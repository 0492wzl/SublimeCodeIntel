Binary files scintilla.orig/.DS_Store and scintilla/.DS_Store differ
diff -ruN scintilla.orig/include/Accessor.h scintilla/include/Accessor.h
--- scintilla.orig/include/Accessor.h	2007-04-06 19:57:02.000000000 -0500
+++ scintilla/include/Accessor.h	2011-05-29 23:24:12.000000000 -0500
@@ -5,6 +5,9 @@
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#ifndef ACCESSOR_H_
+#define ACCESSOR_H_
+
 enum { wsSpace = 1, wsTab = 2, wsSpaceTab = 4, wsInconsistent=8};
 
 class Accessor;
@@ -77,3 +80,5 @@
 	virtual int IndentAmount(int line, int *flags, PFNIsCommentLeader pfnIsCommentLeader = 0)=0;
 	virtual void IndicatorFill(int start, int end, int indicator, int value)=0;
 };
+
+#endif // ACCESSOR_H_
\ No newline at end of file
Binary files scintilla.orig/include/Face.pyc and scintilla/include/Face.pyc differ
diff -ruN scintilla.orig/include/KeyWords.h scintilla/include/KeyWords.h
--- scintilla.orig/include/KeyWords.h	2009-07-21 04:05:43.000000000 -0500
+++ scintilla/include/KeyWords.h	2011-05-29 23:34:09.000000000 -0500
@@ -5,6 +5,11 @@
 // Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
+#ifndef KEYWORDS_H_
+#define KEYWORDS_H_
+
+#include "Accessor.h"
+
 #ifdef SCI_NAMESPACE
 namespace Scintilla {
 #endif
@@ -111,3 +116,5 @@
 		return true;
 	return false;
 }
+
+#endif // KEYWORDS_H_
diff -ruN scintilla.orig/include/SciLexer.h scintilla/include/SciLexer.h
--- scintilla.orig/include/SciLexer.h	2010-02-06 18:26:01.000000000 -0600
+++ scintilla/include/SciLexer.h	2011-05-29 21:52:37.000000000 -0500
@@ -111,6 +111,8 @@
 #define SCLEX_NIMROD 96
 #define SCLEX_SML 97
 #define SCLEX_MARKDOWN 98
+#define SCLEX_XSLT 99
+#define SCLEX_UDL 100
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -128,6 +130,10 @@
 #define SCE_P_STRINGEOL 13
 #define SCE_P_WORD2 14
 #define SCE_P_DECORATOR 15
+#define SCE_P_STDIN   16
+#define SCE_P_STDOUT   17
+#define SCE_P_STDERR   18
+#define SCE_P_UPPER_BOUND 19
 #define SCE_C_DEFAULT 0
 #define SCE_C_COMMENT 1
 #define SCE_C_COMMENTLINE 2
@@ -148,6 +154,12 @@
 #define SCE_C_COMMENTDOCKEYWORD 17
 #define SCE_C_COMMENTDOCKEYWORDERROR 18
 #define SCE_C_GLOBALCLASS 19
+#define SCE_C_STDIN 20
+#define SCE_C_STDOUT 21
+#define SCE_C_STDERR 22
+#define SCE_C_COFFEESCRIPT_COMMENTBLOCK 23
+#define SCE_C_COFFEESCRIPT_VERBOSE_REGEX 24
+#define SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT 25
 #define SCE_D_DEFAULT 0
 #define SCE_D_COMMENT 1
 #define SCE_D_COMMENTLINE 2
@@ -173,26 +185,20 @@
 #define SCE_D_WORD7 22
 #define SCE_TCL_DEFAULT 0
 #define SCE_TCL_COMMENT 1
-#define SCE_TCL_COMMENTLINE 2
-#define SCE_TCL_NUMBER 3
-#define SCE_TCL_WORD_IN_QUOTE 4
-#define SCE_TCL_IN_QUOTE 5
-#define SCE_TCL_OPERATOR 6
-#define SCE_TCL_IDENTIFIER 7
-#define SCE_TCL_SUBSTITUTION 8
-#define SCE_TCL_SUB_BRACE 9
-#define SCE_TCL_MODIFIER 10
-#define SCE_TCL_EXPAND 11
-#define SCE_TCL_WORD 12
-#define SCE_TCL_WORD2 13
-#define SCE_TCL_WORD3 14
-#define SCE_TCL_WORD4 15
-#define SCE_TCL_WORD5 16
-#define SCE_TCL_WORD6 17
-#define SCE_TCL_WORD7 18
-#define SCE_TCL_WORD8 19
-#define SCE_TCL_COMMENT_BOX 20
-#define SCE_TCL_BLOCK_COMMENT 21
+#define SCE_TCL_VARIABLE 2
+#define SCE_TCL_ARRAY 3
+#define SCE_TCL_NUMBER 4
+#define SCE_TCL_WORD 5
+#define SCE_TCL_STRING 6
+#define SCE_TCL_CHARACTER 7
+#define SCE_TCL_LITERAL 8
+#define SCE_TCL_IDENTIFIER 9
+#define SCE_TCL_OPERATOR 10
+#define SCE_TCL_EOL 11
+#define SCE_TCL_STDIN 12
+#define SCE_TCL_STDOUT 13
+#define SCE_TCL_STDERR 14
+#define SCE_TCL_UPPER_BOUND 15
 #define SCE_H_DEFAULT 0
 #define SCE_H_TAG 1
 #define SCE_H_TAGUNKNOWN 2
@@ -339,6 +345,13 @@
 #define SCE_PL_SUB_PROTOTYPE 40
 #define SCE_PL_FORMAT_IDENT 41
 #define SCE_PL_FORMAT 42
+#define SCE_PL_SUB 43
+#define SCE_PL_SUB_ARGS 44
+#define SCE_PL_UNKNOWN_FIELD 45
+#define SCE_PL_STDIN 46
+#define SCE_PL_STDOUT 47
+#define SCE_PL_STDERR 48
+#define SCE_PL_UPPER_BOUND 49
 #define SCE_RB_DEFAULT 0
 #define SCE_RB_ERROR 1
 #define SCE_RB_COMMENTLINE 2
@@ -1376,6 +1389,110 @@
 #define SCE_MARKDOWN_CODE 19
 #define SCE_MARKDOWN_CODE2 20
 #define SCE_MARKDOWN_CODEBK 21
+#define SCE_XML_DEFAULT 0
+#define SCE_XML_PROLOG 0
+#define SCE_XML_START_TAG_OPEN 1
+#define SCE_XML_START_TAG_NAME 2
+#define SCE_XML_START_TAG_CLOSE 3
+#define SCE_XML_START_TAG_EMPTY_CLOSE 4
+#define SCE_XML_START_TAG_ATTR_NAME 5
+#define SCE_XML_START_TAG_ATTR_EQUALS 6
+#define SCE_XML_START_TAG_ATTR_QUOT_OPEN 7
+#define SCE_XML_START_TAG_ATTR_QUOT_CONTENT 8
+#define SCE_XML_START_TAG_ATTR_QUOT_CLOSE 9
+#define SCE_XML_START_TAG_ATTR_APOS_OPEN 10
+#define SCE_XML_START_TAG_ATTR_APOS_CONTENT 11
+#define SCE_XML_START_TAG_ATTR_APOS_CLOSE 12
+#define SCE_XML_END_TAG_OPEN 13
+#define SCE_XML_END_TAG_NAME 14
+#define SCE_XML_END_TAG_CLOSE 15
+#define SCE_XML_START_TAG_ATTR_NUMBER 16
+#define SCE_XML_ENTITY_REF 17
+#define SCE_XML_CHAR_REF 18
+#define SCE_XML_DATA_NEWLINE 19
+#define SCE_XML_DATA_CHARS 20
+#define SCE_XML_CDATA_SECT_OPEN 21
+#define SCE_XML_CDATA_SECT_CONTENT 22
+#define SCE_XML_CDATA_SECT_CLOSE 23
+#define SCE_XML_COMMENT_OPEN 24
+#define SCE_XML_COMMENT_CONTENT 25
+#define SCE_XML_COMMENT_CLOSE 26
+#define SCE_XML_PI_OPEN 27
+#define SCE_XML_PI_CONTENT 28
+#define SCE_XML_PI_CLOSE 29
+#define SCE_XML_XML_DECL_OPEN 30
+#define SCE_XML_XML_DECL_CONTENT 31
+#define SCE_XML_XML_DECL_CLOSE 40
+#define SCE_XML_BOM 41
+#define SCE_XPATH_TAG_NAME 42
+#define SCE_XPATH_ATTR_NAME 43
+#define SCE_XPATH_OPEN 44
+#define SCE_XPATH_CONTENT_QUOT 45
+#define SCE_XPATH_CONTENT_APOS 46
+#define SCE_XPATH_CLOSE 47
+#define SCE_XML_START_TAG_WHITE_SPACE 48
+#define SCE_XML_START_TAG_ATTR_UNQUOTED 49
+#define SCE_XML_END_TAG_WHITE_SPACE 50
+#define SCE_XML_DECLARATION_OPEN 51
+#define SCE_XML_DECLARATION_TYPE 52
+#define SCE_XML_DECLN_WHITE_SPACE 53
+#define SCE_XML_DECLN_NAME 54
+#define SCE_XML_DECLN_CLOSE 55
+#define SCE_XML_DECLN_QUOT_CONTENT 56
+#define SCE_XML_DECLN_APOS_CONTENT 57
+#define SCE_XML_DECLN_DATA_CHARS 58
+#define SCE_XML_UPPER_BOUND 59
+#define SCE_UDL_M_DEFAULT 0
+#define SCE_UDL_M_STAGO 1
+#define SCE_UDL_M_TAGNAME 2
+#define SCE_UDL_M_TAGSPACE 3
+#define SCE_UDL_M_ATTRNAME 4
+#define SCE_UDL_M_OPERATOR 5
+#define SCE_UDL_M_STAGC 6
+#define SCE_UDL_M_EMP_TAGC 7
+#define SCE_UDL_M_STRING 8
+#define SCE_UDL_M_ETAGO 9
+#define SCE_UDL_M_ETAGC 10
+#define SCE_UDL_M_ENTITY 11
+#define SCE_UDL_M_PI 12
+#define SCE_UDL_M_CDATA 13
+#define SCE_UDL_M_COMMENT 14
+#define SCE_UDL_CSS_DEFAULT 15
+#define SCE_UDL_CSS_COMMENT 16
+#define SCE_UDL_CSS_NUMBER 17
+#define SCE_UDL_CSS_STRING 18
+#define SCE_UDL_CSS_WORD 19
+#define SCE_UDL_CSS_IDENTIFIER 20
+#define SCE_UDL_CSS_OPERATOR 21
+#define SCE_UDL_CSL_DEFAULT 22
+#define SCE_UDL_CSL_COMMENT 23
+#define SCE_UDL_CSL_COMMENTBLOCK 24
+#define SCE_UDL_CSL_NUMBER 25
+#define SCE_UDL_CSL_STRING 26
+#define SCE_UDL_CSL_WORD 27
+#define SCE_UDL_CSL_IDENTIFIER 28
+#define SCE_UDL_CSL_OPERATOR 29
+#define SCE_UDL_CSL_REGEX 30
+#define SCE_UDL_SSL_DEFAULT 31
+#define SCE_UDL_SSL_COMMENT 40
+#define SCE_UDL_SSL_COMMENTBLOCK 41
+#define SCE_UDL_SSL_NUMBER 42
+#define SCE_UDL_SSL_STRING 43
+#define SCE_UDL_SSL_WORD 44
+#define SCE_UDL_SSL_IDENTIFIER 45
+#define SCE_UDL_SSL_OPERATOR 46
+#define SCE_UDL_SSL_REGEX 47
+#define SCE_UDL_SSL_VARIABLE 48
+#define SCE_UDL_TPL_DEFAULT 49
+#define SCE_UDL_TPL_COMMENT 50
+#define SCE_UDL_TPL_COMMENTBLOCK 51
+#define SCE_UDL_TPL_NUMBER 52
+#define SCE_UDL_TPL_STRING 53
+#define SCE_UDL_TPL_WORD 54
+#define SCE_UDL_TPL_IDENTIFIER 55
+#define SCE_UDL_TPL_OPERATOR 56
+#define SCE_UDL_TPL_VARIABLE 57
+#define SCE_UDL_UPPER_BOUND 57
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff -ruN scintilla.orig/include/Scintilla.iface scintilla/include/Scintilla.iface
--- scintilla.orig/include/Scintilla.iface	2010-03-26 00:31:57.000000000 -0600
+++ scintilla/include/Scintilla.iface	2011-05-29 21:52:07.000000000 -0500
@@ -2299,6 +2299,9 @@
 val SCLEX_NIMROD=96
 val SCLEX_SML=97
 val SCLEX_MARKDOWN=98
+val SCLEX_XSLT=99
+# User-defined languages
+val SCLEX_UDL=100
 
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
@@ -2322,6 +2325,11 @@
 val SCE_P_STRINGEOL=13
 val SCE_P_WORD2=14
 val SCE_P_DECORATOR=15
+# python terminal support
+val SCE_P_STDIN = 16
+val SCE_P_STDOUT = 17
+val SCE_P_STDERR = 18
+val SCE_P_UPPER_BOUND=19
 # Lexical states for SCLEX_CPP
 lex Cpp=SCLEX_CPP SCE_C_
 lex BullAnt=SCLEX_BULLANT SCE_C_
@@ -2345,6 +2353,12 @@
 val SCE_C_COMMENTDOCKEYWORD=17
 val SCE_C_COMMENTDOCKEYWORDERROR=18
 val SCE_C_GLOBALCLASS=19
+val SCE_C_STDIN=20
+val SCE_C_STDOUT=21
+val SCE_C_STDERR=22
+val SCE_C_COFFEESCRIPT_COMMENTBLOCK=23
+val SCE_C_COFFEESCRIPT_VERBOSE_REGEX=24
+val SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT=25
 # Lexical states for SCLEX_D
 lex D=SCLEX_D SCE_D_
 val SCE_D_DEFAULT=0
@@ -2374,26 +2388,22 @@
 lex TCL=SCLEX_TCL SCE_TCL_
 val SCE_TCL_DEFAULT=0
 val SCE_TCL_COMMENT=1
-val SCE_TCL_COMMENTLINE=2
-val SCE_TCL_NUMBER=3
-val SCE_TCL_WORD_IN_QUOTE=4
-val SCE_TCL_IN_QUOTE=5
-val SCE_TCL_OPERATOR=6
-val SCE_TCL_IDENTIFIER=7
-val SCE_TCL_SUBSTITUTION=8
-val SCE_TCL_SUB_BRACE=9
-val SCE_TCL_MODIFIER=10
-val SCE_TCL_EXPAND=11
-val SCE_TCL_WORD=12
-val SCE_TCL_WORD2=13
-val SCE_TCL_WORD3=14
-val SCE_TCL_WORD4=15
-val SCE_TCL_WORD5=16
-val SCE_TCL_WORD6=17
-val SCE_TCL_WORD7=18
-val SCE_TCL_WORD8=19
-val SCE_TCL_COMMENT_BOX=20
-val SCE_TCL_BLOCK_COMMENT=21
+val SCE_TCL_VARIABLE=2
+val SCE_TCL_ARRAY=3
+val SCE_TCL_NUMBER=4
+val SCE_TCL_WORD=5
+val SCE_TCL_STRING=6
+val SCE_TCL_CHARACTER=7
+val SCE_TCL_LITERAL=8
+val SCE_TCL_IDENTIFIER=9
+# SCE_TCL_OPERATOR must == SCE_PL_OPERATOR in order for brace matching
+# to work (until language services better abstract this)
+val SCE_TCL_OPERATOR=10
+val SCE_TCL_EOL=11
+val SCE_TCL_STDIN=12
+val SCE_TCL_STDOUT=13
+val SCE_TCL_STDERR=14
+val SCE_TCL_UPPER_BOUND=15
 # Lexical states for SCLEX_HTML, SCLEX_XML
 lex HTML=SCLEX_HTML SCE_H
 lex XML=SCLEX_XML SCE_H
@@ -2559,6 +2569,14 @@
 val SCE_PL_SUB_PROTOTYPE=40
 val SCE_PL_FORMAT_IDENT=41
 val SCE_PL_FORMAT=42
+### ACTIVESTATE PERL LEXER ADDITIONS
+val SCE_PL_SUB=43
+val SCE_PL_SUB_ARGS=44
+val SCE_PL_UNKNOWN_FIELD=45
+val SCE_PL_STDIN=46
+val SCE_PL_STDOUT=47
+val SCE_PL_STDERR=48
+val SCE_PL_UPPER_BOUND=49
 # Lexical states for SCLEX_RUBY
 lex Ruby=SCLEX_RUBY SCE_RB_
 val SCE_RB_DEFAULT=0
@@ -3743,6 +3761,135 @@
 val SCE_MARKDOWN_CODE=19
 val SCE_MARKDOWN_CODE2=20
 val SCE_MARKDOWN_CODEBK=21
+# Lexical states for the SCLEX_XML (XML files)
+val SCE_XML_DEFAULT=0
+val SCE_XML_PROLOG=0
+val SCE_XML_START_TAG_OPEN=1
+val SCE_XML_START_TAG_NAME=2 
+val SCE_XML_START_TAG_CLOSE=3
+val SCE_XML_START_TAG_EMPTY_CLOSE=4
+val SCE_XML_START_TAG_ATTR_NAME=5  
+val SCE_XML_START_TAG_ATTR_EQUALS=6
+val SCE_XML_START_TAG_ATTR_QUOT_OPEN=7
+val SCE_XML_START_TAG_ATTR_QUOT_CONTENT=8
+val SCE_XML_START_TAG_ATTR_QUOT_CLOSE=9
+val SCE_XML_START_TAG_ATTR_APOS_OPEN=10
+val SCE_XML_START_TAG_ATTR_APOS_CONTENT=11
+val SCE_XML_START_TAG_ATTR_APOS_CLOSE=12
+val SCE_XML_END_TAG_OPEN=13
+val SCE_XML_END_TAG_NAME=14
+val SCE_XML_END_TAG_CLOSE=15
+val SCE_XML_START_TAG_ATTR_NUMBER=16
+val SCE_XML_ENTITY_REF=17
+val SCE_XML_CHAR_REF=18
+val SCE_XML_DATA_NEWLINE=19
+val SCE_XML_DATA_CHARS=20
+val SCE_XML_CDATA_SECT_OPEN=21
+val SCE_XML_CDATA_SECT_CONTENT=22
+val SCE_XML_CDATA_SECT_CLOSE=23
+val SCE_XML_COMMENT_OPEN=24
+val SCE_XML_COMMENT_CONTENT=25
+val SCE_XML_COMMENT_CLOSE=26
+val SCE_XML_PI_OPEN=27
+val SCE_XML_PI_CONTENT=28
+val SCE_XML_PI_CLOSE=29
+val SCE_XML_XML_DECL_OPEN=30
+val SCE_XML_XML_DECL_CONTENT=31
+# Scintilla itself uses 32-39 internally so skip those.
+val SCE_XML_XML_DECL_CLOSE=40
+val SCE_XML_BOM=41
+val SCE_XPATH_TAG_NAME=42
+val SCE_XPATH_ATTR_NAME=43
+val SCE_XPATH_OPEN=44
+val SCE_XPATH_CONTENT_QUOT=45
+val SCE_XPATH_CONTENT_APOS=46
+val SCE_XPATH_CLOSE=47
+val SCE_XML_START_TAG_WHITE_SPACE=48
+val SCE_XML_START_TAG_ATTR_UNQUOTED=49
+val SCE_XML_END_TAG_WHITE_SPACE=50
+val SCE_XML_DECLARATION_OPEN=51
+val SCE_XML_DECLARATION_TYPE=52
+val SCE_XML_DECLN_WHITE_SPACE=53
+val SCE_XML_DECLN_NAME=54
+val SCE_XML_DECLN_CLOSE=55
+val SCE_XML_DECLN_QUOT_CONTENT=56
+val SCE_XML_DECLN_APOS_CONTENT=57
+val SCE_XML_DECLN_DATA_CHARS=58
+val SCE_XML_UPPER_BOUND=59
+
+
+# Lexical states for SCLEX_UDL ("UDL" == user-defined languages)
+# These define the states each UDL needs to define.
+
+# The lexer for these uses a parallel set of states to determine what
+# it's looking at, so some of these states can fold to common colors.
+
+# Specifically:
+# *_DEFAULT => 0
+# *_COMMENT => 15
+# *_COMMENTBLOCK => 15
+# *_NUMBER => 20
+# *_STRING => 21
+# *_OPERATOR => 24
+
+lex UDL=SCLEX_UDL SCE_UDL_
+val SCE_UDL_M_DEFAULT=0
+val SCE_UDL_M_STAGO=1
+val SCE_UDL_M_TAGNAME=2
+val SCE_UDL_M_TAGSPACE=3
+val SCE_UDL_M_ATTRNAME=4
+val SCE_UDL_M_OPERATOR=5
+val SCE_UDL_M_STAGC=6
+val SCE_UDL_M_EMP_TAGC=7
+val SCE_UDL_M_STRING=8
+val SCE_UDL_M_ETAGO=9
+val SCE_UDL_M_ETAGC=10
+val SCE_UDL_M_ENTITY=11
+val SCE_UDL_M_PI=12
+val SCE_UDL_M_CDATA=13
+val SCE_UDL_M_COMMENT=14
+# UDL: style (reduced CSS) language
+# Don't bother reserving slots, just renumber on (hopefully infrequent) changes
+val SCE_UDL_CSS_DEFAULT=15
+val SCE_UDL_CSS_COMMENT=16
+val SCE_UDL_CSS_NUMBER=17
+val SCE_UDL_CSS_STRING=18
+val SCE_UDL_CSS_WORD=19
+val SCE_UDL_CSS_IDENTIFIER=20
+val SCE_UDL_CSS_OPERATOR=21
+# UDL: client-side language
+val SCE_UDL_CSL_DEFAULT=22
+val SCE_UDL_CSL_COMMENT=23
+val SCE_UDL_CSL_COMMENTBLOCK=24
+val SCE_UDL_CSL_NUMBER=25
+val SCE_UDL_CSL_STRING=26
+val SCE_UDL_CSL_WORD=27
+val SCE_UDL_CSL_IDENTIFIER=28
+val SCE_UDL_CSL_OPERATOR=29
+val SCE_UDL_CSL_REGEX=30
+# UDL: server-side
+val SCE_UDL_SSL_DEFAULT=31
+val SCE_UDL_SSL_COMMENT=40
+val SCE_UDL_SSL_COMMENTBLOCK=41
+val SCE_UDL_SSL_NUMBER=42
+val SCE_UDL_SSL_STRING=43
+val SCE_UDL_SSL_WORD=44
+val SCE_UDL_SSL_IDENTIFIER=45
+val SCE_UDL_SSL_OPERATOR=46
+val SCE_UDL_SSL_REGEX=47
+val SCE_UDL_SSL_VARIABLE=48
+# Room for 7 more terms.
+# Specialize template mini-languages (e.g., Perl Template Toolkit, PHP Smarty)
+val SCE_UDL_TPL_DEFAULT=49
+val SCE_UDL_TPL_COMMENT=50
+val SCE_UDL_TPL_COMMENTBLOCK=51
+val SCE_UDL_TPL_NUMBER=52
+val SCE_UDL_TPL_STRING=53
+val SCE_UDL_TPL_WORD=54
+val SCE_UDL_TPL_IDENTIFIER=55
+val SCE_UDL_TPL_OPERATOR=56
+val SCE_UDL_TPL_VARIABLE=57
+val SCE_UDL_UPPER_BOUND=57
 
 # Events
 
diff -ruN scintilla.orig/src/KeyWords.cxx scintilla/src/KeyWords.cxx
--- scintilla.orig/src/KeyWords.cxx	2010-02-16 18:39:46.000000000 -0600
+++ scintilla/src/KeyWords.cxx	2011-05-29 23:28:11.000000000 -0500
@@ -414,7 +414,7 @@
 	LINK_LEXER(lmTACL);
 	LINK_LEXER(lmTADS3);
 	LINK_LEXER(lmTAL);
-	LINK_LEXER(lmTCL);
+	LINK_LEXER(lmTcl);
 	LINK_LEXER(lmTeX);
 	LINK_LEXER(lmVB);
 	LINK_LEXER(lmVBScript);
diff -ruN scintilla.orig/src/LexCPP.cxx scintilla/src/LexCPP.cxx
--- scintilla.orig/src/LexCPP.cxx	2010-02-16 18:39:46.000000000 -0600
+++ scintilla/src/LexCPP.cxx	2011-05-29 16:22:12.000000000 -0500
@@ -25,11 +25,24 @@
 using namespace Scintilla;
 #endif
 
+// KOMODO  see if a style is one of our IO styles
+static inline bool IsIOStyle(int style) {
+	return style == SCE_C_STDIN ||
+		style == SCE_C_STDOUT ||
+		style == SCE_C_STDERR;
+}
+
 static bool IsSpaceEquiv(int state) {
-	return (state <= SCE_C_COMMENTDOC) ||
-		// including SCE_C_DEFAULT, SCE_C_COMMENT, SCE_C_COMMENTLINE
-		(state == SCE_C_COMMENTLINEDOC) || (state == SCE_C_COMMENTDOCKEYWORD) ||
-		(state == SCE_C_COMMENTDOCKEYWORDERROR);
+	return (state <= SCE_C_COMMENTDOC
+	    // including SCE_C_DEFAULT, SCE_C_COMMENT, SCE_C_COMMENTLINE
+	    || state == SCE_C_COMMENTLINEDOC
+	    || state == SCE_C_COMMENTDOCKEYWORD
+	    || state == SCE_C_COMMENTDOCKEYWORDERROR
+	    || state == SCE_C_COFFEESCRIPT_COMMENTBLOCK
+	    || state == SCE_C_COFFEESCRIPT_VERBOSE_REGEX
+	    || state == SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT
+	    || state == SCE_C_WORD
+	    || state == SCE_C_REGEX);
 }
 
 // Preconditions: sc.currentPos points to a character after '+' or '-'.
@@ -50,6 +63,29 @@
 	return false;
 }
 
+static bool followsReturnKeyword(StyleContext &sc, Accessor &styler) {
+    // Don't look at styles, so no need to flush.
+	int pos = (int) sc.currentPos;
+	int currentLine = styler.GetLine(pos);
+	int lineStartPos = styler.LineStart(currentLine);
+	char ch;
+	while (--pos > lineStartPos) {
+		ch = styler.SafeGetCharAt(pos);
+		if (ch != ' ' && ch != '\t') {
+			break;
+		}
+	}
+	const char *retBack = "nruter";
+	const char *s = retBack;
+	while (*s
+	       && pos >= lineStartPos
+	       && styler.SafeGetCharAt(pos) == *s) {
+		s++;
+		pos--;
+	}
+	return !*s;
+}
+
 static void ColouriseCppDoc(unsigned int startPos, int length, int initStyle, WordList *keywordlists[],
                             Accessor &styler, bool caseSensitive) {
 
@@ -77,6 +113,7 @@
 		setWordStart.Add('$');
 		setWord.Add('$');
 	}
+	bool isCoffeeScript = styler.GetPropertyInt("lexer.cpp.coffeescript");
 
 	int chPrevNonWhite = ' ';
 	int visibleChars = 0;
@@ -102,24 +139,35 @@
 	}
 
 	// look back to set chPrevNonWhite properly for better regex colouring
+	int endPos = startPos + length;
 	if (startPos > 0) {
-		int back = startPos;
-		while (--back && IsSpaceEquiv(styler.StyleAt(back)))
+		unsigned int back = startPos;
+		styler.Flush();
+		while (back > 0 && IsSpaceEquiv(styler.StyleAt(--back)))
 			;
 		if (styler.StyleAt(back) == SCE_C_OPERATOR) {
 			chPrevNonWhite = styler.SafeGetCharAt(back);
 		}
+		if (startPos != back) {
+			initStyle = styler.StyleAt(back);
+		}
+		startPos = back;
 	}
 
-	StyleContext sc(startPos, length, initStyle, styler);
+	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
 
 	for (; sc.More(); sc.Forward()) {
 
 		if (sc.atLineStart) {
-			if (sc.state == SCE_C_STRING) {
+			int lineStartState = sc.state;
+			if (!isCoffeeScript
+			    && (lineStartState == SCE_C_STRING
+				|| lineStartState == SCE_C_CHARACTER)) {
 				// Prevent SCE_C_STRINGEOL from leaking back to previous line which
 				// ends with a line continuation by locking in the state upto this position.
-				sc.SetState(SCE_C_STRING);
+				sc.SetState(lineStartState);
+			} else if (IsIOStyle(sc.state)) {
+				sc.SetState(SCE_C_DEFAULT);
 			}
 			// Reset states to begining of colourise so no surprises
 			// if different sets of lines lexed.
@@ -152,7 +200,7 @@
 				}
 				break;
 			case SCE_C_IDENTIFIER:
-				if (!setWord.Contains(sc.ch) || (sc.ch == '.')) {
+				if (!setWord.Contains(sc.ch) || (sc.ch == '.') || (sc.ch == '$')) {
 					char s[1000];
 					if (caseSensitive) {
 						sc.GetCurrent(s, sizeof(s));
@@ -236,7 +284,8 @@
 				}
 				break;
 			case SCE_C_STRING:
-				if (sc.atLineEnd) {
+				if (sc.atLineEnd && !isCoffeeScript) {
+					// coffeescript allows multi-line strings.
 					sc.ChangeState(SCE_C_STRINGEOL);
 				} else if (isIncludePreprocessor) {
 					if (sc.ch == '>') {
@@ -252,7 +301,7 @@
 				}
 				break;
 			case SCE_C_CHARACTER:
-				if (sc.atLineEnd) {
+				if (sc.atLineEnd && !isCoffeeScript) {
 					sc.ChangeState(SCE_C_STRINGEOL);
 				} else if (sc.ch == '\\') {
 					if (sc.chNext == '\"' || sc.chNext == '\'' || sc.chNext == '\\') {
@@ -295,6 +344,34 @@
 				if (sc.ch == '\r' || sc.ch == '\n' || sc.ch == ')') {
 					sc.SetState(SCE_C_DEFAULT);
 				}
+				break;
+			case SCE_C_COFFEESCRIPT_COMMENTBLOCK:
+				if (sc.Match("###")) {
+					sc.ChangeState(SCE_C_COMMENT);
+					sc.Forward();
+					sc.ForwardSetState(SCE_C_DEFAULT);
+				} else if (sc.ch == '\\') {
+					sc.Forward();
+				}
+				break;
+			case SCE_C_COFFEESCRIPT_VERBOSE_REGEX:
+				if (sc.Match("///")) {
+					sc.Forward();
+					sc.ChangeState(SCE_C_REGEX);
+					sc.ForwardSetState(SCE_C_DEFAULT);
+				} else if (sc.Match('#')) {
+					sc.ChangeState(SCE_C_REGEX);
+					sc.SetState(SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT);
+				} else if (sc.ch == '\\') {
+					sc.Forward();
+				}
+				break;
+			case SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT:
+				if (sc.atLineStart) {
+					sc.ChangeState(SCE_C_COMMENT);
+					sc.SetState(SCE_C_COFFEESCRIPT_VERBOSE_REGEX);
+				}
+				break;
 		}
 
 		// Determine if a new state should be entered.
@@ -309,7 +386,7 @@
 				} else {
 					sc.SetState(SCE_C_NUMBER);
 				}
-			} else if (setWordStart.Contains(sc.ch) || (sc.ch == '@')) {
+			} else if (setWordStart.Contains(sc.ch) || (sc.ch == '@') || (sc.ch == '$')) {
 				if (lastWordWasUUID) {
 					sc.SetState(SCE_C_UUID);
 					lastWordWasUUID = false;
@@ -323,14 +400,19 @@
 					sc.SetState(SCE_C_COMMENT);
 				}
 				sc.Forward();	// Eat the * so it isn't used for the end of the comment
-			} else if (sc.Match('/', '/')) {
+			} else if (sc.Match("///") && isCoffeeScript) {
+				sc.SetState(SCE_C_COFFEESCRIPT_VERBOSE_REGEX);
+			} else if (sc.Match('/', '/') && !isCoffeeScript) {
 				if ((sc.Match("///") && !sc.Match("////")) || sc.Match("//!"))
 					// Support of Qt/Doxygen doc. style
 					sc.SetState(SCE_C_COMMENTLINEDOC);
 				else
 					sc.SetState(SCE_C_COMMENTLINE);
-			} else if (sc.ch == '/' && setOKBeforeRE.Contains(chPrevNonWhite) &&
-				(!setCouldBePostOp.Contains(chPrevNonWhite) || !FollowsPostfixOperator(sc, styler))) {
+			} else if (sc.ch == '/'
+				   && (setOKBeforeRE.Contains(chPrevNonWhite)
+				       || followsReturnKeyword(sc, styler))
+				   && (!setCouldBePostOp.Contains(chPrevNonWhite)
+				       || !FollowsPostfixOperator(sc, styler))) {
 				sc.SetState(SCE_C_REGEX);	// JavaScript's RegEx
 			} else if (sc.ch == '\"') {
 				sc.SetState(SCE_C_STRING);
@@ -339,17 +421,25 @@
 				sc.SetState(SCE_C_STRING);
 			} else if (sc.ch == '\'') {
 				sc.SetState(SCE_C_CHARACTER);
-			} else if (sc.ch == '#' && visibleChars == 0) {
-				// Preprocessor commands are alone on their line
-				sc.SetState(SCE_C_PREPROCESSOR);
-				// Skip whitespace between # and preprocessor word
-				do {
-					sc.Forward();
-				} while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
-				if (sc.atLineEnd) {
-					sc.SetState(SCE_C_DEFAULT);
-				} else if (sc.Match("include")) {
-					isIncludePreprocessor = true;
+			} else if (sc.ch == '#' && (isCoffeeScript || visibleChars == 0)) {
+				if (isCoffeeScript) {
+					if (sc.Match("###")) {
+						sc.SetState(SCE_C_COFFEESCRIPT_COMMENTBLOCK);
+					} else {
+						sc.SetState(SCE_C_COMMENTLINE);
+					}
+				} else {
+					// Preprocessor commands are alone on their line
+					sc.SetState(SCE_C_PREPROCESSOR);
+					// Skip whitespace between # and preprocessor word
+					do {
+					    sc.Forward();
+					} while ((sc.ch == ' ' || sc.ch == '\t') && sc.More());
+					if (sc.atLineEnd) {
+					    sc.SetState(SCE_C_DEFAULT);
+					} else if (sc.Match("include")) {
+					    isIncludePreprocessor = true;
+					}
 				}
 			} else if (isoperator(static_cast<char>(sc.ch))) {
 				sc.SetState(SCE_C_OPERATOR);
@@ -362,6 +452,20 @@
 		}
 		continuationLine = false;
 	}
+	if (isCoffeeScript) {
+		// Change temporary coffeescript states into standard C ones.
+		switch (sc.state) {
+			case SCE_C_COFFEESCRIPT_COMMENTBLOCK:
+				sc.ChangeState(SCE_C_COMMENT);
+				break;
+			case SCE_C_COFFEESCRIPT_VERBOSE_REGEX:
+				sc.ChangeState(SCE_C_REGEX);
+				break;
+			case SCE_C_COFFEESCRIPT_VERBOSE_REGEX_COMMENT:
+				sc.ChangeState(SCE_C_COMMENTLINE);
+				break;
+		}
+	}
 	sc.Complete();
 }
 
@@ -372,12 +476,160 @@
 		style == SCE_C_COMMENTDOCKEYWORDERROR;
 }
 
+static bool IsCommentLine(int line, Accessor &styler) {
+	int pos = styler.LineStart(line);
+	int eol_pos = styler.LineStart(line + 1) - 1;
+	for (int i = pos; i < eol_pos; i++) {
+		char ch = styler[i];
+		if (ch == '#')
+			return true;
+        else if (ch == '/'
+                 && i < eol_pos - 1
+                 && styler[i + 1] == '*')
+			return true;
+		else if (ch != ' ' && ch != '\t')
+			return false;
+	}
+	return false;
+}
+
+static void FoldCoffeeScriptDoc(unsigned int startPos, int length, int initStyle,
+				WordList *keywordlists[], Accessor &styler) {
+	// A simplified version of FoldPyDoc
+	const int maxPos = startPos + length;
+	const int maxLines = styler.GetLine(maxPos - 1);             // Requested last line
+	const int docLines = styler.GetLine(styler.Length() - 1);  // Available last line
+
+	// property fold.comment.python
+	const bool foldComment = styler.GetPropertyInt("fold.coffeescript.comment") != 0;
+
+	const bool foldCompact = styler.GetPropertyInt("fold.compact") != 0;
+
+	// Backtrack to previous non-blank line so we can determine indent level
+	// for any white space lines
+	// and so we can fix any preceding fold level (which is why we go back
+	// at least one line in all cases)
+	int spaceFlags = 0;
+	int lineCurrent = styler.GetLine(startPos);
+	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
+	while (lineCurrent > 0) {
+		lineCurrent--;
+		indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
+		if (!(indentCurrent & SC_FOLDLEVELWHITEFLAG)
+		    && !IsCommentLine(lineCurrent, styler))
+			break;
+	}
+	int indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
+
+	// Set up initial loop state
+	startPos = styler.LineStart(lineCurrent);
+	int prev_state = SCE_C_DEFAULT & 31;
+	if (lineCurrent >= 1)
+		prev_state = styler.StyleAt(startPos - 1) & 31;
+	int prevComment = 0;
+	if (lineCurrent >= 1)
+		prevComment = foldComment && IsCommentLine(lineCurrent - 1, styler);
+
+	// Process all characters to end of requested range
+	// or comment that hangs over the end of the range.  Cap processing in all cases
+	// to end of document (in case of comment at end).
+	while ((lineCurrent <= docLines) && ((lineCurrent <= maxLines) || prevComment)) {
+
+		// Gather info
+		int lev = indentCurrent;
+		int lineNext = lineCurrent + 1;
+		int indentNext = indentCurrent;
+		if (lineNext <= docLines) {
+			// Information about next line is only available if not at end of document
+			indentNext = styler.IndentAmount(lineNext, &spaceFlags, NULL);
+		}
+		const int comment = foldComment && IsCommentLine(lineCurrent, styler);
+		const int comment_start = (comment && !prevComment && (lineNext <= docLines) &&
+		                           IsCommentLine(lineNext, styler) && (lev > SC_FOLDLEVELBASE));
+		const int comment_continue = (comment && prevComment);
+		if (!comment)
+			indentCurrentLevel = indentCurrent & SC_FOLDLEVELNUMBERMASK;
+		if (indentNext & SC_FOLDLEVELWHITEFLAG)
+			indentNext = SC_FOLDLEVELWHITEFLAG | indentCurrentLevel;
+
+		if (comment_start) {
+			// Place fold point at start of a block of comments
+			lev |= SC_FOLDLEVELHEADERFLAG;
+		} else if (comment_continue) {
+			// Add level to rest of lines in the block
+			lev = lev + 1;
+		}
+
+		// Skip past any blank lines for next indent level info; we skip also
+		// comments (all comments, not just those starting in column 0)
+		// which effectively folds them into surrounding code rather
+		// than screwing up folding.
+
+		while ((lineNext < docLines) &&
+		        ((indentNext & SC_FOLDLEVELWHITEFLAG) ||
+		         (lineNext <= docLines && IsCommentLine(lineNext, styler)))) {
+
+			lineNext++;
+			indentNext = styler.IndentAmount(lineNext, &spaceFlags, NULL);
+		}
+
+		const int levelAfterComments = indentNext & SC_FOLDLEVELNUMBERMASK;
+		const int levelBeforeComments = Platform::Maximum(indentCurrentLevel,levelAfterComments);
+
+		// Now set all the indent levels on the lines we skipped
+		// Do this from end to start.  Once we encounter one line
+		// which is indented more than the line after the end of
+		// the comment-block, use the level of the block before
+
+		int skipLine = lineNext;
+		int skipLevel = levelAfterComments;
+
+		while (--skipLine > lineCurrent) {
+			int skipLineIndent = styler.IndentAmount(skipLine, &spaceFlags, NULL);
+
+			if (foldCompact) {
+				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments)
+					skipLevel = levelBeforeComments;
+
+				int whiteFlag = skipLineIndent & SC_FOLDLEVELWHITEFLAG;
+
+				styler.SetLevel(skipLine, skipLevel | whiteFlag);
+			} else {
+				if ((skipLineIndent & SC_FOLDLEVELNUMBERMASK) > levelAfterComments &&
+					!(skipLineIndent & SC_FOLDLEVELWHITEFLAG) &&
+					!IsCommentLine(skipLine, styler))
+					skipLevel = levelBeforeComments;
+
+				styler.SetLevel(skipLine, skipLevel);
+			}
+		}
+
+		// Set fold header on non-comment line
+		if (!comment && !(indentCurrent & SC_FOLDLEVELWHITEFLAG)) {
+			if ((indentCurrent & SC_FOLDLEVELNUMBERMASK) < (indentNext & SC_FOLDLEVELNUMBERMASK))
+				lev |= SC_FOLDLEVELHEADERFLAG;
+		}
+
+		// Keep track of block comment state of previous line
+		prevComment = comment_start || comment_continue;
+
+		// Set fold level for this line and move to next line
+		styler.SetLevel(lineCurrent, lev);
+		indentCurrent = indentNext;
+		lineCurrent = lineNext;
+	}
+}
+
 // Store both the current line's fold level and the next lines in the
 // level store to make it easy to pick up with each increment
 // and to make it possible to fiddle the current level for "} else {".
 static void FoldCppDoc(unsigned int startPos, int length, int initStyle,
-					   WordList *[], Accessor &styler) {
+					   WordList *keywordlists[], Accessor &styler) {
 
+	if (styler.GetPropertyInt("lexer.cpp.coffeescript")) {
+		FoldCoffeeScriptDoc(startPos, length, initStyle, keywordlists, styler);
+		return;
+	}
 	// property fold.comment
 	//	This option enables folding multi-line comments and explicit fold points when using the C++ lexer.
 	//	Explicit fold points allows adding extra folding by placing a //{ comment at the start and a //}
@@ -452,8 +704,12 @@
 					levelMinCurrent = levelNext;
 				}
 				levelNext++;
-			} else if (ch == '}') {
-				levelNext--;
+			} else if (ch == '[') {
+				levelNext++;
+			} else if (ch == '}' || ch == ']') {
+				if ((levelNext & (SC_FOLDLEVELNUMBERMASK & ~SC_FOLDLEVELBASE)) > 0) {
+					levelNext--;
+				}
 			}
 		}
 		if (!IsASpace(ch))
diff -ruN scintilla.orig/src/LexPerl.cxx scintilla/src/LexPerl.cxx
--- scintilla.orig/src/LexPerl.cxx	2009-07-01 04:54:33.000000000 -0500
+++ scintilla/src/LexPerl.cxx	2011-02-11 10:17:02.000000000 -0600
@@ -1,9 +1,8 @@
 // Scintilla source code edit control
 /** @file LexPerl.cxx
- ** Lexer for Perl.
+ ** Lexer for subset of Perl.
  **/
-// Copyright 1998-2008 by Neil Hodgson <neilh@scintilla.org>
-// Lexical analysis fixes by Kein-Hong Man <mkh@pl.jaring.my>
+// Copyright 1998-2001 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
 
 #include <stdlib.h>
@@ -16,1290 +15,2380 @@
 
 #include "PropSet.h"
 #include "Accessor.h"
-#include "StyleContext.h"
 #include "KeyWords.h"
 #include "Scintilla.h"
 #include "SciLexer.h"
-#include "CharacterSet.h"
 
 #ifdef SCI_NAMESPACE
 using namespace Scintilla;
 #endif
 
-// Info for HERE document handling from perldata.pod (reformatted):
-// ----------------------------------------------------------------
-// A line-oriented form of quoting is based on the shell ``here-doc'' syntax.
-// Following a << you specify a string to terminate the quoted material, and
-// all lines following the current line down to the terminating string are
-// the value of the item.
-// * The terminating string may be either an identifier (a word), or some
-//   quoted text.
-// * If quoted, the type of quotes you use determines the treatment of the
-//   text, just as in regular quoting.
-// * An unquoted identifier works like double quotes.
-// * There must be no space between the << and the identifier.
-//   (If you put a space it will be treated as a null identifier,
-//    which is valid, and matches the first empty line.)
-//   (This is deprecated, -w warns of this syntax)
-// * The terminating string must appear by itself (unquoted and
-//   with no surrounding whitespace) on the terminating line.
-
-#define HERE_DELIM_MAX 256		// maximum length of HERE doc delimiter
-
-#define PERLNUM_BINARY		1	// order is significant: 1-4 cannot have a dot
-#define PERLNUM_HEX			2
-#define PERLNUM_OCTAL		3
-#define PERLNUM_FLOAT_EXP	4	// exponent part only
-#define PERLNUM_DECIMAL		5	// 1-5 are numbers; 6-7 are strings
-#define PERLNUM_VECTOR		6
-#define PERLNUM_V_VECTOR	7
-#define PERLNUM_BAD			8
-
-#define BACK_NONE		0	// lookback state for bareword disambiguation:
-#define BACK_OPERATOR	1	// whitespace/comments are insignificant
-#define BACK_KEYWORD	2	// operators/keywords are needed for disambiguation
+static inline void advanceOneChar(unsigned int& i, char&ch, char& chNext, char chNext2) {
+    i++;
+    ch = chNext;
+    chNext = chNext2;
+}
+
+static inline void retreatOneChar(unsigned int& i, char& chPrev, char& ch, char& chNext) {
+    i--;
+    chNext = ch;
+    ch = chPrev;
+}
+
+// This is ASCII specific but is safe with chars >= 0x80
+
+static inline bool isEOLChar(char ch) {
+    return (ch == '\r') || (ch == '\n');
+}
+
+static inline bool isSingleCharOp(char ch) {
+    return strchr("rwxoRWXOezsfdlpSbctugkTBMAC", ch) != NULL;
+}
+
+static inline bool isPerlOperator(char ch) {
+    return strchr("%^&*\\()-+=|{}[]:;<>,/?!.~",ch) != NULL;
+}
+
+static inline bool isHereDocStyle(int style) {
+    return style == SCE_PL_HERE_Q || style == SCE_PL_HERE_DELIM;
+}
+
+// Assume high-bit chars are part of a utf-8 name, not part of
+// something like a non-breaking space or fancy hyphen
+
+static inline bool isSafeAlpha(char ch) {
+    return ((unsigned int) ch >= 128) || isalpha(ch);
+}
+
+static inline bool isSafeAlnum(char ch) {
+    return ((unsigned int) ch >= 128) || isalnum(ch) || ch == '_';
+}
+
+// Digits on the other hand don't have utf-8 representations.
+static inline bool isSafeDigit(char ch) {
+    return ((unsigned int) ch <= 127) && isdigit(ch);
+}
+
+static inline bool isSimpleWS(char ch) {
+    return (ch == ' ') || (ch == '\t');
+}
+
+static inline char safeStyleAt(int pos, Accessor &styler) {
+    return ((char) (((unsigned int)styler.StyleAt(pos)) & 0x3f)); // 6 bits
+}
+
+static inline int columnStartPos(int pos, Accessor &styler) {
+    return pos - styler.LineStart(styler.GetLine(pos));
+}
+
+static bool isFatCommaNext(Accessor &styler, unsigned int startIndex, unsigned int length) {
+    bool inComment = false;
+    unsigned int i;
+    for (i = startIndex;i < length;i++) {
+        char ch = styler.SafeGetCharAt(i);
+        if (inComment) {
+            if (isEOLChar(ch)) {
+                inComment = false;
+            }
+        } else if (ch == '=') {
+            if (styler.SafeGetCharAt(i+1) == '>') {
+                return true;
+            }
+        } else if (ch == '#') {
+            inComment = true;
+        } else if (!isspacechar(ch)) {
+            break;
+        }
+    }
+
+    return false;
+}
+
+static int classifyWordPerl(unsigned int start, unsigned int end, unsigned int length,
+                            WordList &keywords, Accessor &styler,
+                            bool *p_BraceStartsBlock)
+{
+    char ch, s[51];
+    ch = styler[start];
+    bool wordIsNumber = (((unsigned int) ch) < 128
+                         && (isdigit(ch) || (ch == '.')));
+    bool isSimpleWord = true;
+    
+    // Copy the word into a local buffer.
+    unsigned int i;
+    for (i = 0; i < end - start + 1 && i < 50; i++) {
+        ch = styler[start+i];
+        if (isSimpleWord && !isSafeAlnum(ch) && !(i == 0 && ch == '-')) {
+            isSimpleWord = false;
+        }
+        s[i] = ch;
+    }
+    s[i] = '\0';
+    
+    // Choose and apply a colour style for the word.
+    if (p_BraceStartsBlock) {
+        *p_BraceStartsBlock = true;
+    }
+    char chAttr = SCE_PL_IDENTIFIER;
+    if (wordIsNumber) {
+        chAttr = SCE_PL_NUMBER;
+    } else if (isSimpleWord && isFatCommaNext(styler,end+1,length)) {
+        chAttr = SCE_PL_STRING_Q;
+    } else if (keywords.InList(s)) {
+        chAttr = SCE_PL_WORD;
+        if (p_BraceStartsBlock
+            && (!strcmp(s, "bless")
+                || !strcmp(s, "return")
+                || !strcmp(s, "ref"))) {
+            *p_BraceStartsBlock = false;
+        }
+    }
+    styler.ColourTo(end, chAttr);
+    return chAttr;
+}
+
+//precondition: styler[start..end] is a keyword
+
+static bool RE_CanFollowKeyword(unsigned int start, unsigned int end,
+                                Accessor &styler)
+{
+    char ch, s[53];
+    ch = styler[start];
+    unsigned int i;
+    // Copy the word into a local buffer.
+    s[0] = '|';
+    for (i = 0; i < end - start + 1 && i < 51; i++) {
+        s[i + 1] = styler[start+i];
+    }
+    s[i + 1] = '|';
+    s[i + 2] = '\0';
+    const char *no_RE_KwdList = 
+        "|while|if|unless|until|and|or|not|xor|split|grep|map|print|";
+    return strstr(no_RE_KwdList, s) != NULL;
+}
+
+// Let's look back: if we see /(^|;(10))\s*\w+(5|11)\s(0)*<here>/, return true
+// Precondition: i points to the end of the text we're trying to match
+
+static bool afterLabel(int pos, Accessor &styler)
+{
+    char ch;
+    int style;
+    styler.Flush();
+    for (; pos >= 0; pos--) {
+        ch = styler.SafeGetCharAt(pos);
+        if (isSimpleWS(ch)) {
+            style = safeStyleAt(pos, styler);
+            if (style != SCE_PL_DEFAULT) {
+                return false;
+            }
+        } else {
+            break;
+        }
+    }
+    // at the start of the line ... report failure anyway
+    if (pos < 0) {
+        return false;
+    }
+    int curr_pos = pos;
+    for (; pos >= 0; pos--) {
+        style = safeStyleAt(pos, styler);
+        if (style != SCE_PL_WORD && style != SCE_PL_IDENTIFIER) {
+            break;
+        }
+    }
+    if (pos == curr_pos) {
+        // we didn't retreat, so we're aren't looking at a word
+        return false;
+    }
+    for (; pos >= 0; pos--) {
+        ch = styler.SafeGetCharAt(pos);
+        if (!isSimpleWS(ch)) {
+            break;
+        }
+    }
+    if (pos < 0) {
+        return true;
+    }
+    ch = styler.SafeGetCharAt(pos);
+    return strchr("\n:{}", ch) != NULL;
+}
+
+static inline bool isEndVar(char ch) {
+    return !isSafeAlnum(ch) && !strchr("#$_\'[{",ch);
+}
 
-static bool isPerlKeyword(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler)
+static bool isMatch(Accessor &styler, int lengthDoc, int pos, const char *val) {
+    if ((pos + static_cast<int>(strlen(val))) >= lengthDoc) {
+        return false;
+    }
+    while (*val) {
+        if (*val != styler[pos++]) {
+            return false;
+        }
+        val++;
+    }
+    return true;
+}
+
+
+// It's harder to look forward than backward, but it's more correct:
+// Makes fewer assumptions about what scintilla innards are doing.
+
+static bool atStartOfFormatStmt(unsigned int &pos,
+                                int lengthDoc,
+                                Accessor &styler) 
 {
-	// old-style keyword matcher; needed because GetCurrent() needs
-	// current segment to be committed, but we may abandon early...
-	char s[100];
-	unsigned int i, len = end - start;
-	if (len > 30) { len = 30; }
-	for (i = 0; i < len; i++, start++) s[i] = styler[start];
-	s[i] = '\0';
-	return keywords.InList(s);
+    // <format:word> to left, match ws+, <word|ident>, ws*, '='
+    // First just match the chars.  If the chars match,
+    // paint them correctly, and return true.
+
+    int positions[5];
+    // {start, end of ws-1, end-of-ident, end of ws-2, '='
+
+    char ch;
+    positions[0] = pos;
+    ch = styler.SafeGetCharAt(pos);
+
+    if (pos + 3 >= (unsigned int)lengthDoc) {
+        return false;
+    }
+    
+    int testPos = pos + 1;
+
+    ch = styler.SafeGetCharAt(testPos);
+    if (!isSimpleWS(ch)) {
+        return false;
+    }
+
+    // Match <ws>
+    for (; testPos < lengthDoc; testPos++) {
+        ch = styler.SafeGetCharAt(testPos);
+        if (!isSimpleWS(ch)) {
+            break;
+        }
+    }
+    positions[1] = testPos - 1;
+
+    // Match <ident>
+    ch = styler.SafeGetCharAt(testPos);
+    if (!(isSafeAlpha(ch) || ch == '_')) {
+        return false;
+    }
+    for (testPos++; testPos < lengthDoc; testPos++) {
+        ch = styler.SafeGetCharAt(testPos);
+        if (!isSafeAlnum(ch)) {
+            break;
+        }
+    }
+    positions[2] = testPos - 1;
+    
+    // Match <ws?>
+    for (; testPos < lengthDoc; testPos++) {
+        ch = styler.SafeGetCharAt(testPos);
+        if (!isSimpleWS(ch)) {
+            break;
+        }
+    }
+    positions[3] = testPos - 1;
+
+    if (testPos >= lengthDoc) {
+        return false;
+    }
+    ch = styler.SafeGetCharAt(testPos);
+    if (ch == '=') {
+        positions[4] = testPos;
+    } else {
+        return false;
+    }
+
+    // Now color the line we matched based on the positions,
+    // and update the final state.
+    //
+    // Don't match the newline in this routine -- let the standard
+    // newline-handling code deal with it.
+
+    int styles[4] = {SCE_PL_DEFAULT,
+                     SCE_PL_IDENTIFIER,
+                     SCE_PL_DEFAULT,
+                     SCE_PL_OPERATOR
+    };
+    int idx;
+    styler.ColourTo(pos, SCE_PL_WORD);
+    for (idx = 0; idx < 4; idx++) {
+        if (positions[idx + 1] > positions[idx]) {
+            styler.ColourTo(positions[idx + 1], styles[idx]);
+        }
+    }
+    // Leave it pointing at the '='
+    pos = testPos;
+    styler.Flush();
+    return true;
+}
+
+
+static char opposite(char ch) {
+    if (ch == '(')
+        return ')';
+    if (ch == '[')
+        return ']';
+    if (ch == '{')
+        return '}';
+    if (ch == '<')
+        return '>';
+    return ch;
+}
+
+// Calculates the current fold level (for the relevant line) when the lexer has 
+// parsed up to the given index.
+int getFoldLevelModifier(Accessor& styler, int startIndex, int endIndex) {
+    int modifier = 0;
+    int index;
+    styler.Flush();
+    for (index = startIndex;index < endIndex;index++) {
+        int style = safeStyleAt(index, styler);
+        if (style == SCE_PL_OPERATOR || style == SCE_PL_VARIABLE_INDEXER) {
+            char ch = styler.SafeGetCharAt(index);
+            if (ch == '{' || ch == '(' || ch == '[') {
+                modifier++;
+            } else if (ch == '}' || ch == ')' || ch == ']') {
+                modifier--;
+            }
+        }
+    }
+    return modifier;
+}    
+
+/* Leading dashes are allowed only in some places before fat-commas,
+ * such as inside hash definitions.
+ * This code doesn't know which context it's called in, so will always
+ * report a string with a leading dash as a bareword.  If it isn't,
+ * the code is invalid.  Editor users will see an error indicator.
+ * Other clients of this code are unlikely to call this incorrectly,
+ * as they're most likely using it to analyze correct code.
+ */
+
+static bool isWordBeforeFatComma(Accessor &styler, unsigned int startIndex, 
+                                 unsigned int length) {
+    unsigned int i = startIndex;
+    // Allow a '-' at the start
+    if (i < length && styler.SafeGetCharAt(i) == '-') {
+        ++i;
+    }
+    for (; i < length; i++) {
+        char ch = styler.SafeGetCharAt(i);
+        if (!isSafeAlnum(ch)) {
+            break;
+        }
+    }
+    return isFatCommaNext(styler,i,length);
+}
+
+static bool isInterpolatingString(int style, char ch) {
+    switch(style) {
+    case SCE_PL_STRING_QQ:
+    case SCE_PL_STRING:
+    case SCE_PL_STRING_QX:
+    case SCE_PL_BACKTICKS:
+        return isSafeAlnum(ch) || ch == '_';
+    }
+    return false;
 }
 
-static int disambiguateBareword(Accessor &styler, unsigned int bk, unsigned int fw,
-                                int backFlag, unsigned int backPos, unsigned int endPos)
+static void doInterpolateVariable(unsigned int&         i,
+                                  unsigned int          lengthDoc,
+                                  int                   state,
+                                  char&                 ch,
+                                  Accessor&             styler) {
+    // bug 34374: color interpolated variables
+    styler.ColourTo(i - 1, state);
+    int variableType = ch == '$' ? SCE_PL_SCALAR : SCE_PL_ARRAY;
+    // Enter a mini-mode to color scalars and arrays inside strings
+    while (++i < lengthDoc) {
+        ch = styler.SafeGetCharAt(i);
+        if (!isSafeAlnum(ch) && ch != '_') {
+            break;
+        }
+    }
+    styler.ColourTo(i - 1, variableType);
+}
+
+// support checking backwards for
+
+// You can't always look for styles, because the entire sequence hasn't been
+// restyled yet.  YOu need to do a lex analysis:
+
+// {[indexer], \s*, [-]?[a-zA-Z0-9_]+, \s*
+
+static bool followsStartIndexer(Accessor &styler, unsigned int index)
 {
-	// identifiers are recognized by Perl as barewords under some
-	// conditions, the following attempts to do the disambiguation
-	// by looking backward and forward; result in 2 LSB
-	int result = 0;
-	bool moreback = false;		// true if passed newline/comments
-	bool brace = false;			// true if opening brace found
-	// if BACK_NONE, neither operator nor keyword, so skip test
-	if (backFlag == BACK_NONE)
-		return result;
-	// first look backwards past whitespace/comments to set EOL flag
-	// (some disambiguation patterns must be on a single line)
-	if (backPos <= static_cast<unsigned int>(styler.LineStart(styler.GetLine(bk))))
-		moreback = true;
-	// look backwards at last significant lexed item for disambiguation
-	bk = backPos - 1;
-	int ch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
-	if (ch == '{' && !moreback) {
-		// {bareword: possible variable spec
-		brace = true;
-	} else if ((ch == '&' && styler.SafeGetCharAt(bk - 1) != '&')
-			// &bareword: subroutine call
-			   || styler.Match(bk - 1, "->")
-			// ->bareword: part of variable spec
-			   || styler.Match(bk - 2, "sub")) {
-			// sub bareword: subroutine declaration
-			// (implied BACK_KEYWORD, no keywords end in 'sub'!)
-		result |= 1;
-	}
-	// next, scan forward after word past tab/spaces only;
-	// if ch isn't one of '[{(,' we can skip the test
-	if ((ch == '{' || ch == '(' || ch == '['|| ch == ',')
-		&& fw < endPos) {
-		while (ch = static_cast<unsigned char>(styler.SafeGetCharAt(fw)),
-			   IsASpaceOrTab(ch) && fw < endPos) {
-			fw++;
-		}
-		if ((ch == '}' && brace)
-			// {bareword}: variable spec
-			|| styler.Match(fw, "=>")) {
-			// [{(, bareword=>: hash literal
-			result |= 2;
-		}
-	}
-	return result;
+    char ch;
+    int style;
+    if (index > 0x0fffffff) return false;
+    long i = 0x0fffffff & index;
+    // First check for trailing default <anything> (since we haven't colorized it yet
+    for (; i >= 0; i--) {        
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            break;
+        }
+    }
+
+    // Now check for word-chars
+    // The '< 1' test is intended to select out
+    // negative values where char's range from 0 .. 255,
+    // and the 'ch >= 127' for where char's range over -128 .. 127
+    for (; i >= 0; i--) {        
+        ch = styler[i];
+        if (!isSafeAlnum(ch)) {
+            break;
+        }
+    }
+    // Optional leading '-'
+    if (i >= 0 && styler[i] == '-')
+        --i;
+
+    // Leading space
+    for (; i >= 0; i--) {        
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            break;
+        }
+    }
+
+    if (i < 0) {
+        return false;
+    }
+    style = safeStyleAt(i, styler);
+    if (style != SCE_PL_VARIABLE_INDEXER) {
+        return false;
+    }
+    ch = styler[i];
+    return (ch == '{');
 }
 
-static void skipWhitespaceComment(Accessor &styler, unsigned int &p)
+/* Match <space>*, -? [\w\d_]+, <space>*, } */
+static bool lookingAtBareword(Accessor &styler, unsigned int index,
+                              unsigned int actualLengthDoc) 
 {
-	// when backtracking, we need to skip whitespace and comments
-	int style;
-	while ((p > 0) && (style = styler.StyleAt(p),
-		   style == SCE_PL_DEFAULT || style == SCE_PL_COMMENTLINE))
-		p--;
+    if (index > 0x0fffffff) return false;
+    char ch = ' ';
+    unsigned int i = (index & 0x0fffffff); // signed index
+    for (; i < actualLengthDoc; i++) {
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            break;
+        }
+    }
+    if (i < actualLengthDoc - 1 && ch == '-') {
+        ch = styler[++i];
+    }
+    // Make sure we have a character
+    if (i >= actualLengthDoc || !isSafeAlnum(ch)) {
+        return false;
+    }
+    for (i++; i < actualLengthDoc; i++) {
+        ch = styler[i];
+        if (!isSafeAlnum(ch)) {
+            break;
+        }
+    }
+    // Use the char set in the char-skipping loop
+    for(;;) {
+        if (!isspacechar(ch)) {
+            break;
+        }
+        if (i >= actualLengthDoc - 1) {
+            break;
+        }
+        ch = styler[++i];
+    }
+    return (i < actualLengthDoc && ch == '}');
 }
 
-static int styleBeforeBracePair(Accessor &styler, unsigned int bk)
+static char colouriseBareword(Accessor &styler, unsigned int &i, int &state,
+                              unsigned int actualLengthDoc)
 {
-	// backtrack to find open '{' corresponding to a '}', balanced
-	// return significant style to be tested for '/' disambiguation
-	int braceCount = 1;
-	if (bk == 0)
-		return SCE_PL_DEFAULT;
-	while (--bk > 0) {
-		if (styler.StyleAt(bk) == SCE_PL_OPERATOR) {
-			int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
-			if (bkch == ';') {	// early out
-				break;
-			} else if (bkch == '}') {
-				braceCount++;
-			} else if (bkch == '{') {
-				if (--braceCount == 0) break;
-			}
-		}
-	}
-	if (bk > 0 && braceCount == 0) {
-		// balanced { found, bk > 0, skip more whitespace/comments
-		bk--;
-		skipWhitespaceComment(styler, bk);
-		return styler.StyleAt(bk);
-	}
-	return SCE_PL_DEFAULT;
+    // We're going to colorize everything here to avoid
+    // further complicating the state machine.
+
+    char ch = ' ';
+    for (i++; i < actualLengthDoc; i++) {
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            break;
+        }
+    }
+    // fprintf(stderr, "Color as default to posn %d\n", i - 1);
+    styler.ColourTo(i - 1, SCE_PL_DEFAULT);
+    if (ch == '-') {
+        ch = styler[++i];
+    }
+    for (; i < actualLengthDoc; i++) {
+        ch = styler[i];
+        if (!isSafeAlnum(ch)) {
+            break;
+        }
+    }
+    styler.ColourTo(i - 1, SCE_PL_STRING);
+    // fprintf(stderr, "Color as string to posn %d\n", i - 1);
+    for (; i < actualLengthDoc; i++) {
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            break;
+        }
+    }
+    styler.ColourTo(i - 1, SCE_PL_DEFAULT);
+    // fprintf(stderr, "Color as space to posn %d\n", i - 1);
+    i -= 1;
+    state = SCE_PL_DEFAULT;
+    return styler[i]; // The last char we found
 }
 
-static int styleCheckIdentifier(Accessor &styler, unsigned int bk)
+static bool precedesIndexer(Accessor &styler, unsigned int index,
+                            unsigned int endPoint)
 {
-	// backtrack to classify sub-styles of identifier under test
-	// return sub-style to be tested for '/' disambiguation
-	if (styler.SafeGetCharAt(bk) == '>')	// inputsymbol, like <foo>
-		return 1;
-	// backtrack to check for possible "->" or "::" before identifier
-	while (bk > 0 && styler.StyleAt(bk) == SCE_PL_IDENTIFIER) {
-		bk--;
-	}
-	while (bk > 0) {
-		int bkstyle = styler.StyleAt(bk);
-		if (bkstyle == SCE_PL_DEFAULT
-			|| bkstyle == SCE_PL_COMMENTLINE) {
-			// skip whitespace, comments
-		} else if (bkstyle == SCE_PL_OPERATOR) {
-			// test for "->" and "::"
-			if (styler.Match(bk - 1, "->") || styler.Match(bk - 1, "::"))
-				return 2;
-		} else
-			return 3;	// bare identifier
-		bk--;
-	}
-	return 0;
+    if (index > 0x0fffffff) return false;
+    unsigned int i = 0x0fffffff & index;
+    if (i >= endPoint) {
+        return false;
+    }
+    char ch;
+    // Look for \s*\}, return false on anything else.
+    for (; i < endPoint; i++) {
+        ch = styler[i];
+        if (!isspacechar(ch)) {
+            return (ch == '}');
+            break;
+        }
+    }
+    return false;
 }
 
-static int inputsymbolScan(Accessor &styler, unsigned int pos, unsigned int endPos)
+
+static bool wordEndsHere(char chNext, char chNext2, bool no_namespace_op)
 {
-	// looks forward for matching > on same line; a bit ugly
-	unsigned int fw = pos;
-	while (++fw < endPos) {
-		int fwch = static_cast<unsigned char>(styler.SafeGetCharAt(fw));
-		if (fwch == '\r' || fwch == '\n') {
-			return 0;
-		} else if (fwch == '>') {
-			if (styler.Match(fw - 2, "<=>"))	// '<=>' case
-				return 0;
-			return fw - pos;
-		}
-	}
-	return 0;
+    // ".." is always an operator if preceded by a SCE_PL_WORD.
+    // "." is an operator unless we're inside a number thing
+    // Archaic Perl has quotes inside names
+    
+    if (chNext == '.') {
+        return true;
+    } else if (chNext == ':' && chNext2 == ':' && no_namespace_op) {
+        return false;
+    } else if (iswordchar(chNext)) {
+        return false;
+    } else if (chNext != '\'') {
+        return true;
+    } else {
+        return !iswordstart(chNext2);  // ada-like $pkg'member
+    }
 }
 
-static int podLineScan(Accessor &styler, unsigned int &pos, unsigned int endPos)
+// KOMODO -- interactive shell colorizing
+static bool isStdioChar(int style) {
+    switch (style) {
+        case SCE_PL_STDIN:
+        case SCE_PL_STDOUT:
+        case SCE_PL_STDERR:
+            return true;
+    }
+    return false;
+}
+
+static int prevNonNewlinePos(int line,
+                             Accessor &styler) {
+    if (line <= 0) return -1;
+    int lineStart = styler.LineStart(line);
+    if (lineStart == 0) return -1;
+    // Move to the previous line
+    int pos = lineStart - 1;
+    char ch = styler.SafeGetCharAt(pos);
+    while (pos > 0 && (ch == '\n' || ch == '\r')) {
+        ch = styler.SafeGetCharAt(--pos);
+    }
+    return pos;
+}
+
+/*
+ * This implementation just walks back up the
+ * buffer, since looking at line levels is way too error-prone.
+ * In Perl you can have long runs of blocks that are all at the
+ * same level given non-standard code formatting, like
+ *
+ * if (1 ...
+ *    ) { my %abc = { abc => map { if (2
+ *                                     ...) {
+ * ...
+ *
+ * This seems fast enough -- on cgi.pm it goes from line 40 to 3808
+ * without any noticeable dela.
+ */
+
+static int GetMatchingPos(int currPos, Accessor &styler)
+{
+    char currChar = styler.SafeGetCharAt(currPos);
+    if (currChar != '}') {
+        return -1;
+    }
+    int num_extra_closers = 1;
+    int direction = 0;
+    for (int i = currPos - 1; i >= 0; i--) {
+        char ch = styler.SafeGetCharAt(i);
+        if (ch == '{') {
+            direction = -1;
+        } else if (ch == '}') {
+            direction = +1;
+        } else {
+            direction = 0;
+        }
+        if (direction) {
+            switch ((int) safeStyleAt(i, styler)) {
+            case SCE_PL_OPERATOR:
+            case SCE_PL_VARIABLE_INDEXER:
+                num_extra_closers += direction;
+                if (num_extra_closers == 0) {
+                    return i;
+                }
+                break;
+            }
+        }
+    }
+    return -1;
+}
+
+static
+int GetMatchingStyle(int currPos, Accessor &styler)
 {
-	// forward scan the current line to classify line for POD style
-	int state = -1;
-	while (pos <= endPos) {
-		int ch = static_cast<unsigned char>(styler.SafeGetCharAt(pos));
-		if (ch == '\n' || ch == '\r' || pos >= endPos) {
-			if (ch == '\r' && styler.SafeGetCharAt(pos + 1) == '\n') pos++;
-			break;
-		}
-		if (IsASpaceOrTab(ch)) {	// whitespace, take note
-			if (state == -1)
-				state = SCE_PL_DEFAULT;
-		} else if (state == SCE_PL_DEFAULT) {	// verbatim POD line
-			state = SCE_PL_POD_VERB;
-		} else if (state != SCE_PL_POD_VERB) {	// regular POD line
-			state = SCE_PL_POD;
-		}
-		pos++;
-	}
-	if (state == -1)
-		state = SCE_PL_DEFAULT;
-	return state;
+    // We need to flush in case things above us changed, as this code uses styles.
+    styler.Flush();
+    int startPos = GetMatchingPos(currPos, styler);
+    if (startPos >= 0) {
+        int startStyle = safeStyleAt(startPos, styler);
+        return startStyle;
+    }
+    return SCE_PL_OPERATOR;
 }
 
-static bool styleCheckSubPrototype(Accessor &styler, unsigned int bk)
+typedef int BracePoint;
+
+class BracePositionInfo {
+    public:
+    BracePositionInfo(int cap_=16) {
+        capacity = cap_;
+        p_BI = (BracePoint *) malloc(capacity * sizeof(BracePoint));
+        if (!p_BI) {
+            capacity = 0;
+        }
+        index = 0;
+    };
+    ~BracePositionInfo() {
+        if (p_BI) free ((void *) p_BI);
+    };
+    bool add(int style) {
+        if (capacity <= 0 || index < 0) {
+            return false;
+        } else if (capacity <= index) {
+            int new_cap = capacity;
+            while (new_cap <= index) {
+                new_cap = new_cap * 2;
+            }
+            // fprintf(stderr, "BracePositionInfo::add: about to realloc 0x%x from %d to %d bytes\n", p_BI, capacity, new_cap);
+            BracePoint *tmp =
+                (BracePoint *) realloc((void *) p_BI,
+                                      new_cap * sizeof(BracePoint));
+            if (!tmp) {
+                // Throw it *all* away
+                // fprintf(stderr, "BracePositionInfo::add: failed\n");
+                free ((void *) p_BI);
+                p_BI = 0;
+                index = capacity = 0;
+                return false;
+            } else {
+                p_BI = tmp;
+                capacity = new_cap;
+                // fprintf(stderr, "BracePositionInfo::add: worked, mem=0x%x, cap = %d\n", p_BI, capacity);
+            }
+        }
+        p_BI[index++] = style;
+        return true;
+    };
+    int getStyle(bool pop=true) {
+        if (!p_BI || index <= 0) {
+            return -1;
+        }
+        int style = p_BI[index - 1];
+        if (pop) {
+            index--;
+        }
+        return style;
+    };
+    
+    private:
+    BracePoint *p_BI;
+    int index;
+    int capacity;
+};
+
+// Move back to the start of the last statement. This may require passing 
+// through a here document body and/or a line declaring a here doc follows.
+
+static void synchronizeDocStart(unsigned int& startPos,
+                                unsigned int endPos,
+                                int& state,
+                                Accessor& styler)
 {
-	// backtrack to identify if we're starting a subroutine prototype
-	// we also need to ignore whitespace/comments:
-	// 'sub' [whitespace|comment] <identifier> [whitespace|comment]
-	styler.Flush();
-	skipWhitespaceComment(styler, bk);
-	if (bk == 0 || styler.StyleAt(bk) != SCE_PL_IDENTIFIER)	// check identifier
-		return false;
-	while (bk > 0 && (styler.StyleAt(bk) == SCE_PL_IDENTIFIER)) {
-		bk--;
-	}
-	skipWhitespaceComment(styler, bk);
-	if (bk < 2 || styler.StyleAt(bk) != SCE_PL_WORD	// check "sub" keyword
-		|| !styler.Match(bk - 2, "sub"))	// assume suffix is unique!
-		return false;
-	return true;
+    styler.Flush();
+    int style;
+    int pos = startPos;
+    int currLine = styler.GetLine(pos);
+    int lastLine = styler.GetLine(endPos);
+    int lineEndPos = (lastLine == currLine) ? styler.Length() : styler.LineStart(currLine + 1) - 1;
+    
+    while (currLine > 0) {
+        // Now look at the style before the previous line's EOL
+        int prevLine_PosBeforeEOL = prevNonNewlinePos(currLine, styler);
+        if (prevLine_PosBeforeEOL == -1) {
+            break;
+        }
+        style = safeStyleAt(prevLine_PosBeforeEOL, styler);
+        int lineStartPos = styler.LineStart(currLine);
+        // KOMODO -- interactive shell colorizing
+        if (isStdioChar(style)) {
+            // stop at start of line currLine
+            startPos = lineStartPos;
+            state = SCE_PL_DEFAULT;
+            return;
+        }
+        // If the previous newline style isn't default, keep moving back
+        int prevLineEndPos = lineStartPos - 1;
+
+        // Look at the style at the end of the previous line
+        style = safeStyleAt(prevLineEndPos, styler);
+        if (style != SCE_PL_DEFAULT) {
+            switch (style) {
+            case SCE_PL_POD:
+            case SCE_PL_DATASECTION:
+                // These always end the same, so we can stop in one.
+                // Otherwise we risk walking back through very long
+                // documents for no reason.
+                startPos = lineStartPos;
+                state = style;
+                return;
+            }
+            currLine -= 1;
+            lineEndPos = prevLineEndPos;
+            continue;
+        }            
+
+        // Now look at the first non-white token on this line
+        // and decide what to do.
+
+        int first_sig_pos;
+        for (first_sig_pos = lineStartPos; // first significant position
+             first_sig_pos < lineEndPos;
+             first_sig_pos++) {
+            int style = safeStyleAt(first_sig_pos, styler);
+            if (style != SCE_PL_DEFAULT) {
+                break;
+            }
+        }
+
+        int firstStyle = safeStyleAt(first_sig_pos, styler);
+        switch (firstStyle) {
+        case SCE_PL_COMMENTLINE:
+        case SCE_PL_NUMBER:
+        case SCE_PL_WORD:
+        case SCE_PL_OPERATOR:
+        case SCE_PL_IDENTIFIER:
+        case SCE_PL_SCALAR:
+        case SCE_PL_ARRAY:
+        case SCE_PL_HASH:
+        case SCE_PL_SYMBOLTABLE:
+        case SCE_PL_VARIABLE_INDEXER:
+            // Verify the char before this one is default EOL,
+            // then we know it's safe to break here,
+            // as the lexer will proceed in the default state.
+            startPos = lineStartPos;
+            state = SCE_PL_DEFAULT;
+            return;
+        }
+        currLine -= 1;
+        lineEndPos = prevLineEndPos;
+    }
+    startPos = 0;
+    state = SCE_PL_DEFAULT;
 }
 
-static bool isMatch(const char *sref, char *s)
+
+void ColourisePerlDoc(unsigned int startPos, int length, int , // initStyle
+                      WordList *keywordlists[], Accessor &styler)
 {
-	// match per-line delimiter - must kill trailing CR if CRLF
-	int i = strlen(s);
-	if (i != 0 && s[i - 1] == '\r')
-		s[i - 1] = '\0';
-	return (strcmp(sref, s) == 0);
-}
-
-static int actualNumStyle(int numberStyle) {
-	if (numberStyle == PERLNUM_VECTOR || numberStyle == PERLNUM_V_VECTOR) {
-		return SCE_PL_STRING;
-	} else if (numberStyle == PERLNUM_BAD) {
-		return SCE_PL_ERROR;
-	}
-	return SCE_PL_NUMBER;
-}
-
-static int opposite(int ch) {
-	if (ch == '(') return ')';
-	if (ch == '[') return ']';
-	if (ch == '{') return '}';
-	if (ch == '<') return '>';
-	return ch;
-}
-
-static void ColourisePerlDoc(unsigned int startPos, int length, int initStyle,
-                             WordList *keywordlists[], Accessor &styler) {
-
-	WordList &keywords = *keywordlists[0];
-
-	// keywords that forces /PATTERN/ at all times; should track vim's behaviour
-	WordList reWords;
-	reWords.Set("elsif if split while");
-
-	// charset classes
-	CharacterSet setWordStart(CharacterSet::setAlpha, "_", 0x80, true);
-	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
-	CharacterSet setSingleCharOp(CharacterSet::setNone, "rwxoRWXOezsfdlpSbctugkTBMAC");
-	// lexing of "%*</" operators is non-trivial; these are missing in the set below
-	CharacterSet setPerlOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;>,?!.~");
-	CharacterSet setQDelim(CharacterSet::setNone, "qrwx");
-	CharacterSet setModifiers(CharacterSet::setAlpha);
-	CharacterSet setPreferRE(CharacterSet::setNone, "*/<%");
-	// setArray and setHash also accepts chars for special vars like $_,
-	// which are then truncated when the next char does not match setVar
-	CharacterSet setVar(CharacterSet::setAlphaNum, "#$_'", 0x80, true);
-	CharacterSet setArray(CharacterSet::setAlpha, "#$_+-", 0x80, true);
-	CharacterSet setHash(CharacterSet::setAlpha, "#$_!^+-", 0x80, true);
-	CharacterSet &setPOD = setModifiers;
-	CharacterSet setNonHereDoc(CharacterSet::setDigits, "=$@");
-	CharacterSet setHereDocDelim(CharacterSet::setAlphaNum, "_");
-	CharacterSet setSubPrototype(CharacterSet::setNone, "\\[$@%&*];");
-	// for format identifiers
-	CharacterSet setFormatStart(CharacterSet::setAlpha, "_=");
-	CharacterSet &setFormat = setHereDocDelim;
-
-	// Lexer for perl often has to backtrack to start of current style to determine
-	// which characters are being used as quotes, how deeply nested is the
-	// start position and what the termination string is for HERE documents.
-
-	class HereDocCls {	// Class to manage HERE doc sequence
-	public:
-		int State;		// 0: '<<' encountered
-						// 1: collect the delimiter
-						// 2: here doc text (lines after the delimiter)
-		int Quote;		// the char after '<<'
-		bool Quoted;		// true if Quote in ('\'','"','`')
-		int DelimiterLength;	// strlen(Delimiter)
-		char *Delimiter;	// the Delimiter, 256: sizeof PL_tokenbuf
-		HereDocCls() {
-			State = 0;
-			Quote = 0;
-			Quoted = false;
-			DelimiterLength = 0;
-			Delimiter = new char[HERE_DELIM_MAX];
-			Delimiter[0] = '\0';
-		}
-		void Append(int ch) {
-			Delimiter[DelimiterLength++] = static_cast<char>(ch);
-			Delimiter[DelimiterLength] = '\0';
-		}
-		~HereDocCls() {
-			delete []Delimiter;
-		}
-	};
-	HereDocCls HereDoc;		// TODO: FIFO for stacked here-docs
-
-	class QuoteCls {	// Class to manage quote pairs
-		public:
-		int Rep;
-		int Count;
-		int Up, Down;
-		QuoteCls() {
-			this->New(1);
-		}
-		void New(int r = 1) {
-			Rep   = r;
-			Count = 0;
-			Up    = '\0';
-			Down  = '\0';
-		}
-		void Open(int u) {
-			Count++;
-			Up    = u;
-			Down  = opposite(Up);
-		}
-	};
-	QuoteCls Quote;
-
-	// additional state for number lexing
-	int numState = PERLNUM_DECIMAL;
-	int dotCount = 0;
-
-	unsigned int endPos = startPos + length;
-
-	// Backtrack to beginning of style if required...
-	// If in a long distance lexical state, backtrack to find quote characters.
-	// Includes strings (may be multi-line), numbers (additional state), format
-	// bodies, as well as POD sections.
-	if (initStyle == SCE_PL_HERE_Q
-		|| initStyle == SCE_PL_HERE_QQ
-		|| initStyle == SCE_PL_HERE_QX
-		|| initStyle == SCE_PL_FORMAT
-	) {
-		int delim = (initStyle == SCE_PL_FORMAT) ? SCE_PL_FORMAT_IDENT:SCE_PL_HERE_DELIM;
-		while ((startPos > 1) && (styler.StyleAt(startPos) != delim)) {
-			startPos--;
-		}
-		startPos = styler.LineStart(styler.GetLine(startPos));
-		initStyle = styler.StyleAt(startPos - 1);
-	}
-	if (initStyle == SCE_PL_STRING_Q
-		|| initStyle == SCE_PL_STRING_QQ
-		|| initStyle == SCE_PL_STRING_QX
-		|| initStyle == SCE_PL_STRING_QR
-		|| initStyle == SCE_PL_STRING_QW
-		|| initStyle == SCE_PL_REGEX
-		|| initStyle == SCE_PL_REGSUBST
-		|| initStyle == SCE_PL_STRING
-		|| initStyle == SCE_PL_BACKTICKS
-		|| initStyle == SCE_PL_CHARACTER
-		|| initStyle == SCE_PL_NUMBER
-		|| initStyle == SCE_PL_IDENTIFIER
-		|| initStyle == SCE_PL_ERROR
-		|| initStyle == SCE_PL_SUB_PROTOTYPE
-	) {
-		while ((startPos > 1) && (styler.StyleAt(startPos - 1) == initStyle)) {
-			startPos--;
-		}
-		initStyle = SCE_PL_DEFAULT;
-	} else if (initStyle == SCE_PL_POD
-			   || initStyle == SCE_PL_POD_VERB
-	) {
-		// POD backtracking finds preceeding blank lines and goes back past them
-		int ln = styler.GetLine(startPos);
-		if (ln > 0) {
-			initStyle = styler.StyleAt(styler.LineStart(--ln));
-			if (initStyle == SCE_PL_POD || initStyle == SCE_PL_POD_VERB) {
-				while (ln > 0 && styler.GetLineState(ln) == SCE_PL_DEFAULT)
-					ln--;
-			}
-			startPos = styler.LineStart(++ln);
-			initStyle = styler.StyleAt(startPos - 1);
-		} else {
-			startPos = 0;
-			initStyle = SCE_PL_DEFAULT;
-		}
-	}
-
-	// backFlag, backPos are additional state to aid identifier corner cases.
-	// Look backwards past whitespace and comments in order to detect either
-	// operator or keyword. Later updated as we go along.
-	int backFlag = BACK_NONE;
-	unsigned int backPos = startPos;
-	if (backPos > 0) {
-		backPos--;
-		skipWhitespaceComment(styler, backPos);
-		if (styler.StyleAt(backPos) == SCE_PL_OPERATOR)
-			backFlag = BACK_OPERATOR;
-		else if (styler.StyleAt(backPos) == SCE_PL_WORD)
-			backFlag = BACK_KEYWORD;
-		backPos++;
-	}
-
-	StyleContext sc(startPos, endPos - startPos, initStyle, styler, static_cast<char>(STYLE_MAX));
-
-	for (; sc.More(); sc.Forward()) {
-
-		// Determine if the current state should terminate.
-		switch (sc.state) {
-			case SCE_PL_OPERATOR:
-				sc.SetState(SCE_PL_DEFAULT);
-				backFlag = BACK_OPERATOR;
-				backPos = sc.currentPos;
-				break;
-			case SCE_PL_IDENTIFIER:		// identifier, bareword, inputsymbol
-				if ((!setWord.Contains(sc.ch) && sc.ch != '\'')
-					|| sc.Match('.', '.')
-					|| sc.chPrev == '>') {	// end of inputsymbol
-					sc.SetState(SCE_PL_DEFAULT);
-				}
-				break;
-			case SCE_PL_WORD:		// keyword, plus special cases
-				if (!setWord.Contains(sc.ch)) {
-					char s[100];
-					sc.GetCurrent(s, sizeof(s));
-					if ((strcmp(s, "__DATA__") == 0) || (strcmp(s, "__END__") == 0)) {
-						sc.ChangeState(SCE_PL_DATASECTION);
-					} else {
-						if ((strcmp(s, "format") == 0)) {
-							sc.SetState(SCE_PL_FORMAT_IDENT);
-							HereDoc.State = 0;
-						} else {
-							sc.SetState(SCE_PL_DEFAULT);
-						}
-						backFlag = BACK_KEYWORD;
-						backPos = sc.currentPos;
-					}
-				}
-				break;
-			case SCE_PL_SCALAR:
-			case SCE_PL_ARRAY:
-			case SCE_PL_HASH:
-			case SCE_PL_SYMBOLTABLE:
-				if (sc.Match(':', ':')) {	// skip ::
-					sc.Forward();
-				} else if (!setVar.Contains(sc.ch)) {
-					if (sc.LengthCurrent() == 1) {
-						// Special variable: $(, $_ etc.
-						sc.Forward();
-					}
-					sc.SetState(SCE_PL_DEFAULT);
-				}
-				break;
-			case SCE_PL_NUMBER:
-				// if no early break, number style is terminated at "(go through)"
-				if (sc.ch == '.') {
-					if (sc.chNext == '.') {
-						// double dot is always an operator (go through)
-					} else if (numState <= PERLNUM_FLOAT_EXP) {
-						// non-decimal number or float exponent, consume next dot
-						sc.SetState(SCE_PL_OPERATOR);
-						break;
-					} else {	// decimal or vectors allows dots
-						dotCount++;
-						if (numState == PERLNUM_DECIMAL) {
-							if (dotCount <= 1)	// number with one dot in it
-								break;
-							if (IsADigit(sc.chNext)) {	// really a vector
-								numState = PERLNUM_VECTOR;
-								break;
-							}
-							// number then dot (go through)
-						} else if (IsADigit(sc.chNext))	// vectors
-							break;
-						// vector then dot (go through)
-					}
-				} else if (sc.ch == '_') {
-					// permissive underscoring for number and vector literals
-					break;
-				} else if (numState == PERLNUM_DECIMAL) {
-					if (sc.ch == 'E' || sc.ch == 'e') {	// exponent, sign
-						numState = PERLNUM_FLOAT_EXP;
-						if (sc.chNext == '+' || sc.chNext == '-') {
-							sc.Forward();
-						}
-						break;
-					} else if (IsADigit(sc.ch))
-						break;
-					// number then word (go through)
-				} else if (numState == PERLNUM_HEX) {
-					if (IsADigit(sc.ch, 16))
-						break;
-				} else if (numState == PERLNUM_VECTOR || numState == PERLNUM_V_VECTOR) {
-					if (IsADigit(sc.ch))	// vector
-						break;
-					if (setWord.Contains(sc.ch) && dotCount == 0) {	// change to word
-						sc.ChangeState(SCE_PL_IDENTIFIER);
-						break;
-					}
-					// vector then word (go through)
-				} else if (IsADigit(sc.ch)) {
-					if (numState == PERLNUM_FLOAT_EXP) {
-						break;
-					} else if (numState == PERLNUM_OCTAL) {
-						if (sc.ch <= '7') break;
-					} else if (numState == PERLNUM_BINARY) {
-						if (sc.ch <= '1') break;
-					}
-					// mark invalid octal, binary numbers (go through)
-					numState = PERLNUM_BAD;
-					break;
-				}
-				// complete current number or vector
-				sc.ChangeState(actualNumStyle(numState));
-				sc.SetState(SCE_PL_DEFAULT);
-				break;
-			case SCE_PL_COMMENTLINE:
-				if (sc.atLineEnd) {
-					sc.SetState(SCE_PL_DEFAULT);
-				}
-				break;
-			case SCE_PL_HERE_DELIM:
-				if (HereDoc.State == 0) { // '<<' encountered
-					int delim_ch = sc.chNext;
-					int ws_skip = 0;
-					HereDoc.State = 1;	// pre-init HERE doc class
-					HereDoc.Quote = sc.chNext;
-					HereDoc.Quoted = false;
-					HereDoc.DelimiterLength = 0;
-					HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
-					if (IsASpaceOrTab(delim_ch)) {
-						// skip whitespace; legal only for quoted delimiters
-						unsigned int i = sc.currentPos + 1;
-						while ((i < endPos) && IsASpaceOrTab(delim_ch)) {
-							i++;
-							delim_ch = static_cast<unsigned char>(styler.SafeGetCharAt(i));
-						}
-						ws_skip = i - sc.currentPos - 1;
-					}
-					if (delim_ch == '\'' || delim_ch == '"' || delim_ch == '`') {
-						// a quoted here-doc delimiter; skip any whitespace
-						sc.Forward(ws_skip + 1);
-						HereDoc.Quote = delim_ch;
-						HereDoc.Quoted = true;
-					} else if ((ws_skip == 0 && setNonHereDoc.Contains(sc.chNext))
-							   || ws_skip > 0) {
-						// left shift << or <<= operator cases
-						// restore position if operator
-						sc.ChangeState(SCE_PL_OPERATOR);
-						sc.ForwardSetState(SCE_PL_DEFAULT);
-						backFlag = BACK_OPERATOR;
-						backPos = sc.currentPos;
-						HereDoc.State = 0;
-					} else {
-						// specially handle initial '\' for identifier
-						if (ws_skip == 0 && HereDoc.Quote == '\\')
-							sc.Forward();
-						// an unquoted here-doc delimiter, no special handling
-						// (cannot be prefixed by spaces/tabs), or
-						// symbols terminates; deprecated zero-length delimiter
-					}
-				} else if (HereDoc.State == 1) { // collect the delimiter
-					backFlag = BACK_NONE;
-					if (HereDoc.Quoted) { // a quoted here-doc delimiter
-						if (sc.ch == HereDoc.Quote) { // closing quote => end of delimiter
-							sc.ForwardSetState(SCE_PL_DEFAULT);
-						} else if (!sc.atLineEnd) {
-							if (sc.Match('\\', static_cast<char>(HereDoc.Quote))) { // escaped quote
-								sc.Forward();
-							}
-							if (sc.ch != '\r') {	// skip CR if CRLF
-								HereDoc.Append(sc.ch);
-							}
-						}
-					} else { // an unquoted here-doc delimiter
-						if (setHereDocDelim.Contains(sc.ch)) {
-							HereDoc.Append(sc.ch);
-						} else {
-							sc.SetState(SCE_PL_DEFAULT);
-						}
-					}
-					if (HereDoc.DelimiterLength >= HERE_DELIM_MAX - 1) {
-						sc.SetState(SCE_PL_ERROR);
-						HereDoc.State = 0;
-					}
-				}
-				break;
-			case SCE_PL_HERE_Q:
-			case SCE_PL_HERE_QQ:
-			case SCE_PL_HERE_QX: {
-				// also implies HereDoc.State == 2
-				sc.Complete();
-				while (!sc.atLineEnd)
-					sc.Forward();
-				char s[HERE_DELIM_MAX];
-				sc.GetCurrent(s, sizeof(s));
-				if (isMatch(HereDoc.Delimiter, s)) {
-					sc.SetState(SCE_PL_DEFAULT);
-					backFlag = BACK_NONE;
-					HereDoc.State = 0;
-				}
-				} break;
-			case SCE_PL_POD:
-			case SCE_PL_POD_VERB: {
-				unsigned int fw = sc.currentPos;
-				int ln = styler.GetLine(fw);
-				if (sc.atLineStart && sc.Match("=cut")) {	// end of POD
-					sc.SetState(SCE_PL_POD);
-					sc.Forward(4);
-					sc.SetState(SCE_PL_DEFAULT);
-					styler.SetLineState(ln, SCE_PL_POD);
-					break;
-				}
-				int pod = podLineScan(styler, fw, endPos);	// classify POD line
-				styler.SetLineState(ln, pod);
-				if (pod == SCE_PL_DEFAULT) {
-					if (sc.state == SCE_PL_POD_VERB) {
-						unsigned int fw2 = fw;
-						while (fw2 <= endPos && pod == SCE_PL_DEFAULT) {
-							fw = fw2++;	// penultimate line (last blank line)
-							pod = podLineScan(styler, fw2, endPos);
-							styler.SetLineState(styler.GetLine(fw2), pod);
-						}
-						if (pod == SCE_PL_POD) {	// truncate verbatim POD early
-							sc.SetState(SCE_PL_POD);
-						} else
-							fw = fw2;
-					} else
-						pod = SCE_PL_POD;
-				} else {
-					if (pod == SCE_PL_POD_VERB	// still part of current paragraph
-					    && (styler.GetLineState(ln - 1) == SCE_PL_POD)) {
-						pod = SCE_PL_POD;
-						styler.SetLineState(ln, pod);
-					} else if (pod == SCE_PL_POD
-							   && (styler.GetLineState(ln - 1) == SCE_PL_POD_VERB)) {
-						pod = SCE_PL_POD_VERB;
-						styler.SetLineState(ln, pod);
-					}
-					sc.SetState(pod);
-				}
-				sc.Forward(fw - sc.currentPos);	// commit style
-				} break;
-			case SCE_PL_REGEX:
-			case SCE_PL_STRING_QR:
-				if (Quote.Rep <= 0) {
-					if (!setModifiers.Contains(sc.ch))
-						sc.SetState(SCE_PL_DEFAULT);
-				} else if (!Quote.Up && !IsASpace(sc.ch)) {
-					Quote.Open(sc.ch);
-				} else if (sc.ch == '\\' && Quote.Up != '\\') {
-					sc.Forward();
-				} else if (sc.ch == Quote.Down) {
-					Quote.Count--;
-					if (Quote.Count == 0)
-						Quote.Rep--;
-				} else if (sc.ch == Quote.Up) {
-					Quote.Count++;
-				}
-				break;
-			case SCE_PL_REGSUBST:
-				if (Quote.Rep <= 0) {
-					if (!setModifiers.Contains(sc.ch))
-						sc.SetState(SCE_PL_DEFAULT);
-				} else if (!Quote.Up && !IsASpace(sc.ch)) {
-					Quote.Open(sc.ch);
-				} else if (sc.ch == '\\' && Quote.Up != '\\') {
-					sc.Forward();
-				} else if (Quote.Count == 0 && Quote.Rep == 1) {
-					// We matched something like s(...) or tr{...}, Perl 5.10
-					// appears to allow almost any character for use as the
-					// next delimiters. Whitespace and comments are accepted in
-					// between, but we'll limit to whitespace here.
-					// For '#', if no whitespace in between, it's a delimiter.
-					if (IsASpace(sc.ch)) {
-						// Keep going
-					} else if (sc.ch == '#' && IsASpaceOrTab(sc.chPrev)) {
-						sc.SetState(SCE_PL_DEFAULT);
-					} else {
-						Quote.Open(sc.ch);
-					}
-				} else if (sc.ch == Quote.Down) {
-					Quote.Count--;
-					if (Quote.Count == 0)
-						Quote.Rep--;
-					if (Quote.Up == Quote.Down)
-						Quote.Count++;
-				} else if (sc.ch == Quote.Up) {
-					Quote.Count++;
-				}
-				break;
-			case SCE_PL_STRING_Q:
-			case SCE_PL_STRING_QQ:
-			case SCE_PL_STRING_QX:
-			case SCE_PL_STRING_QW:
-			case SCE_PL_STRING:
-			case SCE_PL_CHARACTER:
-			case SCE_PL_BACKTICKS:
-				if (!Quote.Down && !IsASpace(sc.ch)) {
-					Quote.Open(sc.ch);
-				} else if (sc.ch == '\\' && Quote.Up != '\\') {
-					sc.Forward();
-				} else if (sc.ch == Quote.Down) {
-					Quote.Count--;
-					if (Quote.Count == 0)
-						sc.ForwardSetState(SCE_PL_DEFAULT);
-				} else if (sc.ch == Quote.Up) {
-					Quote.Count++;
-				}
-				break;
-			case SCE_PL_SUB_PROTOTYPE: {
-				int i = 0;
-				// forward scan; must all be valid proto characters
-				while (setSubPrototype.Contains(sc.GetRelative(i)))
-					i++;
-				if (sc.GetRelative(i) == ')') {	// valid sub prototype
-					sc.Forward(i);
-					sc.ForwardSetState(SCE_PL_DEFAULT);
-				} else {
-					// abandon prototype, restart from '('
-					sc.ChangeState(SCE_PL_OPERATOR);
-					sc.SetState(SCE_PL_DEFAULT);
-				}
-				} break;
-			case SCE_PL_FORMAT: {
-				sc.Complete();
-				while (!sc.atLineEnd)
-					sc.Forward();
-				char s[10];
-				sc.GetCurrent(s, sizeof(s));
-				if (isMatch(".", s))
-					sc.SetState(SCE_PL_DEFAULT);
-				} break;
-			case SCE_PL_ERROR:
-				break;
-		}
-		// Needed for specific continuation styles (one follows the other)
-		switch (sc.state) {
-			// continued from SCE_PL_WORD
-			case SCE_PL_FORMAT_IDENT:
-				// occupies HereDoc state 3 to avoid clashing with HERE docs
-				if (IsASpaceOrTab(sc.ch)) {		// skip whitespace
-					sc.ChangeState(SCE_PL_DEFAULT);
-					while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
-						sc.Forward();
-					sc.SetState(SCE_PL_FORMAT_IDENT);
-				}
-				if (setFormatStart.Contains(sc.ch)) {	// identifier or '='
-					if (sc.ch != '=') {
-						do {
-							sc.Forward();
-						} while (setFormat.Contains(sc.ch));
-					}
-					while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
-						sc.Forward();
-					if (sc.ch == '=') {
-						sc.ForwardSetState(SCE_PL_DEFAULT);
-						HereDoc.State = 3;
-					} else {
-						// invalid indentifier; inexact fallback, but hey
-						sc.ChangeState(SCE_PL_IDENTIFIER);
-						sc.SetState(SCE_PL_DEFAULT);
-					}
-				} else {
-					sc.ChangeState(SCE_PL_DEFAULT);	// invalid indentifier
-				}
-				backFlag = BACK_NONE;
-				break;
-		}
-
-		// Must check end of HereDoc states here before default state is handled
-		if (HereDoc.State == 1 && sc.atLineEnd) {
-			// Begin of here-doc (the line after the here-doc delimiter):
-			// Lexically, the here-doc starts from the next line after the >>, but the
-			// first line of here-doc seem to follow the style of the last EOL sequence
-			int st_new = SCE_PL_HERE_QQ;
-			HereDoc.State = 2;
-			if (HereDoc.Quoted) {
-				if (sc.state == SCE_PL_HERE_DELIM) {
-					// Missing quote at end of string! We are stricter than perl.
-					// Colour here-doc anyway while marking this bit as an error.
-					sc.ChangeState(SCE_PL_ERROR);
-				}
-				switch (HereDoc.Quote) {
-					case '\'': st_new = SCE_PL_HERE_Q ; break;
-					case '"' : st_new = SCE_PL_HERE_QQ; break;
-					case '`' : st_new = SCE_PL_HERE_QX; break;
-				}
-			} else {
-				if (HereDoc.Quote == '\\')
-					st_new = SCE_PL_HERE_Q;
-			}
-			sc.SetState(st_new);
-		}
-		if (HereDoc.State == 3 && sc.atLineEnd) {
-			// Start of format body.
-			HereDoc.State = 0;
-			sc.SetState(SCE_PL_FORMAT);
-		}
-
-		// Determine if a new state should be entered.
-		if (sc.state == SCE_PL_DEFAULT) {
-			if (IsADigit(sc.ch) ||
-				(IsADigit(sc.chNext) && (sc.ch == '.' || sc.ch == 'v'))) {
-				sc.SetState(SCE_PL_NUMBER);
-				backFlag = BACK_NONE;
-				numState = PERLNUM_DECIMAL;
-				dotCount = 0;
-				if (sc.ch == '0') {		// hex,bin,octal
-					if (sc.chNext == 'x') {
-						numState = PERLNUM_HEX;
-					} else if (sc.chNext == 'b') {
-						numState = PERLNUM_BINARY;
-					} else if (IsADigit(sc.chNext)) {
-						numState = PERLNUM_OCTAL;
-					}
-					if (numState != PERLNUM_DECIMAL) {
-						sc.Forward();
-					}
-				} else if (sc.ch == 'v') {		// vector
-					numState = PERLNUM_V_VECTOR;
-				}
-			} else if (setWord.Contains(sc.ch)) {
-				// if immediately prefixed by '::', always a bareword
-				sc.SetState(SCE_PL_WORD);
-				if (sc.chPrev == ':' && sc.GetRelative(-2) == ':') {
-					sc.ChangeState(SCE_PL_IDENTIFIER);
-				}
-				unsigned int bk = sc.currentPos;
-				unsigned int fw = sc.currentPos + 1;
-				// first check for possible quote-like delimiter
-				if (sc.ch == 's' && !setWord.Contains(sc.chNext)) {
-					sc.ChangeState(SCE_PL_REGSUBST);
-					Quote.New(2);
-				} else if (sc.ch == 'm' && !setWord.Contains(sc.chNext)) {
-					sc.ChangeState(SCE_PL_REGEX);
-					Quote.New();
-				} else if (sc.ch == 'q' && !setWord.Contains(sc.chNext)) {
-					sc.ChangeState(SCE_PL_STRING_Q);
-					Quote.New();
-				} else if (sc.ch == 'y' && !setWord.Contains(sc.chNext)) {
-					sc.ChangeState(SCE_PL_REGSUBST);
-					Quote.New(2);
-				} else if (sc.Match('t', 'r') && !setWord.Contains(sc.GetRelative(2))) {
-					sc.ChangeState(SCE_PL_REGSUBST);
-					Quote.New(2);
-					sc.Forward();
-					fw++;
-				} else if (sc.ch == 'q' && setQDelim.Contains(sc.chNext)
-						   && !setWord.Contains(sc.GetRelative(2))) {
-					if      (sc.chNext == 'q') sc.ChangeState(SCE_PL_STRING_QQ);
-					else if (sc.chNext == 'x') sc.ChangeState(SCE_PL_STRING_QX);
-					else if (sc.chNext == 'r') sc.ChangeState(SCE_PL_STRING_QR);
-					else sc.ChangeState(SCE_PL_STRING_QW);	// sc.chNext == 'w'
-					Quote.New();
-					sc.Forward();
-					fw++;
-				} else if (sc.ch == 'x' && (sc.chNext == '=' ||	// repetition
-						   !setWord.Contains(sc.chNext) ||
-						   (IsADigit(sc.chPrev) && IsADigit(sc.chNext)))) {
-					sc.ChangeState(SCE_PL_OPERATOR);
-				}
-				// if potentially a keyword, scan forward and grab word, then check
-				// if it's really one; if yes, disambiguation test is performed
-				// otherwise it is always a bareword and we skip a lot of scanning
-				if (sc.state == SCE_PL_WORD) {
-					while (setWord.Contains(static_cast<unsigned char>(styler.SafeGetCharAt(fw))))
-						fw++;
-					if (!isPerlKeyword(styler.GetStartSegment(), fw, keywords, styler)) {
-						sc.ChangeState(SCE_PL_IDENTIFIER);
-					}
-				}
-				// if already SCE_PL_IDENTIFIER, then no ambiguity, skip this
-				// for quote-like delimiters/keywords, attempt to disambiguate
-				// to select for bareword, change state -> SCE_PL_IDENTIFIER
-				if (sc.state != SCE_PL_IDENTIFIER && bk > 0) {
-					if (disambiguateBareword(styler, bk, fw, backFlag, backPos, endPos))
-						sc.ChangeState(SCE_PL_IDENTIFIER);
-				}
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '#') {
-				sc.SetState(SCE_PL_COMMENTLINE);
-			} else if (sc.ch == '\"') {
-				sc.SetState(SCE_PL_STRING);
-				Quote.New();
-				Quote.Open(sc.ch);
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '\'') {
-				if (sc.chPrev == '&' && setWordStart.Contains(sc.chNext)) {
-					// Archaic call
-					sc.SetState(SCE_PL_IDENTIFIER);
-				} else {
-					sc.SetState(SCE_PL_CHARACTER);
-					Quote.New();
-					Quote.Open(sc.ch);
-				}
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '`') {
-				sc.SetState(SCE_PL_BACKTICKS);
-				Quote.New();
-				Quote.Open(sc.ch);
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '$') {
-				sc.SetState(SCE_PL_SCALAR);
-				if (sc.chNext == '{') {
-					sc.ForwardSetState(SCE_PL_OPERATOR);
-				} else if (IsASpace(sc.chNext)) {
-					sc.ForwardSetState(SCE_PL_DEFAULT);
-				} else {
-					sc.Forward();
-					if (sc.Match('`', '`') || sc.Match(':', ':')) {
-						sc.Forward();
-					}
-				}
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '@') {
-				sc.SetState(SCE_PL_ARRAY);
-				if (setArray.Contains(sc.chNext)) {
-					// no special treatment
-				} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
-					sc.Forward(2);
-				} else if (sc.chNext == '{' || sc.chNext == '[') {
-					sc.ForwardSetState(SCE_PL_OPERATOR);
-				} else {
-					sc.ChangeState(SCE_PL_OPERATOR);
-				}
-				backFlag = BACK_NONE;
-			} else if (setPreferRE.Contains(sc.ch)) {
-				// Explicit backward peeking to set a consistent preferRE for
-				// any slash found, so no longer need to track preferRE state.
-				// Find first previous significant lexed element and interpret.
-				// A few symbols shares this code for disambiguation.
-				bool preferRE = false;
-				bool isHereDoc = sc.Match('<', '<');
-				bool hereDocSpace = false;		// for: SCALAR [whitespace] '<<'
-				unsigned int bk = (sc.currentPos > 0) ? sc.currentPos - 1: 0;
-				unsigned int bkend;
-				sc.Complete();
-				styler.Flush();
-				if (styler.StyleAt(bk) == SCE_PL_DEFAULT)
-					hereDocSpace = true;
-				skipWhitespaceComment(styler, bk);
-				if (bk == 0) {
-					// avoid backward scanning breakage
-					preferRE = true;
-				} else {
-					int bkstyle = styler.StyleAt(bk);
-					int bkch = static_cast<unsigned char>(styler.SafeGetCharAt(bk));
-					switch(bkstyle) {
-					case SCE_PL_OPERATOR:
-						preferRE = true;
-						if (bkch == ')' || bkch == ']') {
-							preferRE = false;
-						} else if (bkch == '}') {
-							// backtrack by counting balanced brace pairs
-							// needed to test for variables like ${}, @{} etc.
-							bkstyle = styleBeforeBracePair(styler, bk);
-							if (bkstyle == SCE_PL_SCALAR
-								|| bkstyle == SCE_PL_ARRAY
-								|| bkstyle == SCE_PL_HASH
-								|| bkstyle == SCE_PL_SYMBOLTABLE
-								|| bkstyle == SCE_PL_OPERATOR) {
-								preferRE = false;
-							}
-						} else if (bkch == '+' || bkch == '-') {
-							if (bkch == static_cast<unsigned char>(styler.SafeGetCharAt(bk - 1))
-								&& bkch != static_cast<unsigned char>(styler.SafeGetCharAt(bk - 2)))
-							// exceptions for operators: unary suffixes ++, --
-							preferRE = false;
-						}
-						break;
-					case SCE_PL_IDENTIFIER:
-						preferRE = true;
-						bkstyle = styleCheckIdentifier(styler, bk);
-						if ((bkstyle == 1) || (bkstyle == 2)) {
-							// inputsymbol or var with "->" or "::" before identifier
-							preferRE = false;
-						} else if (bkstyle == 3) {
-							// bare identifier, test cases follows:
-							if (sc.ch == '/') {
-								// if '/', /PATTERN/ unless digit/space immediately after '/'
-								// if '//', always expect defined-or operator to follow identifier
-								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
-									preferRE = false;
-							} else if (sc.ch == '*' || sc.ch == '%') {
-								if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
-									preferRE = false;
-							} else if (sc.ch == '<') {
-								if (IsASpace(sc.chNext) || sc.chNext == '=')
-									preferRE = false;
-							}
-						}
-						break;
-					case SCE_PL_SCALAR:		// for $var<< case:
-						if (isHereDoc && hereDocSpace)	// if SCALAR whitespace '<<', *always* a HERE doc
-							preferRE = true;
-						break;
-					case SCE_PL_WORD:
-						preferRE = true;
-						// for HERE docs, always true
-						if (sc.ch == '/') {
-							// adopt heuristics similar to vim-style rules:
-							// keywords always forced as /PATTERN/: split, if, elsif, while
-							// everything else /PATTERN/ unless digit/space immediately after '/'
-							// for '//', defined-or favoured unless special keywords
-							bkend = bk + 1;
-							while (bk > 0 && styler.StyleAt(bk - 1) == SCE_PL_WORD) {
-								bk--;
-							}
-							if (isPerlKeyword(bk, bkend, reWords, styler))
-								break;
-							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.chNext == '/')
-								preferRE = false;
-						} else if (sc.ch == '*' || sc.ch == '%') {
-							if (IsASpace(sc.chNext) || IsADigit(sc.chNext) || sc.Match('*', '*'))
-								preferRE = false;
-						} else if (sc.ch == '<') {
-							if (IsASpace(sc.chNext) || sc.chNext == '=')
-								preferRE = false;
-						}
-						break;
-					// other styles uses the default, preferRE=false
-					case SCE_PL_POD:
-					case SCE_PL_HERE_Q:
-					case SCE_PL_HERE_QQ:
-					case SCE_PL_HERE_QX:
-						preferRE = true;
-						break;
-					}
-				}
-				backFlag = BACK_NONE;
-				if (isHereDoc) {	// handle '<<', HERE doc
-					if (preferRE) {
-						sc.SetState(SCE_PL_HERE_DELIM);
-						HereDoc.State = 0;
-					} else {		// << operator
-						sc.SetState(SCE_PL_OPERATOR);
-						sc.Forward();
-					}
-				} else if (sc.ch == '*') {	// handle '*', typeglob
-					if (preferRE) {
-						sc.SetState(SCE_PL_SYMBOLTABLE);
-						if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
-							sc.Forward(2);
-						} else if (sc.chNext == '{') {
-							sc.ForwardSetState(SCE_PL_OPERATOR);
-						} else {
-							sc.Forward();
-						}
-					} else {
-						sc.SetState(SCE_PL_OPERATOR);
-						if (sc.chNext == '*') 	// exponentiation
-							sc.Forward();
-					}
-				} else if (sc.ch == '%') {	// handle '%', hash
-					if (preferRE) {
-						sc.SetState(SCE_PL_HASH);
-						if (setHash.Contains(sc.chNext)) {
-							sc.Forward();
-						} else if (sc.chNext == ':' && sc.GetRelative(2) == ':') {
-							sc.Forward(2);
-						} else if (sc.chNext == '{') {
-							sc.ForwardSetState(SCE_PL_OPERATOR);
-						} else {
-							sc.ChangeState(SCE_PL_OPERATOR);
-						}
-					} else {
-						sc.SetState(SCE_PL_OPERATOR);
-					}
-				} else if (sc.ch == '<') {	// handle '<', inputsymbol
-					if (preferRE) {
-						// forward scan
-						int i = inputsymbolScan(styler, sc.currentPos, endPos);
-						if (i > 0) {
-							sc.SetState(SCE_PL_IDENTIFIER);
-							sc.Forward(i);
-						} else {
-							sc.SetState(SCE_PL_OPERATOR);
-						}
-					} else {
-						sc.SetState(SCE_PL_OPERATOR);
-					}
-				} else {			// handle '/', regexp
-					if (preferRE) {
-						sc.SetState(SCE_PL_REGEX);
-						Quote.New();
-						Quote.Open(sc.ch);
-					} else {		// / and // operators
-						sc.SetState(SCE_PL_OPERATOR);
-						if (sc.chNext == '/') {
-							sc.Forward();
-						}
-					}
-				}
-			} else if (sc.ch == '='		// POD
-					   && setPOD.Contains(sc.chNext)
-					   && sc.atLineStart) {
-				sc.SetState(SCE_PL_POD);
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '-' && setWordStart.Contains(sc.chNext)) {	// extended '-' cases
-				unsigned int bk = sc.currentPos;
-				unsigned int fw = 2;
-				if (setSingleCharOp.Contains(sc.chNext) &&	// file test operators
-					!setWord.Contains(sc.GetRelative(2))) {
-					sc.SetState(SCE_PL_WORD);
-				} else {
-					// nominally a minus and bareword; find extent of bareword
-					while (setWord.Contains(sc.GetRelative(fw)))
-						fw++;
-					sc.SetState(SCE_PL_OPERATOR);
-				}
-				// force to bareword for hash key => or {variable literal} cases
-				if (disambiguateBareword(styler, bk, bk + fw, backFlag, backPos, endPos) & 2) {
-					sc.ChangeState(SCE_PL_IDENTIFIER);
-				}
-				backFlag = BACK_NONE;
-			} else if (sc.ch == '(' && sc.currentPos > 0) {	// '(' or subroutine prototype
-				sc.Complete();
-				if (styleCheckSubPrototype(styler, sc.currentPos - 1)) {
-					sc.SetState(SCE_PL_SUB_PROTOTYPE);
-					backFlag = BACK_NONE;
-				} else {
-					sc.SetState(SCE_PL_OPERATOR);
-				}
-			} else if (setPerlOperator.Contains(sc.ch)) {	// operators
-				sc.SetState(SCE_PL_OPERATOR);
-				if (sc.Match('.', '.')) {	// .. and ...
-					sc.Forward();
-					if (sc.chNext == '.') sc.Forward();
-				}
-			} else if (sc.ch == 4 || sc.ch == 26) {		// ^D and ^Z ends valid perl source
-				sc.SetState(SCE_PL_DATASECTION);
-			} else {
-				// keep colouring defaults
-				sc.Complete();
-			}
-		}
-	}
-	sc.Complete();
-}
-
-static bool IsCommentLine(int line, Accessor &styler) {
-	int pos = styler.LineStart(line);
-	int eol_pos = styler.LineStart(line + 1) - 1;
-	for (int i = pos; i < eol_pos; i++) {
-		char ch = styler[i];
-		int style = styler.StyleAt(i);
-		if (ch == '#' && style == SCE_PL_COMMENTLINE)
-			return true;
-		else if (!IsASpaceOrTab(ch))
-			return false;
-	}
-	return false;
+
+    // Lexer for perl often has to backtrack to start of current style to determine
+    // which characters are being used as quotes, how deeply nested is the
+    // start position and what the termination string is for here documents
+
+    WordList &keywords = *keywordlists[0];
+    
+    class HereDocCls {
+    public:
+        int State;      // 0: '<<' encountered
+        // 1: collect the delimiter
+        // 2: here doc text (lines after the delimiter)
+        char Quote;     // the char after '<<'
+        bool Quoted;        // true if Quote in ('\'','"','`')
+        int DelimiterLength;    // strlen(Delimiter)
+        char Delimiter[256];    // the Delimiter, 256: sizeof PL_tokenbuf
+        bool HasSemiColon;
+        HereDocCls() {
+            State = 0;
+            DelimiterLength = 0;
+            Delimiter[0] = '\0';
+        }
+    };
+    HereDocCls HereDoc;
+
+    class QuoteCls {
+        public:
+        int  Rep;
+        int  Count;
+        char Up;
+        char Down;
+        QuoteCls() {
+            this->New(1);
+        }
+        void New(int r) {
+            Rep   = r;
+            Count = 0;
+            Up    = '\0';
+            Down  = '\0';
+        }
+        void Open(char u) {
+            Count++;
+            Up    = u;
+            Down  = opposite(Up);
+        }
+    };
+    QuoteCls Quote;
+    // Info on parsing numbers
+    int numDots = 0;
+    int numBase = 10;
+    int numExponents = 0;
+
+    bool preferRE = true;
+    unsigned int lengthDoc = startPos + length;
+    bool binaryOperatorExpected = false; // If true, a binary operator can follow.
+    bool braceStartsBlock = true; // Whether a brace starts a block or an indexed expression
+    int variableNestingCount = 0; // The number of unclosed '(' and '{' in the current variable name.
+
+#if 0
+    int origStartPos = startPos;
+#endif
+
+    bool hasVisibleChars = false;
+
+    int state;
+    synchronizeDocStart(startPos, lengthDoc, state, styler);
+    
+    int previousState = SCE_PL_DEFAULT; // Used to restore the original state after a comment.
+
+    if (startPos < 0) {
+        startPos = 0;
+        state = SCE_PL_DEFAULT;
+    }
+#if 0
+    {
+        int origLine = styler.GetLine(origStartPos);
+        int newLine = styler.GetLine(startPos);
+        fprintf(stderr, "Synch: moved from [%d:%d:%d]=>(%d) to [%d:%d:%d], state %d\n",
+                origStartPos, origLine,
+                origStartPos - styler.LineStart(origLine),
+                lengthDoc,
+                startPos, newLine,
+                startPos - styler.LineStart(newLine),
+                state);
+        int targetPos = lengthDoc - 1;
+        int targetLine = styler.GetLine(targetPos);
+        fprintf(stderr, "Color chars upto [%d:%d:%d] (%d chars)\n",
+                targetPos, targetLine, targetPos - styler.LineStart(targetLine),
+                lengthDoc - startPos);
+    }
+#endif
+
+    // Work on this in case we hit an unmatched close-brace.
+    BracePositionInfo *p_BraceInfo = new BracePositionInfo();
+
+    // fprintf(stderr, "Starting lexing at pos %d (line %d)\n", startPos, styler.GetLine(startPos));
+
+    // Variables to allow folding.
+    bool fold = styler.GetPropertyInt("fold") != 0;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelPrev = 0, levelCurrent = 0;
+
+    // Properties
+    bool no_namespace_op = styler.GetPropertyInt("double_colons_are_names") != 0;
+    // bool be_verbose = strchr(styler.GetProperties(), 'v') != NULL;
+    {
+        // We need to modify the starting levels. Curly braces on the current or 
+        // previous lines affect their respective level because the level of a line 
+        // is calculated from its starting level.
+        int startOfCurrent = styler.LineStart(lineCurrent);
+        if (lineCurrent > 0) { 
+            int startOfPrev = styler.LineStart(lineCurrent-1);
+            levelPrev = ((styler.LevelAt(lineCurrent-1)
+                          & SC_FOLDLEVELNUMBERMASK
+                          & ~SC_FOLDLEVELBASE)
+                         + getFoldLevelModifier(styler,startOfPrev,startOfCurrent));
+            if (levelPrev < 0) {
+                levelPrev = 0;
+            }
+        }
+        levelCurrent = levelPrev + getFoldLevelModifier(styler,startOfCurrent,startPos);
+        if (levelCurrent < 0) {
+            levelCurrent =  0;
+        }
+    }
+    
+    // Get the styler and the character variables ready to go.
+    char lexerMask = 0x3f; // 6 bits
+    styler.StartAt(startPos, lexerMask);
+    char chPrev = styler.SafeGetCharAt(startPos - 1);
+    char chNext = styler.SafeGetCharAt(startPos);
+    styler.StartSegment(startPos);
+    static int q_states[] = {SCE_PL_STRING_QQ,
+                             SCE_PL_STRING_QR,
+                             SCE_PL_STRING_QW,
+                             SCE_PL_STRING_QX};
+    static const char* q_chars = "qrwx";
+
+    unsigned int i;
+    unsigned int actualLengthDoc = styler.Length();
+    for (i = startPos; i < lengthDoc; i++) {
+        char ch = chNext;
+        chNext = styler.SafeGetCharAt(i + 1);
+        char chNext2 = styler.SafeGetCharAt(i + 2);
+
+        if (styler.IsLeadByte(ch)) {
+            chNext = chNext2;
+            chPrev = ' ';
+            i += 1;
+            continue;
+        }
+        
+        // skip on DOS/Windows
+        // This has been here since day 1 but it's a bad idea as
+        // it can result in lexing of the previous item to bleed
+        // over the \r
+        //
+        // Obsolete code left in for documentation purposes:
+        // if (ch == '\r' && chNext == '\n') {
+        // continue;
+        // }
+
+        if (fold) {
+    
+            // Apply folding at the end of the line (if required).
+            if (ch == '\n' || (ch == '\r' && chNext != '\n')) {
+                int lev = levelPrev;
+                if (lev < 0 || lev > 0x3ff)
+                    lev = 0;
+                if (!hasVisibleChars) {
+                    lev |= SC_FOLDLEVELWHITEFLAG;
+                }
+                if (levelCurrent > levelPrev && i < lengthDoc - 1) {
+                    lev |= SC_FOLDLEVELHEADERFLAG;
+                }
+                styler.SetLevel(lineCurrent, lev | SC_FOLDLEVELBASE);
+                lineCurrent++;
+                levelPrev = (levelCurrent > 0) ? levelCurrent : 0;
+                hasVisibleChars = false;
+            } else if (!hasVisibleChars && !isspacechar(ch)) {
+                hasVisibleChars = true;
+            }
+        }
+        
+        if (HereDoc.State == 1 && isEOLChar(ch)) {
+            // Begin of here-doc (the line after the here-doc delimiter):
+            // Move back skipping whitespace, looking for semi-colon or start
+            char hch;
+            HereDoc.HasSemiColon = false;
+            int j = i - 1;
+            if (styler.SafeGetCharAt(j) == 10) j--;
+            if (styler.SafeGetCharAt(j) == 13) j--;
+            for (; j > 0 && (unsigned int) j > startPos; j--) {
+              hch = styler.SafeGetCharAt(j);
+              if (isEOLChar(hch)) {
+                break;
+              } else if (hch == ';') {
+                HereDoc.HasSemiColon = true;
+                break;
+              } else if (hch == ' ' || hch == '\t') {
+                 // continue;
+              } else {
+                break;
+              }
+            }
+            HereDoc.State = 2;
+            styler.ColourTo(i-1, state);
+            if (HereDoc.Quoted && state == SCE_PL_HERE_DELIM) {
+                // Missing quote at end of string! We are stricter than perl.
+                state = SCE_PL_ERROR;
+            } else {
+                state = SCE_PL_HERE_Q;
+            }
+        }
+        
+        // Skip over styles that have been set as stdio
+        {
+            // KOMODO -- interactive shell colorizing
+            int origStyle = safeStyleAt(i, styler);
+            if (isStdioChar(origStyle)) {
+                styler.ColourTo(i - 1, state);
+                while (++i < lengthDoc) {
+                    int style = safeStyleAt(i, styler);
+                    if (!isStdioChar(style)) {
+                        break;
+                    }
+                }
+                if (i < lengthDoc) {
+                    chPrev = styler.SafeGetCharAt(i - 1);
+                    chNext = styler[i];
+                    i--;
+                }
+                styler.StartSegment(i);
+                state = SCE_PL_DEFAULT;
+                continue;
+            }
+        }
+
+        if (state == SCE_PL_DEFAULT) {
+            if (isSafeDigit(ch)) {
+                styler.ColourTo(i - 1, state);
+                state = SCE_PL_NUMBER;
+                if (ch == '0') {
+                    if (chNext == 'x') {
+                        numBase = 16;
+                        // Move to the next char, 'x' isn't allowed inside a number
+                        advanceOneChar(i, ch, chNext, chNext2);
+                    } else if (chNext == 'b') {
+                        numBase = 2;
+                        // 'b' isn't allowed either
+                        advanceOneChar(i, ch, chNext, chNext2);
+                    } else {
+                        numBase = 8;
+                    }
+                } else {
+                    numDots = 0;
+                    numExponents = 0;
+                    numBase = 10;
+                }
+            } else if (iswordstart(ch)) {
+                binaryOperatorExpected = false;
+                styler.ColourTo(i - 1, state);
+                styler.Flush();
+                if (i > 0 && followsStartIndexer(styler, i - 1)) {
+                    preferRE = false;
+                    
+                    // Watch out for single-char barewords
+                    // And also watch out for q-strings in this context
+                    if (ch == 'q') {
+                        if (!iswordchar(chNext)) {
+                            if (precedesIndexer(styler, i + 1, lengthDoc)) {
+                                // color preceding string,
+                                // go to default
+                                styler.ColourTo(i, SCE_PL_STRING);
+                                // stay in state = SCE_PL_DEFAULT;
+                            } else {
+                                state = SCE_PL_STRING_Q;
+                                Quote.New(1);
+                            }
+                        } else if (strchr(q_chars, chNext) && !iswordchar(chNext2)) {
+                             if (precedesIndexer(styler, i + 2, lengthDoc)) {
+                                 // color preceding string,
+                                 // go to default
+                                 styler.ColourTo(i + 1, SCE_PL_STRING);
+                                 // stay in state = SCE_PL_DEFAULT;
+                             } else {
+                                 const char *hit = strchr(q_chars, chNext);
+                                 if (hit != NULL) {
+                                     state = q_states[hit - q_chars];
+                                 } else {
+                                     state = SCE_PL_STRING_QQ;
+                                 }
+                                 Quote.New(1);
+                             }
+                             advanceOneChar(i, ch, chNext, chNext2);
+                        } else {
+                            state = SCE_PL_WORD;
+                        }
+                    } else if (!iswordchar(chNext)) {
+                        styler.ColourTo(i, SCE_PL_STRING);
+                        braceStartsBlock = true;
+                    } else {
+                        state = SCE_PL_WORD;
+                    }
+                    // Look for keyword-like things that are followed
+                    // by fat commas.  You might think this doesn't always
+                    // work, but Perl doesn't allow
+                    // q=>...=
+                    // qq=>...=
+                    // s=>...=...=
+                    // tr=>...=...=
+                    // y=>...=...=
+
+                } else if (ch == 's' && !isSafeAlnum(chNext) && !isEOLChar(chNext)) {
+                    if (isFatCommaNext(styler, i + 1, lengthDoc)) {
+                        styler.ColourTo(i, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_REGSUBST;
+                        Quote.New(2);
+                    }
+                } else if (ch == 'x' && !isSafeAlnum(chNext)) {
+                    if (isFatCommaNext(styler, i + 1, lengthDoc)) {
+                        styler.ColourTo(i, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        styler.ColourTo(i, SCE_PL_OPERATOR);
+                    }
+                } else if (ch == 'm' && !isSafeAlnum(chNext)) {
+                    if (isFatCommaNext(styler, i + 1, lengthDoc)) {
+                        styler.ColourTo(i, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_REGEX;
+                        Quote.New(1);
+                    }
+                } else if (ch == 'q' && !isSafeAlnum(chNext)) {
+                    if (isFatCommaNext(styler, i + 1, lengthDoc)) {
+                        styler.ColourTo(i, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_STRING_Q;
+                        Quote.New(1);
+                    }
+                } else if (ch == 'y' && !isSafeAlnum(chNext)) {
+                    if (isFatCommaNext(styler, i + 1, lengthDoc)) {
+                        styler.ColourTo(i, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_REGSUBST;
+                        Quote.New(2);
+                    }
+                } else if (ch == 't' && chNext == 'r' && !isSafeAlnum(chNext2)) {
+                    if (isFatCommaNext(styler, i + 2, lengthDoc)) {
+                        styler.ColourTo(i + 1, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_REGSUBST;
+                        Quote.New(2);
+                    }
+                    advanceOneChar(i, ch, chNext, chNext2);
+                } else if (ch == 'q' && (chNext == 'q' || chNext == 'r' || chNext == 'w' || chNext == 'x') && !isSafeAlnum(chNext2)) {
+                    if (isFatCommaNext(styler, i + 2, lengthDoc)) {
+                        styler.ColourTo(i + 1, SCE_PL_STRING_Q);
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        const char *hit = strchr(q_chars, chNext);
+                        if (hit != NULL) {
+                            state = q_states[hit - q_chars];
+                        }
+                        Quote.New(1);
+                    }
+                    advanceOneChar(i, ch, chNext, chNext2);
+
+                } else {
+                    preferRE = false;
+                    if (wordEndsHere(chNext, chNext2, no_namespace_op)) {
+                        // We need that if length of word == 1!
+                        // This test is copied from the SCE_PL_WORD handler.
+                        int wordStart = styler.GetStartSegment();
+                        if (classifyWordPerl(wordStart, i, lengthDoc,
+                                             keywords, styler, &braceStartsBlock) == SCE_PL_WORD)
+                        {               
+                            preferRE = RE_CanFollowKeyword(wordStart,i,styler);
+                        } else {
+                            binaryOperatorExpected = true;
+                        }
+                        state = SCE_PL_DEFAULT;
+                    } else {
+                        state = SCE_PL_WORD;
+                    }
+                }
+            } else if (ch == '#') {
+                styler.ColourTo(i - 1, state);
+                previousState = state;
+                state = SCE_PL_COMMENTLINE;
+            
+            } else if (ch == '\"') {
+                styler.ColourTo(i - 1, state);
+                state = SCE_PL_STRING;
+                Quote.New(1);
+                Quote.Open(ch);
+            } else if (ch == '\'') {
+                // Don't handle archaic calls.
+                if (chPrev != '&') {
+                    styler.ColourTo(i - 1, state);
+                    state = SCE_PL_CHARACTER;
+                    Quote.New(1);
+                    Quote.Open(ch);
+                }
+            } else if (ch == '`') {
+                styler.ColourTo(i - 1, state);
+                state = SCE_PL_BACKTICKS;
+                Quote.New(1);
+                Quote.Open(ch);
+
+            // Handle all the variable indicators.
+            } else if (ch == '$' || ch == '%' || ch == '@') {
+                preferRE = false;
+                binaryOperatorExpected = true;
+                styler.ColourTo(i - 1, state);
+                int variableType = 
+                    (ch == '$') ? SCE_PL_SCALAR : (ch == '%') ? SCE_PL_HASH : SCE_PL_ARRAY;
+                if (i == lengthDoc - 1) {
+                    // Prevent a crash.
+                    preferRE = true;
+                    binaryOperatorExpected = false;
+                    braceStartsBlock = true;
+                    state = SCE_PL_OPERATOR;
+                } else if (chNext == '{' && chNext2 == '^') {
+                    // New builtins are coming in as ${^DESCRIPTION}
+                    // To simplify brace-matching color the ${ as op,
+                    // the inners as scalar, and the close-} will be
+                    // colored as an op.
+                    levelCurrent++;
+                    i += 2;
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+                    chNext = styler.SafeGetCharAt(i+1);
+                    state = variableType;
+                    p_BraceInfo->add(SCE_PL_OPERATOR);
+                } else if (isSafeAlnum(chNext) || chNext == '_' || chNext == '{') {
+                    state = variableType;
+                } else if (chNext == ':' && chNext2 == ':') {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    state = variableType;
+                } else if (chNext == '^' && isSafeAlnum(chNext2)) {
+                    i += 2;
+                    chNext = styler.SafeGetCharAt(i+1);
+                    styler.ColourTo(i, variableType);
+                } else if (ch == '$' && chNext == '#') {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    state = SCE_PL_SCALAR;
+                } else if (ch == '$' && chNext == '$') {
+                    // $$ is a scalar if it isn't followed by '$' or varstart
+                    // otherwise it's the start of a longer scalar thing,
+                    // involving 2+ dereferences.
+                    // Helpful thing -- the 'x' operator requires white-space
+                    //
+                    // $$ x ... != $$x ...
+                    // So if $$ is followed by neither '$' nor var name,
+                    // it's atomic.  Otherwise we have a sequence of '$'
+                    // which must eventually be followed by a brace or varname
+                    //
+                    // And we let ${...} be colored separately.
+                    
+                    if (chNext2 == '$') {
+                        i += 2;
+                        while ((chNext = styler.SafeGetCharAt(i + 1)) == '$') {
+                            i++;
+                        }
+                        state = SCE_PL_SCALAR;
+                    } else if (isSafeAlpha(chNext2) || chNext2 == '_') {
+                        advanceOneChar(i, ch, chNext, chNext2);
+                        state = SCE_PL_SCALAR;
+                    } else {
+                        advanceOneChar(i, ch, chNext, chNext2);
+                        styler.ColourTo(i, variableType);
+                        state = SCE_PL_DEFAULT;
+                        braceStartsBlock = true;
+                    }
+                } else if (ch == '@' && chNext == '$') {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    state = SCE_PL_ARRAY;
+                } else if (ch == '%' && chNext == '$') {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    state = SCE_PL_HASH;
+                } else if (ispunct(chNext)) {
+                    if (chNext == '{') {
+                        p_BraceInfo->add(SCE_PL_VARIABLE_INDEXER);
+                        levelCurrent++;
+                    }
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    styler.ColourTo(i, variableType);
+                    braceStartsBlock = false;
+                } else {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+                    preferRE = true;
+                    binaryOperatorExpected = false;
+                    braceStartsBlock = true;
+                }
+
+            } else if (ch == '*') {
+                styler.ColourTo(i - 1, state);
+                if (chNext == '*') {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+                    braceStartsBlock = true;
+                } else if (isSafeAlpha(chNext) || chNext == '_' || chNext == '{') {
+                    preferRE = false;
+                    state = SCE_PL_SYMBOLTABLE;
+                } else if (chNext == ':' && chNext2 == ':') {
+                    preferRE = false;
+                    i++;
+                    state = SCE_PL_SYMBOLTABLE;
+                } else {
+                    binaryOperatorExpected = false;
+                    styler.ColourTo(i,SCE_PL_OPERATOR);
+                    braceStartsBlock = true;
+                }
+                
+            } else if ((ch == '/' || ch == '?') && preferRE) {
+                styler.ColourTo(i - 1, state);
+                state = SCE_PL_REGEX;
+                Quote.New(1);
+                Quote.Open(ch);
+
+            } else if (ch == '<') {
+                // Recognise the '<<' symbol - either a here document or a left bit-shift operator.
+                if (chNext == '<') {
+                    styler.ColourTo(i - 1, state);
+                    advanceOneChar(i, ch, chNext, chNext2);
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+
+                    // It sucks, but we need to look both backwards and
+                    // forwards to disambiguate here docs.
+                    //
+                    // Requirements for '<<' to be a here doc op
+                    // After:
+                    // space | quote | apos | letter _ '_'
+                    //
+                    // Before:
+                    // skip spaces, get one of:
+                    // op style
+                    // ident
+
+                    // Don't look at binaryOperatorExpected, etc.
+                    // They don't give enough info
+
+                    bool couldBeHereDoc = false;
+
+                    if (chNext2 == '\''
+                        || chNext2 == '"'
+                        || chNext2 == '_'
+                        || chNext2 == '`'
+                        || isSafeAlpha(chNext2)) {
+                        couldBeHereDoc = true;
+                    } else if (chNext2 == ' ') {
+                        // Look ahead -- if we hit a newline, it's not
+                        // If we hit a digit or scalar, it isn't
+                        // If we hit a string, it isn't
+                        // If we hit an operator, it's hard to say...
+                        int inext;
+                        char inextChar;
+                        // Watch out for those border situations.
+                        for (inext = i + 2; inext < (int) actualLengthDoc; inext++) {
+                            inextChar = styler.SafeGetCharAt(inext);
+                            if (inextChar == ' ' || inextChar == '\t') {
+                                continue;
+                            } else {
+                                if (isEOLChar(inextChar)) {
+                                // nothing left to do
+                                } else if (isSafeAlnum(inextChar) || inextChar == '_') {
+                                // nothing left to do
+                                } else {
+                                    switch(inextChar) {
+                                        case '@':
+                                        case '$':
+                                        case '(':
+                                            // nothing left to do
+                                            break;
+                                            // These two are ambiguous, so turn it on
+                                            // Use parens to turn off here-doc
+                                        case '-':
+                                        case '+':
+                                            couldBeHereDoc = true;
+                                            break;
+                                            
+                                        case '"':
+                                        case '\'':
+                                            // This gets more complicated
+                                            // If the first char after the quote
+                                            // is EOL, not a here-doc
+                                            // If it's a digit, not a here-doc
+                                            // Otherwise assume it is, and
+                                            // ignore space between
+                                            // << and the quoted target.
+                                            // Whatever happens, we're breaking
+                                            // at this point.
+                                            if (inext < (int) actualLengthDoc - 1) {
+                                                char inext2Char = styler.SafeGetCharAt(inext + 1);
+                                                if (inext2Char == '\r'
+                                                    || inext2Char == '\n') {
+                                                    // not a here doc
+                                                } else if (isSafeDigit(inext2Char)) {
+                                                    // not a here doc
+                                                } else {
+                                                    couldBeHereDoc = true;
+                                                }
+                                            }
+                                            break;
+                                            
+                                        default:
+                                            // Most other chars indicate something
+                                            // like <<[string] op...
+                                            couldBeHereDoc = true;
+                                    }
+                                }
+                                break;
+                            }
+                        }
+                    }
+                
+                    if (couldBeHereDoc) {
+                        // Look back to see what else we have
+                        int prevStyle;
+                        int iprev;
+                        char iprevChar;
+                        styler.Flush();
+                        for (iprev = i - 2; iprev >= 0; iprev--) {
+                            prevStyle = safeStyleAt(iprev, styler);
+                            if (prevStyle == SCE_PL_DEFAULT) {
+                                iprevChar = styler.SafeGetCharAt(iprev);
+                                if ((unsigned int) iprevChar < 128 && isspace(iprevChar)) {
+                                    continue;
+                                } else {
+                                    couldBeHereDoc = false;
+                                    break;
+                                }
+                            } else {
+                                switch (prevStyle) {
+                                    case SCE_PL_OPERATOR:
+                                    case SCE_PL_VARIABLE_INDEXER:
+                                        // Make sure it isn't a space colored as op
+                                        // due to context.
+                                        iprevChar = styler.SafeGetCharAt(iprev);
+                                        if ((unsigned int) iprevChar < 128 && isspace(iprevChar)) {
+                                            continue;
+                                        } else {
+                                            couldBeHereDoc = true;
+                                        }
+                                        break;
+                                    case SCE_PL_WORD:
+                                    case SCE_PL_IDENTIFIER:
+                                        // Assume word|ident << string starts a here-doc
+                                    case SCE_PL_HERE_DELIM:
+                                        // Two here-docs in a row that aren't stacked
+                                        // (see bug 76004).
+                                        couldBeHereDoc = true;
+                                        break;
+                                    
+                                    case SCE_PL_SCALAR:
+                                        iprev -= 1;
+                                        styler.Flush();
+                                        while (iprev > 0 &&
+                                               safeStyleAt(iprev, styler) == SCE_PL_SCALAR){
+                                            iprev -= 1;
+                                        }
+                                        while (styler.SafeGetCharAt(iprev) == ' ') {
+                                            iprev -= 1;
+                                        }
+                                        prevStyle = safeStyleAt(iprev, styler);
+                                        if (prevStyle == SCE_PL_WORD
+                                            || prevStyle == SCE_PL_IDENTIFIER) {
+                                            couldBeHereDoc = true;
+                                        } else {
+                                            couldBeHereDoc = false;
+                                        }
+                                        break;
+                                    
+                                    default:
+                                        couldBeHereDoc = false;
+                                }
+                                break;
+                            }
+                        }
+                    }
+
+                    if (couldBeHereDoc) {
+                        state = SCE_PL_HERE_DELIM;
+                        HereDoc.State = 0;
+                    }
+
+                } else {
+                    styler.ColourTo(i-1, state);
+                    preferRE = false;
+                    binaryOperatorExpected = false;
+                    braceStartsBlock = true;
+                    if (chNext == '=') {
+                        if (chNext2 == '>') {
+                            i += 2;
+                            chNext = styler.SafeGetCharAt(i + 1);
+                        } else {
+                            advanceOneChar(i, ch, chNext, chNext2);
+                        }
+                    }
+                    // Leave state at default for all three operators
+                    styler.ColourTo(i,SCE_PL_OPERATOR);
+                }
+            } else if (ch == '=' && isSafeAlpha(chNext) && (i == 0 || isEOLChar(chPrev))) {
+                styler.ColourTo(i - 1, state);
+                state = SCE_PL_POD;
+                levelCurrent++;
+            } else if (ch == '-' && chPrev != '-' && !binaryOperatorExpected && 
+                       isWordBeforeFatComma(styler,i+1,lengthDoc)) {
+                styler.ColourTo(i-1, state);
+                state = SCE_PL_WORD;
+                braceStartsBlock = true;
+            } else if (ch == '-' && chNext == '>') {
+                styler.ColourTo(i-1,state);
+                styler.ColourTo(i+1,SCE_PL_OPERATOR);
+                advanceOneChar(i, ch, chNext, chNext2);
+                state = SCE_PL_UNKNOWN_FIELD;
+                braceStartsBlock = false;
+            } else if (ch == '-' && isSingleCharOp(chNext) && !isSafeAlnum(chNext2)) {
+                styler.ColourTo(i - 1, state);
+                styler.ColourTo(i + 1, SCE_PL_WORD);
+                state = SCE_PL_DEFAULT;
+                preferRE = false;
+                binaryOperatorExpected = false;
+                braceStartsBlock = true;
+                advanceOneChar(i, ch, chNext, chNext2);
+            } else if (ch == '=' && chNext == '>') {
+                styler.ColourTo(i - 1, state);
+                styler.ColourTo(i + 1, SCE_PL_OPERATOR);
+                preferRE = false;
+                binaryOperatorExpected = false;
+                braceStartsBlock = false;
+                advanceOneChar(i, ch, chNext, chNext2);
+            } else if (ch == ':' && chNext == ':' && no_namespace_op) {
+                preferRE = true;
+                binaryOperatorExpected = true;
+                braceStartsBlock = true;
+                styler.ColourTo(i - 1, state);
+                if (iswordstart(chNext2)) {
+                    state = SCE_PL_WORD;
+                } else {
+                    styler.ColourTo(i + 1, SCE_PL_IDENTIFIER);
+                }
+                advanceOneChar(i, ch, chNext, chNext2);
+            } else if (ch == '.') {
+                styler.ColourTo(i - 1, state);
+                // Now what we do next depends on what follows
+                if (isSafeDigit(chNext)) {
+                    state = SCE_PL_NUMBER;
+                    numDots = 1;
+                    numExponents = 0;
+                    numBase = 10;
+                } else {
+                    if (chNext == '.') {
+                        if (chNext2 == '.') {
+                            ch = chNext2;
+                            chNext = styler.SafeGetCharAt(i + 3);
+                            i += 2;
+                        } else {
+                            advanceOneChar(i, ch, chNext, chNext2);
+                        }
+                    }
+                    // Either it's a concat op or a flip op
+                    preferRE = true;
+                    braceStartsBlock = false;
+                    binaryOperatorExpected = false;
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+                    // And stay in default state
+                }
+            } else if (isPerlOperator(ch)) {
+                if (ch == ')' || ch == ']' || (ch == '}' && variableNestingCount)) {
+                    preferRE = false;
+                } else {
+                    preferRE = true;
+                }
+                
+                styler.ColourTo(i - 1, state);
+                int operatorType = SCE_PL_OPERATOR;
+
+                // If this is an open bracket operator, start a fold.
+                if (ch == '[') {
+                    operatorType = SCE_PL_VARIABLE_INDEXER;
+                    variableNestingCount++;
+                    braceStartsBlock = false;
+                    binaryOperatorExpected = false;
+                    levelCurrent++;
+                } else if (ch == '{') {
+                    bool look_for_bareword = false;
+                    if (!braceStartsBlock) {
+                        operatorType = SCE_PL_VARIABLE_INDEXER;
+                        variableNestingCount++;
+                        look_for_bareword = (variableNestingCount == 1);
+                    }
+                    p_BraceInfo->add(operatorType);
+                    levelCurrent++;
+                    binaryOperatorExpected = false;
+                    if (look_for_bareword && lookingAtBareword(styler, i + 1, actualLengthDoc)) {
+                        // fprintf(stderr, "Looking at a bareword after a brace at posn %d\n", i);
+                        styler.ColourTo(i, SCE_PL_VARIABLE_INDEXER);
+                        ch = colouriseBareword(styler, i, state, actualLengthDoc);
+                        chNext = styler.SafeGetCharAt(i + 1);
+                    }
+                } else if (ch == '(') {
+                    binaryOperatorExpected = false;
+                    levelCurrent++;
+                    braceStartsBlock = false;
+                // If this is a close bracket operator, end the previous fold.
+                } else if (ch == ']') {
+                    if (variableNestingCount) {
+                        operatorType = SCE_PL_VARIABLE_INDEXER;
+                        variableNestingCount--;
+                        binaryOperatorExpected = true;
+                        preferRE = false;
+                        braceStartsBlock = false;
+                    
+                        if (chNext == '-' && chNext2 == '>') {
+                            state = SCE_PL_UNKNOWN_FIELD;
+                        }
+
+                    } else {
+                        binaryOperatorExpected = false;
+                    }
+                    if (levelCurrent > 0) {
+                        levelCurrent--;
+                    }
+                } else if (ch == '}') {
+                    operatorType = p_BraceInfo->getStyle();
+                    if (operatorType == -1) {
+                        // fprintf(stderr, " op type: %d\n", operatorType);
+                        operatorType = GetMatchingStyle(i, styler);
+                        // fprintf(stderr, "GetMatchingStyle(%d) => %d\n", i, operatorType);
+                    }
+                    // Keep this updated
+                    if (operatorType == SCE_PL_VARIABLE_INDEXER) {
+                        if (variableNestingCount > 0) {
+                            variableNestingCount--;
+                        }
+                        binaryOperatorExpected = true;
+                        preferRE = false;
+                        if (chNext == '-' && chNext2 == '>') {
+                            state = SCE_PL_UNKNOWN_FIELD;
+                        }
+                    } else {
+                        binaryOperatorExpected = false;
+                    }
+                    if (levelCurrent > 0) {
+                        levelCurrent--;
+                    }
+                    braceStartsBlock = false;
+                } else if (ch == ')') {
+                    binaryOperatorExpected = false;
+                    braceStartsBlock = true;
+                    if (levelCurrent > 0) {
+                        levelCurrent--;
+                    }
+                } else {
+                    // Analyze the other operators
+                    binaryOperatorExpected = false;
+                    switch (ch) {
+                        case '=':
+                        case ',':
+                        case '\\':
+                        case '?':
+                            braceStartsBlock = false;
+                            break;
+                            
+                        case '&':
+                        case '|':
+                            braceStartsBlock = (chPrev != ch);
+                            break;
+
+                        case ':':
+                            // If we're in a ternary operator, bSB is false
+                            // If we're after a label, it doesn't.
+                            // Let's look back: if we see /(^|;(10))\s*\w+(5|11)<here>/,
+                            // assume it's a label.  Otherwise it's ternary
+                            braceStartsBlock = afterLabel(i - 1, styler);
+                            break;
+
+                        case '+':
+                        case '-':
+                            // If we're followed by the same char,
+                            // handle preferRE etc differently
+                            if (chNext == ch) {
+                                binaryOperatorExpected = true;
+                                preferRE = false;
+                                braceStartsBlock = true;
+                                advanceOneChar(i, ch, chNext, chNext2);
+                            }
+                            break;
+                        
+                        case '/':
+                            if (chNext == '/') {
+                                // Perl 5.10 definedness or-operator
+                                advanceOneChar(i, ch, chNext, chNext2);
+                            }
+                            braceStartsBlock = true;
+                            break;
+
+                        default:
+                            braceStartsBlock = true;
+                            break;
+                    }
+                }
+                styler.ColourTo(i, operatorType);
+            }
+        } else if (state == SCE_PL_WORD) {
+            if (ch == ':' && chNext == ':' && no_namespace_op) {
+                // Skip over the namespace separator
+                if (!iswordstart(chNext2)) {
+                    // The word ends here
+                    preferRE = true;
+                    binaryOperatorExpected = true;
+                    braceStartsBlock = true;
+                    styler.ColourTo(i, SCE_PL_IDENTIFIER);
+                    state = SCE_PL_DEFAULT;
+                }
+                ch = chNext2;
+                chNext = styler.SafeGetCharAt(i + 3);
+                i += 2;
+            } else if (wordEndsHere(chNext, chNext2, no_namespace_op)) {
+                styler.Flush();
+                // Be strict in what we'll color bare
+                if ((i == lengthDoc - 1 || chNext == '}')
+                    && followsStartIndexer(styler, i - 1)) {
+                    styler.ColourTo(i, SCE_PL_STRING);
+                    state = SCE_PL_DEFAULT;
+                } else {
+                    bool doDefault = false;
+                    unsigned int kwdStartPos = styler.GetStartSegment();
+                    char sequenceStartChar = styler[kwdStartPos];
+                    if (sequenceStartChar == '_') {
+                        if (isMatch(styler, lengthDoc, kwdStartPos, "__DATA__")) {
+                            styler.ColourTo(i, SCE_PL_DATASECTION);
+                            state = SCE_PL_DATASECTION;
+                        } else if (isMatch(styler, lengthDoc, kwdStartPos, "__END__")) {
+                            styler.ColourTo(i, SCE_PL_DATASECTION);
+                            state = SCE_PL_DATASECTION;
+                        } else {
+                            doDefault = true;
+                        }
+                    } else if (kwdStartPos + 5 == i
+                               && sequenceStartChar == 'f'
+                               && isMatch(styler, lengthDoc, kwdStartPos, "format")
+                               && atStartOfFormatStmt(i, lengthDoc, styler)) {
+                        state = SCE_PL_FORMAT;
+                        // Don't need to set chNext2
+                        ch = styler.SafeGetCharAt(i);
+                        chNext = styler.SafeGetCharAt(i + 1);
+                    } else {
+                        doDefault = true;
+                    }
+                    if (doDefault) {
+                        state = SCE_PL_DEFAULT;
+                        ch = ' ';
+                    
+                        // Recognise the beginning of a subroutine - enter the SUB state.
+                        if (kwdStartPos+2 == i && isMatch(styler, lengthDoc, kwdStartPos, "sub")) { 
+                            for (unsigned int j = i+1;j < lengthDoc;j++) {
+                                char c = styler.SafeGetCharAt(j);
+                                if (!isspacechar(c)) {
+                                    if (isSafeAlpha(c) || c == '_' || c == '{' || c == ';' || c == '(') {
+                                        styler.ColourTo(i,SCE_PL_WORD);
+                                        state = SCE_PL_SUB;
+                                    } else {
+                                        styler.ColourTo(i,SCE_PL_IDENTIFIER);
+                                    }
+                                    break;
+                                }
+                            }
+                            styler.ColourTo(i,SCE_PL_WORD);
+                            braceStartsBlock = true;
+                         
+                            // Colour the word as a number, identifier or keyword.
+                        } else if (classifyWordPerl(kwdStartPos,i,lengthDoc,keywords,styler, &braceStartsBlock) == SCE_PL_WORD) {             
+                            preferRE = RE_CanFollowKeyword(kwdStartPos,i,styler);
+
+                        } else {
+                            binaryOperatorExpected = true;
+                            braceStartsBlock = true;
+                        }
+                    }
+                }
+            }
+        } else if (state == SCE_PL_NUMBER) {
+            bool restyle = false;
+            if (isSafeDigit(ch) || ch == '_') {
+                // Keep going
+            } else if (numBase == 10) {
+                if (ch == '.') {
+                    restyle = !(++numDots == 1 && numExponents == 0 && chNext != '.');
+                } else if (ch == 'e' || ch == 'E') {
+                    restyle = !(++numExponents == 1);
+                } else if (ch == '-' && (chPrev == 'e' || chPrev == 'E')) {
+                    // Keep going
+                } else {
+                    restyle = true;
+                }
+            } else if (numBase == 16 && strchr("abcdefABCDEF", ch)) {
+                // Keep going
+            } else {
+                restyle = true;
+            }
+            if (restyle) {
+                styler.ColourTo(i - 1, state);
+                // Retry with this character.
+                // Special-case handling of newlines due to how folding works
+                if (ch == '\n' || ch == '\r') {
+                    // Default is fine, no need to do anything else.
+                } else if (ch == '.' && chNext != '.') {
+                    // Special case this, otherwise something like
+                    // 0x3.4 will be colorized as two contiguous numbers
+                    styler.ColourTo(i, SCE_PL_OPERATOR);
+                } else {
+                    retreatOneChar(i, chPrev, ch, chNext);
+                }
+                state = SCE_PL_DEFAULT;
+                preferRE = false;
+                binaryOperatorExpected = true;
+                braceStartsBlock = true;
+            }
+        } else if (state == SCE_PL_COMMENTLINE) {
+            if (isEOLChar(ch)) {
+                styler.ColourTo(i - 1, state);
+                state = previousState;
+            }
+        } else if (state == SCE_PL_HERE_DELIM) {
+            //
+            // From perldata.pod:
+            // ------------------
+            // A line-oriented form of quoting is based on the shell ``here-doc''
+            // syntax.
+            // Following a << you specify a string to terminate the quoted material,
+            // and all lines following the current line down to the terminating
+            // string are the value of the item.
+            // The terminating string may be either an identifier (a word),
+            // or some quoted text.
+            // If quoted, the type of quotes you use determines the treatment of
+            // the text, just as in regular quoting.
+            // An unquoted identifier works like double quotes.
+            // There must be no space between the << and the identifier.
+            // (If you put a space it will be treated as a null identifier,
+            // which is valid, and matches the first empty line.)
+            // The terminating string must appear by itself (unquoted and with no
+            // surrounding whitespace) on the terminating line.
+            //
+            if (HereDoc.State == 0) { // '<<' encountered
+                HereDoc.State = 1;
+                HereDoc.Quote = ch;
+                HereDoc.Quoted = false;
+                HereDoc.DelimiterLength = 0;
+                HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                
+                // A quoted here-doc delimiter.
+                if (ch == '\'' || ch == '"' || ch == '`') { 
+                    HereDoc.Quoted = true;
+                
+                   // TODO: does this need to be handled differently? as a ref?
+                } else if (chNext == '\\') {
+            
+                   // An unquoted here-doc delimiter.
+                } else if (isSafeAlnum(ch)) {
+                    HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+                    HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                
+                // deprecated here-doc delimiter
+                } else if (isspacechar(ch)) {
+                    styler.ColourTo(i, state);
+                    state = SCE_PL_DEFAULT;
+                    braceStartsBlock = true;
+                }
+
+            } else if (HereDoc.State == 1) { // collect the delimiter
+                if (HereDoc.Quoted) { // a quoted here-doc delimiter
+                    if (ch == HereDoc.Quote) { // closing quote => end of delimiter
+                        styler.ColourTo(i, state);
+                        state = SCE_PL_DEFAULT;
+                        binaryOperatorExpected = true;
+                        braceStartsBlock = true;
+                    } else {
+                        if (ch == '\\' && chNext == HereDoc.Quote) { // escaped quote
+                            advanceOneChar(i, ch, chNext, chNext2);
+                        }
+                        HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+                        HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                    }
+                } else { // an unquoted here-doc delimiter
+                    if (isSafeAlnum(ch)) {
+                        HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+                        HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                    } else {
+                        styler.ColourTo(i - 1, state);
+                        state = SCE_PL_DEFAULT;
+                        braceStartsBlock = true;
+                        // Retry with this character.
+                        retreatOneChar(i, chPrev, ch, chNext);
+                    }
+                }
+                if (HereDoc.DelimiterLength >= static_cast<int>(sizeof(HereDoc.Delimiter)) - 1) {
+                    styler.ColourTo(i - 1, state);
+                    state = SCE_PL_ERROR;
+                    braceStartsBlock = true;
+                }
+            }
+
+        } else if (HereDoc.State == 2 && isEOLChar(chPrev)) {
+
+            // Look for a blank line to end a space delimited here document.
+            if (isspacechar(HereDoc.Quote) && isEOLChar(ch)) {
+                styler.ColourTo(i - 1, state);
+                styler.ColourTo(i, SCE_PL_HERE_DELIM);
+                state = SCE_PL_DEFAULT;
+                HereDoc.State = 0;
+                preferRE = HereDoc.HasSemiColon;
+                HereDoc.HasSemiColon = false;
+                braceStartsBlock = true;
+            
+            // Look for the here document's delimiter.
+            } else if (isMatch(styler, lengthDoc, i, HereDoc.Delimiter)) {
+                styler.ColourTo(i - 1, state);
+                i += HereDoc.DelimiterLength - 1;
+                chNext = styler.SafeGetCharAt(i + 1);
+                if (isEOLChar(chNext)) {
+                    styler.ColourTo(i, SCE_PL_HERE_DELIM);
+                    state = SCE_PL_DEFAULT;
+                    HereDoc.State = 0;
+                    preferRE = HereDoc.HasSemiColon;
+                    HereDoc.HasSemiColon = false;
+                    braceStartsBlock = true;
+                }
+            }
+            
+        } else if (state == SCE_PL_SCALAR || state == SCE_PL_ARRAY || state == SCE_PL_HASH || 
+                   state == SCE_PL_SYMBOLTABLE) { 
+            
+            // Recognise if the variable is indexed.
+            if (ch == '{' || ch == '[') {
+                styler.ColourTo(i-1, state);
+                styler.ColourTo(i, SCE_PL_VARIABLE_INDEXER);
+                variableNestingCount++;
+                binaryOperatorExpected = false;
+                levelCurrent++;
+                if (ch == '{') {
+                    p_BraceInfo->add(SCE_PL_VARIABLE_INDEXER);
+                }
+                state = SCE_PL_DEFAULT;
+                braceStartsBlock = false;
+                if (lookingAtBareword(styler, i + 1, actualLengthDoc)) {
+                    // fprintf(stderr, "Looking at a bareword after a brace indexer at posn %d\n", i);
+                    ch = colouriseBareword(styler, i, state, actualLengthDoc);
+                    chNext = styler.SafeGetCharAt(i + 1);
+                }
+            
+            // Skip over the namespace symbol.
+            } else if (chNext == ':' && chNext2 == ':') {
+                if (no_namespace_op) {
+                    ch = chNext2;
+                    chNext = styler.SafeGetCharAt(i + 3);
+                    i += 2;
+                } else {
+                    advanceOneChar(i, ch, chNext, chNext2);
+                }
+            } else if (ch == '-' && chNext == '>') {
+                styler.ColourTo(i-1,state);
+                styler.ColourTo(i+1,SCE_PL_OPERATOR);
+                advanceOneChar(i, ch, chNext, chNext2);
+                state = SCE_PL_UNKNOWN_FIELD;
+                braceStartsBlock = false;
+                
+            // If the next character is not a legal variable character, colour 
+            // the preceding variable name and return to the default state.
+            } else if (isspacechar(chNext) || 
+                       (isEndVar(chNext) && (chNext != '-' || chNext2 != '>'))) {
+                styler.ColourTo(i, state);
+                state = SCE_PL_DEFAULT;
+                binaryOperatorExpected = true;
+                braceStartsBlock = !isspacechar(chNext);
+                if (ch == '(') {
+                    levelCurrent++;
+                } else if (strchr(")]}", ch) && levelCurrent > 0) {
+                    levelCurrent--;
+                }
+            }
+
+        } else if (state == SCE_PL_UNKNOWN_FIELD) {
+            // after --> 
+            if (ch == '{' || ch == '[') {
+                styler.ColourTo(i, SCE_PL_VARIABLE_INDEXER);
+                variableNestingCount++;
+                binaryOperatorExpected = false;
+                levelCurrent++;
+                if (ch == '{') {
+                    p_BraceInfo->add(SCE_PL_VARIABLE_INDEXER);
+                }
+                state = SCE_PL_DEFAULT;
+                braceStartsBlock = false;
+            } else if (ch == '(') {
+                // It's a function name, using indirect accessor
+                // notation:
+                // $obj->[selector]->(args) ===
+                // &{$obj->[selector]}(args)
+                styler.ColourTo(i, SCE_PL_OPERATOR);
+                binaryOperatorExpected = false;
+                state = SCE_PL_DEFAULT;
+                braceStartsBlock = false;
+                levelCurrent++;
+            } else if (iswordstart(ch)) {
+                // It's a function name
+                styler.ColourTo(i - 1, state);
+                binaryOperatorExpected = true;
+                if (!iswordchar(chNext)) {
+                    state = SCE_PL_DEFAULT;
+                } else {
+                    state = SCE_PL_WORD;
+                }
+                braceStartsBlock = false;
+            } else if (ch == '-' && chNext == '>') {
+                // Another arrow?  Color it as an operator, and stay here.
+                styler.ColourTo(i+1,SCE_PL_OPERATOR);
+                advanceOneChar(i, ch, chNext, chNext2);
+                braceStartsBlock = false;
+            } else if (isspacechar(ch)) {
+                // Color it blank, stay for another round.
+                styler.ColourTo(i, SCE_PL_DEFAULT);
+                braceStartsBlock = false;
+            } else if (ch == '$' || ch == '%' || ch == '@') {
+                // Move to default state and retry
+                styler.ColourTo(i - 1, SCE_PL_DEFAULT);
+                state = SCE_PL_DEFAULT;
+                retreatOneChar(i, chPrev, ch, chNext);
+            } else {
+                // Give up: go to default state.
+                state = SCE_PL_DEFAULT;
+                braceStartsBlock = true;
+                if (strchr(")]}", ch) && levelCurrent > 0) {
+                    levelCurrent--;
+                }
+            }
+        } else if (state == SCE_PL_POD) {
+            if (ch == '=' && isEOLChar(chPrev) && isMatch(styler, lengthDoc, i, "=cut")) {
+                i += 3;
+                styler.ColourTo(i, state);
+                state = SCE_PL_COMMENTLINE;
+                braceStartsBlock = true;
+                if (levelCurrent > 0) {
+                    levelCurrent--;
+                }
+                ch = styler.SafeGetCharAt(i);
+                chNext = styler.SafeGetCharAt(i + 1);
+            }
+
+        
+        // Continue parsing a reg exp ...
+        } else if (state == SCE_PL_REGEX || state == SCE_PL_STRING_QR) {
+            if (!Quote.Up && !isspacechar(ch)) {
+                Quote.Open(ch);
+            } else if (ch == '\\' && Quote.Up != '\\') {
+                // TODO: Is it safe to skip *every* escaped char?
+                i++;
+                ch = chNext;
+                chNext = styler.SafeGetCharAt(i + 1);
+            } else {
+                if (ch == Quote.Down /*&& chPrev != '\\'*/) {
+                    Quote.Count--;
+                    if (Quote.Count == 0) {
+                        Quote.Rep--;
+                        if (Quote.Up == Quote.Down) {
+                            Quote.Count++;
+                        }
+                    }
+                    if (!isSafeAlpha(chNext)) {
+                        if (Quote.Rep <= 0) {
+                            styler.ColourTo(i, state);
+                            state = SCE_PL_DEFAULT;
+                            preferRE = false;
+                            braceStartsBlock = true;
+                        }
+                    }
+                } else if (ch == Quote.Up /*&& chPrev != '\\'*/) {
+                    Quote.Count++;
+                } else if (!isSafeAlpha(chNext)) {
+                    if (Quote.Rep <= 0) {
+                        styler.ColourTo(i, state);
+                        state = SCE_PL_DEFAULT;
+                        preferRE = false;
+                        braceStartsBlock = true;
+                    }
+                } else if ((ch == '$' || ch == '@')
+                           && isInterpolatingString(SCE_PL_STRING, chNext)) {
+                    doInterpolateVariable(i, lengthDoc, state, ch, styler);
+                    retreatOneChar(i, chPrev, ch, chNext);
+                }
+            }
+        } else if (state == SCE_PL_REGSUBST) {
+            if (!Quote.Up && !isspacechar(ch)) {
+                Quote.Open(ch);
+            } else if (ch == '\\' && Quote.Up != '\\') {
+                // TODO: Is it safe to skip *every* escaped char?
+                i++;
+                ch = chNext;
+                chNext = styler.SafeGetCharAt(i + 1);
+            } else {
+                if (Quote.Count == 0 && Quote.Rep == 1) {
+                    /* We matched something like s(...) or tr{...}
+                    * and are looking for the next matcher characters,
+                    * which could be either bracketed ({...}) or non-bracketed
+                    * (/.../).
+                    *
+                    * Number-signs are problematic.  If they occur after
+                    * the close of the first part, treat them like
+                    * a Quote.Up char, even if they actually start comments.
+                    *
+                    * If we find an alnum, we end the regsubst, and punt.
+                    *
+                    * Eric Promislow   ericp@activestate.com  Aug 9,2000
+                    */
+                    if (isspacechar(ch)) {
+                        // Keep going
+                    }
+                    else if (ch != '_' && isSafeAlnum(ch)) {
+                        // Don't allow an underscore here
+                        styler.ColourTo(i, state);
+                        state = SCE_PL_DEFAULT;
+                        preferRE = false;
+                        braceStartsBlock = true;
+                        ch = ' ';
+                    } else {
+                        Quote.Open(ch);
+                    }
+                } else if (ch == Quote.Down /*&& chPrev != '\\'*/) {
+                    Quote.Count--;
+                    if (Quote.Count == 0) {
+                        Quote.Rep--;
+                    }
+                    if (!isSafeAlpha(chNext)) {
+                        if (Quote.Rep <= 0) {
+                            styler.ColourTo(i, state);
+                            state = SCE_PL_DEFAULT;
+                            preferRE = false;
+                            braceStartsBlock = true;
+                            ch = ' ';
+                        }
+                    }
+                    if (Quote.Up == Quote.Down) {
+                        Quote.Count++;
+                    }
+                } else if (ch == Quote.Up /*&& chPrev != '\\'*/) {
+                    Quote.Count++;
+                } else if (!isSafeAlpha(chNext)) {
+                    if (Quote.Rep <= 0) {
+                        styler.ColourTo(i, state);
+                        state = SCE_PL_DEFAULT;
+                        braceStartsBlock = true;
+                        preferRE = false;
+                        ch = ' ';
+                    }
+                } else if ((ch == '$' || ch == '@')
+                           && Quote.Rep == 2
+                           && isInterpolatingString(SCE_PL_STRING, chNext)) {
+                    doInterpolateVariable(i, lengthDoc, state, ch, styler);
+                    retreatOneChar(i, chPrev, ch, chNext);
+                }
+            }
+
+        // Quotes of all kinds...
+        } else if (state == SCE_PL_STRING_Q || state == SCE_PL_STRING_QQ || 
+                   state == SCE_PL_STRING_QX || state == SCE_PL_STRING_QW ||
+                   state == SCE_PL_STRING || state == SCE_PL_CHARACTER ||
+                   state == SCE_PL_BACKTICKS) {
+            if (!Quote.Down && !isspacechar(ch)) {
+                Quote.Open(ch);
+            } else if (ch == '\\' && Quote.Up != '\\') {
+                // TODO: Is it save to skip *every* escaped char?
+                i++;
+                ch = chNext;
+                chNext = styler.SafeGetCharAt(i + 1);
+            } else if (ch == Quote.Down) {
+                Quote.Count--;
+                if (Quote.Count == 0) {
+                    Quote.Rep--;
+                    if (Quote.Rep <= 0) {
+                        styler.ColourTo(i, state);
+                        state = SCE_PL_DEFAULT;
+                        braceStartsBlock = true;
+                    }
+                    if (Quote.Up == Quote.Down) {
+                        Quote.Count++;
+                    }
+                    preferRE = false;
+                }
+            } else if (ch == Quote.Up) {
+                Quote.Count++;
+            } else if ((ch == '$' || ch == '@')
+                       && isInterpolatingString(state, chNext)) {
+                doInterpolateVariable(i, lengthDoc, state, ch, styler);
+                retreatOneChar(i, chPrev, ch, chNext);
+            }
+
+        // Handle the beginning of a subroutine.
+        } else if (state == SCE_PL_SUB) {
+            
+            // The end of subroutine state. Switch either back to normal mode or 
+            // subroutine argument mode.
+            if (ch == '(' || ch == '{' || ch == ';') {
+                styler.ColourTo(i - 1, SCE_PL_IDENTIFIER);
+                styler.ColourTo(i, SCE_PL_OPERATOR);
+                if (ch == '(') {
+                    state = SCE_PL_SUB_ARGS;
+                    braceStartsBlock = true;
+                    levelCurrent++;
+                } else {
+                    if (ch =='{') {
+                        levelCurrent++;
+                        braceStartsBlock = false;
+                        p_BraceInfo->add(SCE_PL_OPERATOR);
+                    } else {
+                        braceStartsBlock = true;
+                    }
+                    state = SCE_PL_DEFAULT;
+                }
+
+            // Switch temporarily to COMMENTLINE state if a # is encountered.
+            } else if (ch == '#') {
+                styler.ColourTo(i - 1, SCE_PL_IDENTIFIER);
+                previousState = state;
+                state = SCE_PL_COMMENTLINE;
+                braceStartsBlock = true;
+            }
+            
+        // Handle the arguments of a subroutine.
+        } else if (state == SCE_PL_SUB_ARGS) {
+            if (ch == ')') {
+                styler.ColourTo(i - 1, SCE_PL_DEFAULT);
+                styler.ColourTo(i, SCE_PL_OPERATOR);
+                state = SCE_PL_DEFAULT;
+                if (levelCurrent > 0) {
+                    levelCurrent--;
+                }
+                braceStartsBlock = true;
+            }
+        } else if (state == SCE_PL_FORMAT) {
+            if (ch == '.' && isEOLChar(chPrev) && isEOLChar(chNext)) {
+                styler.ColourTo(i, state);
+                state = SCE_PL_DEFAULT;
+            }
+        }
+
+        if (state == SCE_PL_ERROR) {
+            break;
+        }
+        chPrev = ch;
+    }
+    if (state == SCE_PL_SUB) {
+        state = SCE_PL_IDENTIFIER;
+        braceStartsBlock = true;
+    } else if (state == SCE_PL_SUB_ARGS) {
+        state = SCE_PL_DEFAULT;
+        braceStartsBlock = true;
+    }
+    styler.ColourTo(lengthDoc - 1, state);
+
+    //Fill in the real level of the next line, keeping the current flags as they will be filled in later
+    if (fold) {
+        int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+        if (levelPrev < 0 || levelPrev >= 0x3ff) {
+            levelPrev = 0;
+        }
+        styler.SetLevel(lineCurrent, levelPrev | flagsNext | SC_FOLDLEVELBASE);
+    }
+    styler.Flush();
+    delete p_BraceInfo;
 }
 
 static void FoldPerlDoc(unsigned int startPos, int length, int, WordList *[],
                         Accessor &styler) {
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
-	// Custom folding of POD and packages
-
-	// property fold.perl.pod 
-	//	Enable folding Pod blocks when using the Perl lexer. 
-	bool foldPOD = styler.GetPropertyInt("fold.perl.pod", 1) != 0;
-
-	// property fold.perl.package 
-	//	Enable folding packages when using the Perl lexer. 
-	bool foldPackage = styler.GetPropertyInt("fold.perl.package", 1) != 0;
-
-	unsigned int endPos = startPos + length;
-	int visibleChars = 0;
-	int lineCurrent = styler.GetLine(startPos);
-	int levelPrev = SC_FOLDLEVELBASE;
-	if (lineCurrent > 0)
-		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
-	int levelCurrent = levelPrev;
-	char chNext = styler[startPos];
-	char chPrev = styler.SafeGetCharAt(startPos - 1);
-	int styleNext = styler.StyleAt(startPos);
-	// Used at end of line to determine if the line was a package definition
-	bool isPackageLine = false;
-	bool isPodHeading = false;
-	for (unsigned int i = startPos; i < endPos; i++) {
-		char ch = chNext;
-		chNext = styler.SafeGetCharAt(i + 1);
-		int style = styleNext;
-		styleNext = styler.StyleAt(i + 1);
-		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
-		bool atLineStart = ((chPrev == '\r') || (chPrev == '\n')) || i == 0;
-		// Comment folding
-		if (foldComment && atEOL && IsCommentLine(lineCurrent, styler))
-		{
-			if (!IsCommentLine(lineCurrent - 1, styler)
-				&& IsCommentLine(lineCurrent + 1, styler))
-				levelCurrent++;
-			else if (IsCommentLine(lineCurrent - 1, styler)
-					 && !IsCommentLine(lineCurrent+1, styler))
-				levelCurrent--;
-		}
-		if (style == SCE_PL_OPERATOR) {
-			if (ch == '{') {
-				levelCurrent++;
-			} else if (ch == '}') {
-				levelCurrent--;
-			}
-		}
-		// Custom POD folding
-		if (foldPOD && atLineStart) {
-			int stylePrevCh = (i) ? styler.StyleAt(i - 1):SCE_PL_DEFAULT;
-			if (style == SCE_PL_POD) {
-				if (stylePrevCh != SCE_PL_POD && stylePrevCh != SCE_PL_POD_VERB)
-					levelCurrent++;
-				else if (styler.Match(i, "=cut"))
-					levelCurrent--;
-				else if (styler.Match(i, "=head"))
-					isPodHeading = true;
-			} else if (style == SCE_PL_DATASECTION) {
-				if (ch == '=' && isalpha(chNext) && levelCurrent == SC_FOLDLEVELBASE)
-					levelCurrent++;
-				else if (styler.Match(i, "=cut") && levelCurrent > SC_FOLDLEVELBASE)
-					levelCurrent--;
-				else if (styler.Match(i, "=head"))
-					isPodHeading = true;
-				// if package used or unclosed brace, level > SC_FOLDLEVELBASE!
-				// reset needed as level test is vs. SC_FOLDLEVELBASE
-				else if (styler.Match(i, "__END__"))
-					levelCurrent = SC_FOLDLEVELBASE;
-			}
-		}
-		// Custom package folding
-		if (foldPackage && atLineStart) {
-			if (style == SCE_PL_WORD && styler.Match(i, "package")) {
-				isPackageLine = true;
-			}
-		}
-
-		if (atEOL) {
-			int lev = levelPrev;
-			if (isPodHeading) {
-				lev = levelPrev - 1;
-				lev |= SC_FOLDLEVELHEADERFLAG;
-				isPodHeading = false;
-			}
-			// Check if line was a package declaration
-			// because packages need "special" treatment
-			if (isPackageLine) {
-				lev = SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG;
-				levelCurrent = SC_FOLDLEVELBASE + 1;
-				isPackageLine = false;
-			}
-			lev |= levelCurrent << 16;
-			if (visibleChars == 0 && foldCompact)
-				lev |= SC_FOLDLEVELWHITEFLAG;
-			if ((levelCurrent > levelPrev) && (visibleChars > 0))
-				lev |= SC_FOLDLEVELHEADERFLAG;
-			if (lev != styler.LevelAt(lineCurrent)) {
-				styler.SetLevel(lineCurrent, lev);
-			}
-			lineCurrent++;
-			levelPrev = levelCurrent;
-			visibleChars = 0;
-		}
-		if (!isspacechar(ch))
-			visibleChars++;
-		chPrev = ch;
-	}
-	// Fill in the real level of the next line, keeping the current flags as they will be filled in later
-	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
-	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+    bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+    bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+    unsigned int endPos = startPos + length;
+    int state;
+    synchronizeDocStart(startPos, endPos, state, styler);
+    
+    int visibleChars = 0;
+    int lineCurrent = styler.GetLine(startPos);
+
+#if 0
+    // Synchronize: if the previous line is a POD or here doc, move up one
+    if (lineCurrent > 0) {
+        int prevLineStartPos = styler.LineStart(lineCurrent - 1);
+        if (safeStyleAt(prevLineStartPos, styler) == SCE_PL_POD) {
+            startPos = prevLineStartPos;
+            lineCurrent -= 1;
+        }
+    }
+#endif
+            
+    int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+    int levelCurrent = levelPrev;
+    int lengthDoc = styler.Length();
+    char chNext = styler[startPos];
+    int styleNext = safeStyleAt(startPos, styler);
+    for (unsigned int i = startPos; i < endPos; i++) {
+        char ch = chNext;
+        chNext = styler.SafeGetCharAt(i + 1);
+        int style = styleNext;
+        styleNext = safeStyleAt(i + 1, styler);
+        bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+        if (foldComment && (style == SCE_PL_COMMENTLINE)) {
+            if ((ch == '/') && (chNext == '/')) {
+                char chNext2 = styler.SafeGetCharAt(i + 2);
+                if (chNext2 == '{') {
+                    levelCurrent++;
+                } else if (levelCurrent > 0 && chNext2 == '}') {
+                    levelCurrent--;
+                }
+            }
+        } else if (style == SCE_PL_OPERATOR || style == SCE_PL_VARIABLE_INDEXER) {
+            if (strchr("{[(", ch)) {
+                levelCurrent++;
+            } else if (levelCurrent > 0 && strchr(")]}", ch)) {
+                levelCurrent--;
+            }
+        } else if (style == SCE_PL_POD && ch == '=') {
+            // Check the previous line
+            if (lineCurrent == 0
+                || safeStyleAt(styler.LineStart(lineCurrent - 1), styler) != SCE_PL_POD) {
+                levelCurrent++;
+            } else if (levelCurrent > 0) {
+                int nextLinePos = styler.LineStart(lineCurrent + 1);
+                if (nextLinePos < lengthDoc
+                    && safeStyleAt(nextLinePos, styler) != SCE_PL_POD) {
+                    levelCurrent--;
+                }
+            }
+        }
+        if (atEOL) {
+            int lev = levelPrev;
+            if (visibleChars == 0 && foldCompact)
+                lev |= SC_FOLDLEVELWHITEFLAG;
+            if ((levelCurrent > levelPrev) && (visibleChars > 0))
+                lev |= SC_FOLDLEVELHEADERFLAG;
+            if (lev != styler.LevelAt(lineCurrent)) {
+                styler.SetLevel(lineCurrent, lev);
+            }
+            lineCurrent++;
+            levelPrev = levelCurrent;
+            visibleChars = 0;
+        }
+        if (!isspacechar(ch))
+            visibleChars++;
+    }
+    // Fill in the real level of the next line, keeping the current flags as they will be filled in later
+    int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+    styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+    styler.Flush();
 }
 
 static const char * const perlWordListDesc[] = {
-	"Keywords",
-	0
+    "Keywords",
+    0
 };
 
-LexerModule lmPerl(SCLEX_PERL, ColourisePerlDoc, "perl", FoldPerlDoc, perlWordListDesc, 8);
+LexerModule lmPerl(SCLEX_PERL, ColourisePerlDoc, "perl", FoldPerlDoc, perlWordListDesc);
diff -ruN scintilla.orig/src/LexRuby.cxx scintilla/src/LexRuby.cxx
--- scintilla.orig/src/LexRuby.cxx	2008-12-23 17:52:01.000000000 -0600
+++ scintilla/src/LexRuby.cxx	2011-02-11 10:17:02.000000000 -0600
@@ -25,7 +25,7 @@
 
 //XXX Identical to Perl, put in common area
 static inline bool isEOLChar(char ch) {
-	return (ch == '\r') || (ch == '\n');
+    return (ch == '\r') || (ch == '\n');
 }
 
 #define isSafeASCII(ch) ((unsigned int)(ch) <= 127)
@@ -56,7 +56,7 @@
 }
 
 static bool inline iswhitespace(char ch) {
-	return ch == ' ' || ch == '\t';
+    return ch == ' ' || ch == '\t';
 }
 
 #define MAX_KEYWORD_LENGTH 200
@@ -97,27 +97,35 @@
                               int pos,
                               Accessor &styler);
 
-static int ClassifyWordRb(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler, char *prevWord) {
-	char s[MAX_KEYWORD_LENGTH];
+static char* getCurrentWord(unsigned int start, unsigned int end, Accessor &styler) {
+    static char s[MAX_KEYWORD_LENGTH];
+    unsigned int lim = end - start + 1; // num chars to copy
+    if (lim >= MAX_KEYWORD_LENGTH) {
+        s[0] = 0;
+        return s;
+    }
     unsigned int i, j;
-	unsigned int lim = end - start + 1; // num chars to copy
-	if (lim >= MAX_KEYWORD_LENGTH) {
-		lim = MAX_KEYWORD_LENGTH - 1;
-	}
-	for (i = start, j = 0; j < lim; i++, j++) {
-		s[j] = styler[i];
-	}
+    for (i = start, j = 0; j < lim; i++, j++) {
+        s[j] = styler[i];
+    }
     s[j] = '\0';
-	int chAttr;
-	if (0 == strcmp(prevWord, "class"))
-		chAttr = SCE_RB_CLASSNAME;
-	else if (0 == strcmp(prevWord, "module"))
-		chAttr = SCE_RB_MODULE_NAME;
-	else if (0 == strcmp(prevWord, "def"))
-		chAttr = SCE_RB_DEFNAME;
-    else if (keywords.InList(s) && !followsDot(start - 1, styler)) {
-        if (keywordIsAmbiguous(s)
-            && keywordIsModifier(s, start, styler)) {
+    return s;
+}
+
+static int ClassifyWordRb(unsigned int start, unsigned int end, WordList &keywords, Accessor &styler, char *currWord, char *prevWord) {
+    int chAttr;
+    if (!currWord) {
+        return SCE_RB_IDENTIFIER;
+    }
+    if (0 == strcmp(prevWord, "class"))
+        chAttr = SCE_RB_CLASSNAME;
+    else if (0 == strcmp(prevWord, "module"))
+        chAttr = SCE_RB_MODULE_NAME;
+    else if (0 == strcmp(prevWord, "def"))
+        chAttr = SCE_RB_DEFNAME;
+    else if (keywords.InList(currWord) && !followsDot(start - 1, styler)) {
+        if (keywordIsAmbiguous(currWord)
+            && keywordIsModifier(currWord, start, styler)) {
             
             // Demoted keywords are colored as keywords,
             // but do not affect changes in indentation.
@@ -132,39 +140,39 @@
         } else {
             chAttr = SCE_RB_WORD;
         }
-	} else
-        chAttr = SCE_RB_IDENTIFIER;
-	styler.ColourTo(end, chAttr);
-	if (chAttr == SCE_RB_WORD) {
-		strcpy(prevWord, s);
-	} else {
-		prevWord[0] = 0;
-	}
+    } else
+    chAttr = SCE_RB_IDENTIFIER;
+    styler.ColourTo(end, chAttr);
+    if (chAttr == SCE_RB_WORD) {
+        strcpy(prevWord, currWord);
+    } else {
+        prevWord[0] = 0;
+    }
     return chAttr;
 }
 
 
 //XXX Identical to Perl, put in common area
 static bool isMatch(Accessor &styler, int lengthDoc, int pos, const char *val) {
-	if ((pos + static_cast<int>(strlen(val))) >= lengthDoc) {
-		return false;
-	}
-	while (*val) {
-		if (*val != styler[pos++]) {
-			return false;
-		}
-		val++;
-	}
-	return true;
+    if ((pos + static_cast<int>(strlen(val))) >= lengthDoc) {
+        return false;
+    }
+    while (*val) {
+        if (*val != styler[pos++]) {
+            return false;
+        }
+        val++;
+    }
+    return true;
 }
 
 // Do Ruby better -- find the end of the line, work back,
 // and then check for leading white space
 
 // Precondition: the here-doc target can be indented
-static bool lookingAtHereDocDelim(Accessor	   &styler,
-                                  int 			pos,
-                                  int 			lengthDoc,
+static bool lookingAtHereDocDelim(Accessor     &styler,
+                                  int           pos,
+                                  int           lengthDoc,
                                   const char   *HereDocDelim)
 {
     if (!isMatch(styler, lengthDoc, pos, HereDocDelim)) {
@@ -183,15 +191,15 @@
 
 //XXX Identical to Perl, put in common area
 static char opposite(char ch) {
-	if (ch == '(')
-		return ')';
-	if (ch == '[')
-		return ']';
-	if (ch == '{')
-		return '}';
-	if (ch == '<')
-		return '>';
-	return ch;
+    if (ch == '(')
+        return ')';
+    if (ch == '[')
+        return ']';
+    if (ch == '{')
+        return '}';
+    if (ch == '<')
+        return '>';
+    return ch;
 }
 
 // Null transitions when we see we've reached the end
@@ -274,7 +282,7 @@
             Up    = q.Up;
             Down  = q.Down;
         }
-		return *this;
+        return *this;
     }
             
 };
@@ -312,12 +320,30 @@
 
 static bool isEmptyLine(int pos,
                         Accessor &styler) {
-	int spaceFlags = 0;
-	int lineCurrent = styler.GetLine(pos);
-	int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
+    int spaceFlags = 0;
+    int lineCurrent = styler.GetLine(pos);
+    int indentCurrent = styler.IndentAmount(lineCurrent, &spaceFlags, NULL);
     return (indentCurrent & SC_FOLDLEVELWHITEFLAG) != 0;
 }
 
+static bool RE_CanFollowIdentifier(const char *keyword) {
+// Members of Kernel that can precede strings or REs:
+    if (!strcmp(keyword, "eval")
+        || !strcmp(keyword, "exec")
+        || !strcmp(keyword, "open")
+        || !strcmp(keyword, "p")
+        || !strcmp(keyword, "print")
+        || !strcmp(keyword, "printf")
+        || !strcmp(keyword, "puts")
+        || !strcmp(keyword, "require")
+        || !strcmp(keyword, "split")
+        || !strcmp(keyword, "sprintf")
+        || !strcmp(keyword, "system")) {
+        return true;
+    }
+    return false;
+}
+
 static bool RE_CanFollowKeyword(const char *keyword) {
     if (!strcmp(keyword, "and")
         || !strcmp(keyword, "begin")
@@ -374,8 +400,8 @@
     int firstWordPosn = skipWhitespace(lineStartPosn, iPrev, styler);
     if (firstWordPosn >= iPrev) {
         // Have something like {^     <<}
-		//XXX Look at the first previous non-comment non-white line
-		// to establish the context.  Not too likely though.
+        //XXX Look at the first previous non-comment non-white line
+        // to establish the context.  Not too likely though.
         return true;
     } else {
         switch (prevStyle = styler.StyleAt(firstWordPosn)) {
@@ -499,7 +525,7 @@
         return definitely_not_a_here_doc;
     }
     // OK, now 'j' will point to the current spot moving ahead
-	int j = firstWordPosn + 1;
+    int j = firstWordPosn + 1;
     if (styler.StyleAt(j) != SCE_RB_OPERATOR || styler[j] != '<') {
         // This shouldn't happen
         return definitely_not_a_here_doc;
@@ -551,10 +577,10 @@
             // don't handle arbitrary expressions yet
             
             target_end = j;
-			if (target_quote) {
-				// Now we can move to the character after the string delimiter.
-				j += 1;
-			}
+            if (target_quote) {
+                // Now we can move to the character after the string delimiter.
+                j += 1;
+            }
             j = skipWhitespace(j, lengthDoc, styler);
             if (j >= lengthDoc) {
                 return definitely_not_a_here_doc;
@@ -595,110 +621,127 @@
 // move to the start of the first line that is not in a 
 // multi-line construct
 
+// KOMODO -- interactive shell colorizing
+static bool isStdioChar(int style) {
+    switch (style) {
+    case SCE_RB_STDIN:
+    case SCE_RB_STDOUT:
+    case SCE_RB_STDERR:
+        return true;
+    }
+    return false;
+}
+    
+
+// KOMODO -- interactive shell colorizing
+static int prevNonNewlinePos(int line,
+                             Accessor &styler) {
+    if (line <= 0) return -1;
+    int lineStart = styler.LineStart(line);
+    if (lineStart == 0) return -1;
+    // Move to the previous line
+    int pos = lineStart - 1;
+    char ch = styler.SafeGetCharAt(pos);
+    while (pos > 0 && (ch == '\n' || ch == '\r')) {
+        ch = styler.SafeGetCharAt(--pos);
+    }
+    return pos;
+}
+
 static void synchronizeDocStart(unsigned int& startPos,
                                 int &length,
                                 int &initStyle,
-                                Accessor &styler,
-                                bool skipWhiteSpace=false) {
+                                Accessor &styler) {
 
     styler.Flush();
-    int style = actual_style(styler.StyleAt(startPos));
-    switch (style) {
-        case SCE_RB_STDIN:
-        case SCE_RB_STDOUT:
-        case SCE_RB_STDERR:
-            // Don't do anything else with these.
-            return;
-    }
-    
+    int style;
     int pos = startPos;
     // Quick way to characterize each line
-    int lineStart;
-    for (lineStart = styler.GetLine(pos); lineStart > 0; lineStart--) {
+    int currLine = styler.GetLine(pos);
+    while (currLine > 0) {
         // Now look at the style before the previous line's EOL
-        pos = styler.LineStart(lineStart) - 1;
-        if (pos <= 10) {
-            lineStart = 0;
+        // KOMODO -- interactive shell colorizing
+        pos = prevNonNewlinePos(currLine, styler);
+        if (pos == -1) {
+            currLine = 0;
             break;
         }
-        char ch = styler.SafeGetCharAt(pos);
-        char chPrev = styler.SafeGetCharAt(pos - 1);
-        if (ch == '\n' && chPrev == '\r') {
-            pos--;
-        }
-        if (styler.SafeGetCharAt(pos - 1) == '\\') {
+        style = actual_style(styler.StyleAt(pos));
+        if (isStdioChar(style)) {
+            break;
+        } else if (styler.SafeGetCharAt(pos) == '\\') {
             // Continuation line -- keep going
-        } else if (actual_style(styler.StyleAt(pos)) != SCE_RB_DEFAULT) {
+        } else if (actual_style(styler.StyleAt(pos + 1)) != SCE_RB_DEFAULT) {
             // Part of multi-line construct -- keep going
         } else if (currLineContainsHereDelims(pos, styler)) {
             // Keep going, with pos and length now pointing
             // at the end of the here-doc delimiter
-        } else if (skipWhiteSpace && isEmptyLine(pos, styler)) {
-            // Keep going
         } else {
             break;
         }
+        currLine = styler.GetLine(pos);
     }
-    pos = styler.LineStart(lineStart);
+    pos = styler.LineStart(currLine);
     length += (startPos - pos);
     startPos = pos;
     initStyle = SCE_RB_DEFAULT;
 }
 
 static void ColouriseRbDoc(unsigned int startPos, int length, int initStyle,
-						   WordList *keywordlists[], Accessor &styler) {
+                           WordList *keywordlists[], Accessor &styler) {
 
-	// Lexer for Ruby often has to backtrack to start of current style to determine
-	// which characters are being used as quotes, how deeply nested is the
-	// start position and what the termination string is for here documents
+    // Lexer for Ruby often has to backtrack to start of current style to determine
+    // which characters are being used as quotes, how deeply nested is the
+    // start position and what the termination string is for here documents
     
-	WordList &keywords = *keywordlists[0];
+    WordList &keywords = *keywordlists[0];
 
-	class HereDocCls {
-	public:
-		int State;
+    class HereDocCls {
+    public:
+        int State;
         // States
         // 0: '<<' encountered
-		// 1: collect the delimiter
+        // 1: collect the delimiter
         // 1b: text between the end of the delimiter and the EOL
-		// 2: here doc text (lines after the delimiter)
-		char Quote;		// the char after '<<'
-		bool Quoted;		// true if Quote in ('\'','"','`')
-		int DelimiterLength;	// strlen(Delimiter)
-		char Delimiter[256];	// the Delimiter, limit of 256: from Perl
+        // 2: here doc text (lines after the delimiter)
+        char Quote;     // the char after '<<'
+        bool Quoted;        // true if Quote in ('\'','"','`')
+        int DelimiterLength;    // strlen(Delimiter)
+        char Delimiter[256];    // the Delimiter, limit of 256: from Perl
         bool CanBeIndented;
-		HereDocCls() {
-			State = 0;
-			DelimiterLength = 0;
-			Delimiter[0] = '\0';
+        HereDocCls() {
+            State = 0;
+            DelimiterLength = 0;
+            Delimiter[0] = '\0';
             CanBeIndented = false;
-		}
-	};
-	HereDocCls HereDoc;	
+        }
+    };
+    HereDocCls HereDoc; 
 
-	QuoteCls Quote;
+    QuoteCls Quote;
 
     int numDots = 0;  // For numbers --
                       // Don't start lexing in the middle of a num
+    int num_e_s = 0;  // Also for floating-point numbers
 
-    synchronizeDocStart(startPos, length, initStyle, styler, // ref args
-                        false);
+    synchronizeDocStart(startPos, length, initStyle, styler // ref args
+                        );
 
-	bool preferRE = true;
+    bool preferRE = true;
     int state = initStyle;
-	int lengthDoc = startPos + length;
+    int lengthDoc = startPos + length;
 
-	char prevWord[MAX_KEYWORD_LENGTH + 1]; // 1 byte for zero
-	prevWord[0] = '\0';
-	if (length == 0)
-		return;
-
-	char chPrev = styler.SafeGetCharAt(startPos - 1);
-	char chNext = styler.SafeGetCharAt(startPos);
-	bool is_real_number = true;   // Differentiate between constants and ?-sequences.
-	// Ruby uses a different mask because bad indentation is marked by oring with 32
-	styler.StartAt(startPos, 127);
-	styler.StartSegment(startPos);
+    char prevWord[MAX_KEYWORD_LENGTH + 1]; // 1 byte for zero
+    prevWord[0] = '\0';
+    if (length == 0)
+        return;
+
+    char chPrev = styler.SafeGetCharAt(startPos - 1);
+    char chNext = styler.SafeGetCharAt(startPos);
+    bool is_real_number = true;   // Differentiate between constants and ?-sequences.
+    // Ruby uses a different mask because bad indentation is marked by oring with 32
+    styler.StartAt(startPos, 127);
+    styler.StartSegment(startPos);
 
     static int q_states[] = {SCE_RB_STRING_Q,
                              SCE_RB_STRING_QQ,
@@ -735,55 +778,56 @@
     int brace_counts = 0;   // Number of #{ ... } things within an expression
 
     int i;
-	for (i = 0; i < INNER_STRINGS_MAX_COUNT; i++) {
+    for (i = 0; i < INNER_STRINGS_MAX_COUNT; i++) {
         inner_string_types[i] = 0;
         inner_expn_brace_counts[i] = 0;
     }
-	for (i = startPos; i < lengthDoc; i++) {
-		char ch = chNext;
-		chNext = styler.SafeGetCharAt(i + 1);
-		char chNext2 = styler.SafeGetCharAt(i + 2);
+    for (i = startPos; i < lengthDoc; i++) {
+        char ch = chNext;
+        chNext = styler.SafeGetCharAt(i + 1);
+        char chNext2 = styler.SafeGetCharAt(i + 2);
 
         if (styler.IsLeadByte(ch)) {
-			chNext = chNext2;
-			chPrev = ' ';
-			i += 1;
-			continue;
-		}
-		
+            chNext = chNext2;
+            chPrev = ' ';
+            i += 1;
+            continue;
+        }
+        
         // skip on DOS/Windows
         //No, don't, because some things will get tagged on,
         // so we won't recognize keywords, for example
 #if 0
-		if (ch == '\r' && chNext == '\n') {
-	    	continue;
+        if (ch == '\r' && chNext == '\n') {
+            continue;
         }
 #endif
             
         if (HereDoc.State == 1 && isEOLChar(ch)) {
-			// Begin of here-doc (the line after the here-doc delimiter):
-			HereDoc.State = 2;
-			styler.ColourTo(i-1, state);
+            // Begin of here-doc (the line after the here-doc delimiter):
+            HereDoc.State = 2;
+            styler.ColourTo(i-1, state);
             // Don't check for a missing quote, just jump into
             // the here-doc state
             state = SCE_RB_HERE_Q;
         }
 
         // Regular transitions
-		if (state == SCE_RB_DEFAULT) {
+        if (state == SCE_RB_DEFAULT) {
             if (isSafeDigit(ch)) {
-            	styler.ColourTo(i - 1, state);
-				state = SCE_RB_NUMBER;
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_NUMBER;
                 is_real_number = true;
                 numDots = 0;
+                num_e_s = 0; // For the exponent part in a float constant
             } else if (isHighBitChar(ch) || iswordstart(ch)) {
-            	styler.ColourTo(i - 1, state);
-				state = SCE_RB_WORD;
-			} else if (ch == '#') {
-				styler.ColourTo(i - 1, state);
-				state = SCE_RB_COMMENTLINE;
-			} else if (ch == '=') {
-				// =begin indicates the start of a comment (doc) block
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_WORD;
+            } else if (ch == '#') {
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_COMMENTLINE;
+            } else if (ch == '=') {
+                // =begin indicates the start of a comment (doc) block
                 if (i == 0 || (isEOLChar(chPrev)
                     && chNext == 'b'
                     && styler.SafeGetCharAt(i + 2) == 'e'
@@ -793,53 +837,53 @@
                     && !isSafeWordcharOrHigh(styler.SafeGetCharAt(i + 6)))) {
                     styler.ColourTo(i - 1, state);
                     state = SCE_RB_POD;
-				} else {
-					styler.ColourTo(i - 1, state);
-					styler.ColourTo(i, SCE_RB_OPERATOR);
-					preferRE = true;
-				}
-			} else if (ch == '"') {
-				styler.ColourTo(i - 1, state);
-				state = SCE_RB_STRING;
-				Quote.New();
-				Quote.Open(ch);
-			} else if (ch == '\'') {
+                } else {
+                    styler.ColourTo(i - 1, state);
+                    styler.ColourTo(i, SCE_RB_OPERATOR);
+                    preferRE = true;
+                }
+            } else if (ch == '"') {
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_STRING;
+                Quote.New();
+                Quote.Open(ch);
+            } else if (ch == '\'') {
                 styler.ColourTo(i - 1, state);
                 state = SCE_RB_CHARACTER;
                 Quote.New();
                 Quote.Open(ch);
-			} else if (ch == '`') {
-				styler.ColourTo(i - 1, state);
-				state = SCE_RB_BACKTICKS;
-				Quote.New();
-				Quote.Open(ch);
-			} else if (ch == '@') {
+            } else if (ch == '`') {
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_BACKTICKS;
+                Quote.New();
+                Quote.Open(ch);
+            } else if (ch == '@') {
                 // Instance or class var
-				styler.ColourTo(i - 1, state);
+                styler.ColourTo(i - 1, state);
                 if (chNext == '@') {
                     state = SCE_RB_CLASS_VAR;
                     advance_char(i, ch, chNext, chNext2); // pass by ref
                 } else {
                     state = SCE_RB_INSTANCE_VAR;
                 }
-			} else if (ch == '$') {
+            } else if (ch == '$') {
                 // Check for a builtin global
-				styler.ColourTo(i - 1, state);
+                styler.ColourTo(i - 1, state);
                 // Recognize it bit by bit
                 state = SCE_RB_GLOBAL;
             } else if (ch == '/' && preferRE) {
                 // Ambigous operator
-				styler.ColourTo(i - 1, state);
-				state = SCE_RB_REGEX;
+                styler.ColourTo(i - 1, state);
+                state = SCE_RB_REGEX;
                 Quote.New();
                 Quote.Open(ch);
-			} else if (ch == '<' && chNext == '<' && chNext2 != '=') {
+            } else if (ch == '<' && chNext == '<' && chNext2 != '=') {
 
                 // Recognise the '<<' symbol - either a here document or a binary op
-				styler.ColourTo(i - 1, state);
+                styler.ColourTo(i - 1, state);
                 i++;
                 chNext = chNext2;
-				styler.ColourTo(i, SCE_RB_OPERATOR);
+                styler.ColourTo(i, SCE_RB_OPERATOR);
 
                 if (! (strchr("\"\'`_-", chNext2) || isSafeAlpha(chNext2))) {
                     // It's definitely not a here-doc,
@@ -865,15 +909,15 @@
                 }
                 preferRE = (state != SCE_RB_HERE_DELIM);
             } else if (ch == ':') {
-				styler.ColourTo(i - 1, state);
+                styler.ColourTo(i - 1, state);
                 if (chNext == ':') {
                     // Mark "::" as an operator, not symbol start
                     styler.ColourTo(i + 1, SCE_RB_OPERATOR);
                     advance_char(i, ch, chNext, chNext2); // pass by ref
                     state = SCE_RB_DEFAULT;
-					preferRE = false;
+                    preferRE = false;
                 } else if (isSafeWordcharOrHigh(chNext)) {
-					state = SCE_RB_SYMBOL;
+                    state = SCE_RB_SYMBOL;
                 } else if (strchr("[*!~+-*/%=<>&^|", chNext)) {
                     // Do the operator analysis in-line, looking ahead
                     // Based on the table in pickaxe 2nd ed., page 339
@@ -946,11 +990,15 @@
                         styler.ColourTo(i, SCE_RB_SYMBOL);
                         state = SCE_RB_DEFAULT;
                     }
-				} else if (!preferRE) {
-					// Don't color symbol strings (yet)
-					// Just color the ":" and color rest as string
-					styler.ColourTo(i, SCE_RB_SYMBOL);
-					state = SCE_RB_DEFAULT;
+                } else if (strchr(" \t\r\n", chNext)) {
+                    styler.ColourTo(i, SCE_RB_OPERATOR);
+                    state = SCE_RB_DEFAULT;
+                    preferRE = true;
+                } else if (!preferRE) {
+                    // Don't color symbol strings (yet)
+                    // Just color the ":" and color rest as string
+                    styler.ColourTo(i, SCE_RB_SYMBOL);
+                    state = SCE_RB_DEFAULT;
                 } else {
                     styler.ColourTo(i, SCE_RB_OPERATOR);
                     state = SCE_RB_DEFAULT;
@@ -967,7 +1015,7 @@
                         Quote.Open(chNext2);
                         i += 2;
                         ch = chNext2;
-						chNext = styler.SafeGetCharAt(i + 1);
+            chNext = styler.SafeGetCharAt(i + 1);
                         have_string = true;
                     }
                 } else if (preferRE && !isSafeWordcharOrHigh(chNext)) {
@@ -994,8 +1042,8 @@
                     is_real_number = false;
                 }
             } else if (isoperator(ch) || ch == '.') {
-				styler.ColourTo(i - 1, state);
-				styler.ColourTo(i, SCE_RB_OPERATOR);
+                styler.ColourTo(i - 1, state);
+                styler.ColourTo(i, SCE_RB_OPERATOR);
                 // If we're ending an expression or block,
                 // assume it ends an object, and the ambivalent
                 // constructs are binary operators
@@ -1060,26 +1108,24 @@
                     // No need to handle this state -- we'll just move to the end
                     preferRE = false;
                 } else {
-					int wordStartPos = styler.GetStartSegment();
-                    int word_style = ClassifyWordRb(wordStartPos, i - 1, keywords, styler, prevWord);
+                    int wordStartPos = styler.GetStartSegment();
+                    char *currWord = getCurrentWord(wordStartPos, i - 1, styler);
+                    int word_style = ClassifyWordRb(wordStartPos, i - 1, keywords, styler, currWord, prevWord);
                     switch (word_style) {
                         case SCE_RB_WORD:
-                            preferRE = RE_CanFollowKeyword(prevWord);
-							break;
+                            preferRE = RE_CanFollowKeyword(currWord);
+                            break;
                             
                         case SCE_RB_WORD_DEMOTED:
                             preferRE = true;
-							break;
+                            break;
                             
                         case SCE_RB_IDENTIFIER:
-                            if (isMatch(styler, lengthDoc, wordStartPos, "print")) {
-                                preferRE = true;
-                            } else if (isEOLChar(ch)) {
+                            preferRE = RE_CanFollowIdentifier(currWord);
+                            if (!preferRE && isEOLChar(ch)) {
                                 preferRE = true;
-                            } else {
-                                preferRE = false;
                             }
-							break;
+                            break;
                         default:
                             preferRE = false;
                     }
@@ -1122,6 +1168,11 @@
                     preferRE = false;
                     advance_char(i, ch, chNext, chNext2);
                 }
+            } else if (((ch == 'e' || ch == 'E') && ++num_e_s == 1)
+                       && (chNext == '+' || chNext == '-'
+                           || isSafeDigit(chNext))) {
+                advance_char(i, ch, chNext, chNext2); // pass by ref
+                // Can't end a number with a bare 'E', so do more checking.
             } else if (isSafeAlnumOrHigh(ch) || ch == '_') {
                 // Keep going
             } else if (ch == '.' && ++numDots == 1) {
@@ -1132,7 +1183,7 @@
                 preferRE = false;
             }
         } else if (state == SCE_RB_COMMENTLINE) {
-			if (isEOLChar(ch)) {
+            if (isEOLChar(ch)) {
                 styler.ColourTo(i - 1, state);
                 state = SCE_RB_DEFAULT;
                 // Use whatever setting we had going into the comment
@@ -1142,8 +1193,8 @@
             // Slightly different: if we find an immediate '-',
             // the target can appear indented.
             
-			if (HereDoc.State == 0) { // '<<' encountered
-				HereDoc.State = 1;
+            if (HereDoc.State == 0) { // '<<' encountered
+                HereDoc.State = 1;
                 HereDoc.DelimiterLength = 0;
                 if (ch == '-') {
                     HereDoc.CanBeIndented = true;
@@ -1168,7 +1219,7 @@
                         HereDoc.DelimiterLength = 1;
                     }
                 }
-			} else if (HereDoc.State == 1) { // collect the delimiter
+            } else if (HereDoc.State == 1) { // collect the delimiter
                 if (isEOLChar(ch)) {
                     // End the quote now, and go back for more
                     styler.ColourTo(i - 1, state);
@@ -1178,32 +1229,32 @@
                     chNext2 = chNext;
                     preferRE = false;
                 } else if (HereDoc.Quoted) {
-					if (ch == HereDoc.Quote) { // closing quote => end of delimiter
-						styler.ColourTo(i, state);
-						state = SCE_RB_DEFAULT;
+                    if (ch == HereDoc.Quote) { // closing quote => end of delimiter
+                        styler.ColourTo(i, state);
+                        state = SCE_RB_DEFAULT;
                         preferRE = false;
                     } else {
-						if (ch == '\\' && !isEOLChar(chNext)) {
+                        if (ch == '\\' && !isEOLChar(chNext)) {
                             advance_char(i, ch, chNext, chNext2);
-						}
-						HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
-						HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                        }
+                        HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+                        HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
                     }
                 } else { // an unquoted here-doc delimiter
-					if (isSafeAlnumOrHigh(ch) || ch == '_') {
-						HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
-						HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
-					} else {
-						styler.ColourTo(i - 1, state);
+                    if (isSafeAlnumOrHigh(ch) || ch == '_') {
+                        HereDoc.Delimiter[HereDoc.DelimiterLength++] = ch;
+                        HereDoc.Delimiter[HereDoc.DelimiterLength] = '\0';
+                    } else {
+                        styler.ColourTo(i - 1, state);
                         redo_char(i, ch, chNext, chNext2, state);
                         preferRE = false;
-					}
+                    }
                 }
-				if (HereDoc.DelimiterLength >= static_cast<int>(sizeof(HereDoc.Delimiter)) - 1) {
-					styler.ColourTo(i - 1, state);
-					state = SCE_RB_ERROR;
+                if (HereDoc.DelimiterLength >= static_cast<int>(sizeof(HereDoc.Delimiter)) - 1) {
+                    styler.ColourTo(i - 1, state);
+                    state = SCE_RB_ERROR;
                     preferRE = false;
-				}
+                }
             }
         } else if (state == SCE_RB_HERE_Q) {
             // Not needed: HereDoc.State == 2
@@ -1238,13 +1289,23 @@
                 HereDoc.State = 0;
             }
         } else if (state == SCE_RB_CLASS_VAR
-                   || state == SCE_RB_INSTANCE_VAR
-                   || state == SCE_RB_SYMBOL) {
+                   || state == SCE_RB_INSTANCE_VAR) {
             if (!isSafeWordcharOrHigh(ch)) {
                 styler.ColourTo(i - 1, state);
                 redo_char(i, ch, chNext, chNext2, state); // pass by ref
                 preferRE = false;
             }
+        } else if (state == SCE_RB_SYMBOL) {
+            if (!isSafeWordcharOrHigh(ch)) {
+                if (ch == '!' || ch == '?' || ch == '=') {
+                    styler.ColourTo(i, state);
+                    state = SCE_RB_DEFAULT;
+                } else {
+                    styler.ColourTo(i - 1, state);
+                    redo_char(i, ch, chNext, chNext2, state); // pass by ref
+                }
+                preferRE = false;
+            }
         } else if (state == SCE_RB_GLOBAL) {
             if (!isSafeWordcharOrHigh(ch)) {
                 // handle special globals here as well
@@ -1281,7 +1342,7 @@
                     // Include the options
                     while (isSafeAlpha(chNext)) {
                         i++;
-						ch = chNext;
+                        ch = chNext;
                         chNext = styler.SafeGetCharAt(i + 1);
                     }
                     styler.ColourTo(i, state);
@@ -1382,7 +1443,9 @@
     if (state == SCE_RB_WORD) {
         // We've ended on a word, possibly at EOF, and need to
         // classify it.
-        (void) ClassifyWordRb(styler.GetStartSegment(), lengthDoc - 1, keywords, styler, prevWord);
+        int wordStartPos = styler.GetStartSegment();
+        char *currWord = getCurrentWord(wordStartPos, lengthDoc - 1, styler);
+        (void) ClassifyWordRb(wordStartPos, lengthDoc - 1, keywords, styler, currWord, prevWord);
     } else {
         styler.ColourTo(lengthDoc - 1, state);
     }
@@ -1410,7 +1473,7 @@
     for (; i <= pos; i++) {
         *dst++ = styler[i];
     }
-	*dst = 0;
+    *dst = 0;
 }
 
 static bool keywordIsAmbiguous(const char *prevWord)
@@ -1441,23 +1504,23 @@
     }
     char ch;
     int style = SCE_RB_DEFAULT;
-	int lineStart = styler.GetLine(pos);
+    int lineStart = styler.GetLine(pos);
     int lineStartPosn = styler.LineStart(lineStart);
     styler.Flush();
     while (--pos >= lineStartPosn) {
         style = actual_style(styler.StyleAt(pos));
-		if (style == SCE_RB_DEFAULT) {
-			if (iswhitespace(ch = styler[pos])) {
-				//continue
-			} else if (ch == '\r' || ch == '\n') {
-				// Scintilla's LineStart() and GetLine() routines aren't
-				// platform-independent, so if we have text prepared with
-				// a different system we can't rely on it.
-				return false;
-			}
-		} else {
+        if (style == SCE_RB_DEFAULT) {
+            if (iswhitespace(ch = styler[pos])) {
+                //continue
+            } else if (ch == '\r' || ch == '\n') {
+                // Scintilla's LineStart() and GetLine() routines aren't
+                // platform-independent, so if we have text prepared with
+                // a different system we can't rely on it.
+                return false;
+            }
+        } else {
             break;
-		}
+        }
     }
     if (pos < lineStartPosn) {
         return false; //XXX not quite right if the prev line is a continuation
@@ -1504,6 +1567,7 @@
 
 #define WHILE_BACKWARDS "elihw"
 #define UNTIL_BACKWARDS "litnu"
+#define FOR_BACKWARDS "rof"
 
 // Nothing fancy -- look to see if we follow a while/until somewhere
 // on the current line
@@ -1513,19 +1577,19 @@
 {
     char ch;
     int style;
-	int lineStart = styler.GetLine(pos);
+    int lineStart = styler.GetLine(pos);
     int lineStartPosn = styler.LineStart(lineStart);
     styler.Flush();
     while (--pos >= lineStartPosn) {
         style = actual_style(styler.StyleAt(pos));
-		if (style == SCE_RB_DEFAULT) {
-			if ((ch = styler[pos]) == '\r' || ch == '\n') {
-				// Scintilla's LineStart() and GetLine() routines aren't
-				// platform-independent, so if we have text prepared with
-				// a different system we can't rely on it.
-				return false;
-			}
-		} else if (style == SCE_RB_WORD) {
+        if (style == SCE_RB_DEFAULT) {
+            if ((ch = styler[pos]) == '\r' || ch == '\n') {
+                // Scintilla's LineStart() and GetLine() routines aren't
+                // platform-independent, so if we have text prepared with
+                // a different system we can't rely on it.
+                return false;
+            }
+        } else if (style == SCE_RB_WORD) {
             // Check for while or until, but write the word in backwards
             char prevWord[MAX_KEYWORD_LENGTH + 1]; // 1 byte for zero
             char *dst = prevWord;
@@ -1541,7 +1605,8 @@
             *dst = 0;
             // Did we see our keyword?
             if (!strcmp(prevWord, WHILE_BACKWARDS)
-                || !strcmp(prevWord, UNTIL_BACKWARDS)) {
+                || !strcmp(prevWord, UNTIL_BACKWARDS)
+                || !strcmp(prevWord, FOR_BACKWARDS)) {
                 return true;
             }
             // We can move pos to the beginning of the keyword, and then
@@ -1554,6 +1619,8 @@
             //      <- loop decrement
             //     ^  # pointing to end of word1 is fine
             pos = start_word;
+        } else if (style == SCE_RB_OPERATOR && styler[pos] == ';') {
+            return false;
         }
     }
     return false;
@@ -1615,44 +1682,44 @@
 
 static void FoldRbDoc(unsigned int startPos, int length, int initStyle,
                       WordList *[], Accessor &styler) {
-	const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+    const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+    bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
     
-    synchronizeDocStart(startPos, length, initStyle, styler, // ref args
-                        false);
-	unsigned int endPos = startPos + length;
-	int visibleChars = 0;
-	int lineCurrent = styler.GetLine(startPos);
-	int levelPrev = startPos == 0 ? 0 : (styler.LevelAt(lineCurrent)
+    synchronizeDocStart(startPos, length, initStyle, styler // ref args
+                        );
+    unsigned int endPos = startPos + length;
+    int visibleChars = 0;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelPrev = startPos == 0 ? 0 : (styler.LevelAt(lineCurrent)
                                          & SC_FOLDLEVELNUMBERMASK
                                          & ~SC_FOLDLEVELBASE);
-	int levelCurrent = levelPrev;
-	char chNext = styler[startPos];
-	int styleNext = styler.StyleAt(startPos);
-	int stylePrev = startPos <= 1 ? SCE_RB_DEFAULT : styler.StyleAt(startPos - 1);
+    int levelCurrent = levelPrev;
+    char chNext = styler[startPos];
+    int styleNext = styler.StyleAt(startPos);
+    int stylePrev = startPos <= 1 ? SCE_RB_DEFAULT : styler.StyleAt(startPos - 1);
     bool buffer_ends_with_eol = false;
-	for (unsigned int i = startPos; i < endPos; i++) {
-		char ch = chNext;
-		chNext = styler.SafeGetCharAt(i + 1);
-		int style = styleNext;
-		styleNext = styler.StyleAt(i + 1);
-		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+    for (unsigned int i = startPos; i < endPos; i++) {
+        char ch = chNext;
+        chNext = styler.SafeGetCharAt(i + 1);
+        int style = styleNext;
+        styleNext = styler.StyleAt(i + 1);
+        bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
         if (style == SCE_RB_COMMENTLINE) {
             if (foldComment && stylePrev != SCE_RB_COMMENTLINE) {
                 if (chNext == '{') {
-					levelCurrent++;
-				} else if (chNext == '}' && levelCurrent > 0) {
-					levelCurrent--;
-				}
+                    levelCurrent++;
+                } else if (chNext == '}' && levelCurrent > 0) {
+                    levelCurrent--;
+                }
             }
         } else if (style == SCE_RB_OPERATOR) {
-			if (strchr("[{(", ch)) {
-				levelCurrent++;
-			} else if (strchr(")}]", ch)) {
+            if (strchr("[{(", ch)) {
+                levelCurrent++;
+            } else if (strchr(")}]", ch)) {
                 // Don't decrement below 0
                 if (levelCurrent > 0)
                     levelCurrent--;
-			}
+            }
         } else if (style == SCE_RB_WORD && styleNext != SCE_RB_WORD) {
             // Look at the keyword on the left and decide what to do
             char prevWord[MAX_KEYWORD_LENGTH + 1]; // 1 byte for zero
@@ -1668,48 +1735,49 @@
                        || !strcmp(prevWord, "module")
                        || !strcmp(prevWord, "begin")
                        || !strcmp(prevWord, "case")
-                       || !strcmp(prevWord, "do")
+                       || (!strcmp(prevWord, "do")
+                           && !keywordDoStartsLoop(i, styler))
                        || !strcmp(prevWord, "while")
                        || !strcmp(prevWord, "unless")
                        || !strcmp(prevWord, "until")
                        || !strcmp(prevWord, "for")
                           ) {
-				levelCurrent++;
+                levelCurrent++;
             }
         }
-		if (atEOL) {
-			int lev = levelPrev;
-			if (visibleChars == 0 && foldCompact)
-				lev |= SC_FOLDLEVELWHITEFLAG;
-			if ((levelCurrent > levelPrev) && (visibleChars > 0))
-				lev |= SC_FOLDLEVELHEADERFLAG;
+        if (atEOL) {
+            int lev = levelPrev;
+            if (visibleChars == 0 && foldCompact)
+                lev |= SC_FOLDLEVELWHITEFLAG;
+            if ((levelCurrent > levelPrev) && (visibleChars > 0))
+                lev |= SC_FOLDLEVELHEADERFLAG;
             styler.SetLevel(lineCurrent, lev|SC_FOLDLEVELBASE);
-			lineCurrent++;
-			levelPrev = levelCurrent;
-			visibleChars = 0;
+            lineCurrent++;
+            levelPrev = levelCurrent;
+            visibleChars = 0;
             buffer_ends_with_eol = true;
-		} else if (!isspacechar(ch)) {
-			visibleChars++;
+        } else if (!isspacechar(ch)) {
+            visibleChars++;
             buffer_ends_with_eol = false;
         }
-		stylePrev = style;
+        stylePrev = style;
     }
-	// Fill in the real level of the next line, keeping the current flags as they will be filled in later
+    // Fill in the real level of the next line, keeping the current flags as they will be filled in later
     if (!buffer_ends_with_eol) {
         lineCurrent++;
         int new_lev = levelCurrent;
         if (visibleChars == 0 && foldCompact)
             new_lev |= SC_FOLDLEVELWHITEFLAG;
-			if ((levelCurrent > levelPrev) && (visibleChars > 0))
-				new_lev |= SC_FOLDLEVELHEADERFLAG;
+            if ((levelCurrent > levelPrev) && (visibleChars > 0))
+                new_lev |= SC_FOLDLEVELHEADERFLAG;
             levelCurrent = new_lev;
     }
-	styler.SetLevel(lineCurrent, levelCurrent|SC_FOLDLEVELBASE);
+    styler.SetLevel(lineCurrent, levelCurrent|SC_FOLDLEVELBASE);
 }
 
 static const char * const rubyWordListDesc[] = {
-	"Keywords",
-	0
+    "Keywords",
+    0
 };
 
 LexerModule lmRuby(SCLEX_RUBY, ColouriseRbDoc, "ruby", FoldRbDoc, rubyWordListDesc);
diff -ruN scintilla.orig/src/LexTCL.cxx scintilla/src/LexTCL.cxx
--- scintilla.orig/src/LexTCL.cxx	2007-05-31 19:57:25.000000000 -0500
+++ scintilla/src/LexTCL.cxx	1969-12-31 18:00:00.000000000 -0600
@@ -1,366 +0,0 @@
-// Scintilla source code edit control
-/** @file LexTCL.cxx
- ** Lexer for TCL language.
- **/
-// Copyright 1998-2001 by Andre Arpin <arpin@kingston.net>
-// The License.txt file describes the conditions under which this software may be distributed.
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdio.h>
-
-#include "Platform.h"
-
-#include "PropSet.h"
-#include "Accessor.h"
-#include "StyleContext.h"
-#include "KeyWords.h"
-#include "Scintilla.h"
-#include "SciLexer.h"
-
-#ifdef SCI_NAMESPACE
-using namespace Scintilla;
-#endif
-
-// Extended to accept accented characters
-static inline bool IsAWordChar(int ch) {
-	return ch >= 0x80 ||
-        (isalnum(ch) || ch == '_' || ch ==':' || ch=='.'); // : name space separator
-}
-
-static inline bool IsAWordStart(int ch) {
-	return ch >= 0x80 || (ch ==':' || isalpha(ch) || ch == '_');
-}
-
-static inline bool IsANumberChar(int ch) {
-	// Not exactly following number definition (several dots are seen as OK, etc.)
-	// but probably enough in most cases.
-	return (ch < 0x80) &&
-	       (IsADigit(ch, 0x10) || toupper(ch) == 'E' ||
-	        ch == '.' || ch == '-' || ch == '+');
-}
-
-static void ColouriseTCLDoc(unsigned int startPos, int length, int , WordList *keywordlists[], Accessor &styler) {
-#define  isComment(s) (s==SCE_TCL_COMMENT || s==SCE_TCL_COMMENTLINE || s==SCE_TCL_COMMENT_BOX || s==SCE_TCL_BLOCK_COMMENT)
-	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
-	bool commentLevel = false;
-    bool subBrace = false; // substitution begin with a brace ${.....}
-	enum tLineState {LS_DEFAULT, LS_OPEN_COMMENT, LS_OPEN_DOUBLE_QUOTE, LS_COMMENT_BOX, LS_MASK_STATE = 0xf, 
-        LS_COMMAND_EXPECTED = 16, LS_BRACE_ONLY = 32 } lineState = LS_DEFAULT;
-	bool prevSlash = false;
-	int currentLevel = 0;
-    bool expected = 0;
-    bool subParen = 0;
-
-	int currentLine = styler.GetLine(startPos);
-    if (currentLine > 0)
-        currentLine--;
-	length += startPos - styler.LineStart(currentLine);
-	// make sure lines overlap
-	startPos = styler.LineStart(currentLine);
-
-	WordList &keywords = *keywordlists[0];
-	WordList &keywords2 = *keywordlists[1];
-	WordList &keywords3 = *keywordlists[2];
-	WordList &keywords4 = *keywordlists[3];
-	WordList &keywords5 = *keywordlists[4];
-	WordList &keywords6 = *keywordlists[5];
-	WordList &keywords7 = *keywordlists[6];
-    WordList &keywords8 = *keywordlists[7];
-    WordList &keywords9 = *keywordlists[8];
-
-	if (currentLine > 0) {
-        int ls = styler.GetLineState(currentLine - 1);
-		lineState = tLineState(ls & LS_MASK_STATE);
-		expected = LS_COMMAND_EXPECTED == tLineState(ls & LS_COMMAND_EXPECTED);
-        subBrace = LS_BRACE_ONLY == tLineState(ls & LS_BRACE_ONLY);
-		currentLevel = styler.LevelAt(currentLine - 1) >> 17;
-		commentLevel = (styler.LevelAt(currentLine - 1) >> 16) & 1;
-	} else
-		styler.SetLevel(0, SC_FOLDLEVELBASE | SC_FOLDLEVELHEADERFLAG);
-	bool visibleChars = false;
-
-	int previousLevel = currentLevel;
-    StyleContext sc(startPos, length, SCE_TCL_DEFAULT, styler);
-	for (; ; sc.Forward()) {
-next:
-        if (sc.ch=='\r' && sc.chNext == '\n') // only ignore \r on PC process on the mac 
-            continue;
-        bool atEnd = !sc.More();  // make sure we coloured the last word
-        if (lineState != LS_DEFAULT) {
-            sc.SetState(SCE_TCL_DEFAULT);
-            if (lineState == LS_OPEN_COMMENT)
-                sc.SetState(SCE_TCL_COMMENTLINE);
-            else if (lineState == LS_OPEN_DOUBLE_QUOTE)
-                sc.SetState(SCE_TCL_IN_QUOTE);
-            else if (lineState == LS_COMMENT_BOX && (sc.ch == '#' || (sc.ch == ' ' && sc.chNext=='#')))
-                sc.SetState(SCE_TCL_COMMENT_BOX);
-            lineState = LS_DEFAULT;
-        }
-        if (subBrace) { // ${ overrides every thing even \ except }
-            if (sc.ch == '}') {
-                subBrace = false;
-                sc.SetState(SCE_TCL_OPERATOR);
-                sc.ForwardSetState(SCE_TCL_DEFAULT);
-                goto next;
-            }
-            else
-                sc.SetState(SCE_TCL_SUB_BRACE);
-            if (!sc.atLineEnd)
-                continue;
-        } else if (sc.state == SCE_TCL_DEFAULT || sc.state ==SCE_TCL_OPERATOR) {
-            expected &= isspacechar(static_cast<unsigned char>(sc.ch)) || IsAWordStart(sc.ch) || sc.ch =='#';
-        } else if (sc.state == SCE_TCL_SUBSTITUTION) {
-            switch(sc.ch) {
-            case '(':
-                subParen=true;
-                sc.SetState(SCE_TCL_OPERATOR);
-                sc.ForwardSetState(SCE_TCL_SUBSTITUTION);
-                continue;
-            case ')':
-                sc.SetState(SCE_TCL_OPERATOR);
-                subParen=false;
-                continue;
-            case '$':
-                continue;
-            case ',':
-                sc.SetState(SCE_TCL_OPERATOR);
-                if (subParen)
-                    sc.ForwardSetState(SCE_TCL_SUBSTITUTION);
-                continue;
-            default :
-                // maybe spaces should be allowed ???
-                if (!IsAWordChar(sc.ch)) { // probably the code is wrong
-                    sc.SetState(SCE_TCL_DEFAULT);
-                    subParen = 0;
-                }
-                break;
-            }
-        } else if (isComment(sc.state)) {
-        } else if (!IsAWordChar(sc.ch)) {
-            if ((sc.state == SCE_TCL_IDENTIFIER && expected) ||  sc.state == SCE_TCL_MODIFIER) {
-                char w[100];
-                char *s=w;
-                sc.GetCurrent(w, sizeof(w));
-                if (w[strlen(w)-1]=='\r')
-                    w[strlen(w)-1]=0;
-                while(*s == ':') // ignore leading : like in ::set a 10
-                    ++s;
-                bool quote = sc.state == SCE_TCL_IN_QUOTE;
-                if (commentLevel  || expected) {
-                    if (keywords.InList(s)) {
-                        sc.ChangeState(quote ? SCE_TCL_WORD_IN_QUOTE : SCE_TCL_WORD);
-                    } else if (keywords2.InList(s)) {
-                        sc.ChangeState(quote ? SCE_TCL_WORD_IN_QUOTE : SCE_TCL_WORD2);
-                    } else if (keywords3.InList(s)) {
-                        sc.ChangeState(quote ? SCE_TCL_WORD_IN_QUOTE : SCE_TCL_WORD3);
-                    } else if (keywords4.InList(s)) {
-                        sc.ChangeState(quote ? SCE_TCL_WORD_IN_QUOTE : SCE_TCL_WORD4);
-                    } else if (sc.GetRelative(-static_cast<int>(strlen(s))-1) == '{' &&
-                        keywords5.InList(s) && sc.ch == '}') { // {keyword} exactly no spaces
-                            sc.ChangeState(SCE_TCL_EXPAND);
-                    }
-                    if (keywords6.InList(s)) {
-                        sc.ChangeState(SCE_TCL_WORD5);
-                    } else if (keywords7.InList(s)) {
-                        sc.ChangeState(SCE_TCL_WORD6);
-                    } else if (keywords8.InList(s)) {
-                        sc.ChangeState(SCE_TCL_WORD7);
-                    } else if (keywords9.InList(s)) {
-                        sc.ChangeState(SCE_TCL_WORD8);
-                    } 
-                }
-                expected = false;
-                sc.SetState(quote ? SCE_TCL_IN_QUOTE : SCE_TCL_DEFAULT);
-            } else if (sc.state == SCE_TCL_MODIFIER || sc.state == SCE_TCL_IDENTIFIER) {
-                sc.SetState(SCE_TCL_DEFAULT);
-            }
-        }
-		if (atEnd)
-			break;
-        if (sc.atLineEnd) {
-            lineState = LS_DEFAULT;
-			currentLine = styler.GetLine(sc.currentPos);
-			if (foldComment && sc.state!=SCE_TCL_COMMENT && isComment(sc.state)) {
-				if (currentLevel == 0) {
-					++currentLevel;
-					commentLevel = true;
-				}
-			} else {
-				if (visibleChars && commentLevel) {
-					--currentLevel;
-					--previousLevel;
-					commentLevel = false;
-				}
-			}
-			int flag = 0;
-			if (!visibleChars)
-				flag = SC_FOLDLEVELWHITEFLAG;
-			if (currentLevel > previousLevel)
-				flag = SC_FOLDLEVELHEADERFLAG;
-			styler.SetLevel(currentLine, flag + previousLevel + SC_FOLDLEVELBASE + (currentLevel << 17) + (commentLevel << 16));
-
-			// Update the line state, so it can be seen by next line
-			if (sc.state == SCE_TCL_IN_QUOTE)
-				lineState = LS_OPEN_DOUBLE_QUOTE;
-			else {
-			     if (prevSlash) {
-				    if (isComment(sc.state))
-					    lineState = LS_OPEN_COMMENT;
-                } else if (sc.state == SCE_TCL_COMMENT_BOX)
-                    lineState = LS_COMMENT_BOX;
-			}
-            styler.SetLineState(currentLine, 
-                (subBrace ? LS_BRACE_ONLY : 0) |
-                (expected ? LS_COMMAND_EXPECTED : 0)  | lineState);
-            if (lineState == LS_COMMENT_BOX)
-                sc.ForwardSetState(SCE_TCL_COMMENT_BOX);
-            else if (lineState == LS_OPEN_DOUBLE_QUOTE)
-                sc.ForwardSetState(SCE_TCL_IN_QUOTE);
-            else
-                sc.ForwardSetState(SCE_TCL_DEFAULT);
-			prevSlash = false;
-			previousLevel = currentLevel;
-			goto next;
-		}
-
-		if (prevSlash) {
-            prevSlash = false;
-            if (sc.ch == '#' && IsANumberChar(sc.chNext))
-                sc.ForwardSetState(SCE_TCL_NUMBER);
-            continue;
-		}
-        prevSlash = sc.ch == '\\';
-        if (isComment(sc.state))
-            continue;
-		if (sc.atLineStart) {
-			visibleChars = false;
-			if (sc.state!=SCE_TCL_IN_QUOTE && !isComment(sc.state))
-            {
-				sc.SetState(SCE_TCL_DEFAULT);
-                expected = IsAWordStart(sc.ch)|| isspacechar(static_cast<unsigned char>(sc.ch));
-            }
-		}
-
-		switch (sc.state) {
-		case SCE_TCL_NUMBER:
-			if (!IsANumberChar(sc.ch))
-				sc.SetState(SCE_TCL_DEFAULT);
-			break;
-		case SCE_TCL_IN_QUOTE:
-			if (sc.ch == '"') {
-				sc.ForwardSetState(SCE_TCL_DEFAULT);
-				visibleChars = true; // necessary if a " is the first and only character on a line
-				goto next;
-			} else if (sc.ch == '[' || sc.ch == ']' || sc.ch == '$') {
-				sc.SetState(SCE_TCL_OPERATOR);
-                expected = sc.ch == '[';
-                sc.ForwardSetState(SCE_TCL_IN_QUOTE);
-				goto next;
-			}
-            continue;
-        case SCE_TCL_OPERATOR:
-			sc.SetState(SCE_TCL_DEFAULT);
-			break;
-		}
-
-		if (sc.ch == '#') {
-			if (visibleChars) {
-                if (sc.state != SCE_TCL_IN_QUOTE && expected)
-					sc.SetState(SCE_TCL_COMMENT);
-			} else {
-                sc.SetState(SCE_TCL_COMMENTLINE);
-                if (sc.chNext == '~')
-                    sc.SetState(SCE_TCL_BLOCK_COMMENT);
-                if (sc.atLineStart && (sc.chNext == '#' || sc.chNext == '-'))
-                        sc.SetState(SCE_TCL_COMMENT_BOX);
-            }
-        }
-
-		if (!isspacechar(static_cast<unsigned char>(sc.ch))) {
-			visibleChars = true;
-		}
-
-		if (sc.ch == '\\') {
-			prevSlash = true;
-			continue;		
-		}
-
-		// Determine if a new state should be entered.
-		if (sc.state == SCE_TCL_DEFAULT) {
-            if (IsAWordStart(sc.ch)) {
-				sc.SetState(SCE_TCL_IDENTIFIER);
-			} else if (IsADigit(sc.ch) && !IsAWordChar(sc.chPrev)) {
-				sc.SetState(SCE_TCL_NUMBER);
-			} else {
-				switch (sc.ch) {
-				case '\"':
-					sc.SetState(SCE_TCL_IN_QUOTE);
-					break;
-				case '{':
-					sc.SetState(SCE_TCL_OPERATOR);
-					expected = true;
-					++currentLevel;
-					break;
-				case '}':
-					sc.SetState(SCE_TCL_OPERATOR);
-					--currentLevel;
-					break;
-				case '[':
-                    expected = true;
-				case ']':
-				case '(':
-				case ')':
-					sc.SetState(SCE_TCL_OPERATOR);
-					break;
-				case ';':
-                    expected = true;
-					break;
-                case '$':
-                    subParen = 0;
-                    if (sc.chNext != '{') {
-                        sc.SetState(SCE_TCL_SUBSTITUTION);
-                    } 
-                    else {
-                        sc.SetState(SCE_TCL_OPERATOR);  // $
-                        sc.Forward();  // {
-                        sc.ForwardSetState(SCE_TCL_SUB_BRACE);
-                        subBrace = true;
-                    }
-                    break;
-                case '#':
-                    if ((isspacechar(static_cast<unsigned char>(sc.chPrev))||
-                            isoperator(static_cast<char>(sc.chPrev))) && IsADigit(sc.chNext,0x10))
-                        sc.SetState(SCE_TCL_NUMBER);
-                    break;
-                case '-':
-                    sc.SetState(IsADigit(sc.chNext)? SCE_TCL_NUMBER: SCE_TCL_MODIFIER);
-                    break;
-                default:
-                    if (isoperator(static_cast<char>(sc.ch))) {
-                        sc.SetState(SCE_TCL_OPERATOR);
-                    }
-				}
-			}
-		}
-	}
-	sc.Complete();
-}
-
-static const char * const tclWordListDesc[] = {
-            "TCL Keywords",
-            "TK Keywords",
-            "iTCL Keywords",
-            "tkCommands",
-            "expand"
-            "user1",
-            "user2",
-            "user3",
-            "user4",
-            0
-        };
-
-// this code supports folding in the colourizer
-LexerModule lmTCL(SCLEX_TCL, ColouriseTCLDoc, "tcl", 0, tclWordListDesc);
diff -ruN scintilla.orig/src/LexTcl.cxx scintilla/src/LexTcl.cxx
--- scintilla.orig/src/LexTcl.cxx	1969-12-31 18:00:00.000000000 -0600
+++ scintilla/src/LexTcl.cxx	2011-02-11 10:17:02.000000000 -0600
@@ -0,0 +1,532 @@
+/*  -*- tab-width: 8; indent-tabs-mode: t -*-
+ * Scintilla source code edit control
+ * @file LexTcl.cxx
+ * Lexer for Tcl.
+ */
+// Copyright (c) 2001-2006 ActiveState Software Inc.
+// The License.txt file describes the conditions under which this software may
+// be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+#if 1	// No Debug
+#define colourString(end, state, styler) styler.ColourTo(end, state)
+#else	// Debug color printfs
+#define colourString(end, state, styler) \
+	describeString(end, state, styler), styler.ColourTo(end, state)
+
+static char *stateToString(int state) {
+    switch (state) {
+    case SCE_TCL_DEFAULT:	return "default";
+    case SCE_TCL_NUMBER:	return "number";
+    case SCE_TCL_WORD:		return "word";
+    case SCE_TCL_COMMENT:	return "comment";
+    case SCE_TCL_STRING:	return "string";
+    case SCE_TCL_CHARACTER:	return "character";
+    case SCE_TCL_LITERAL:	return "literal";
+    case SCE_TCL_OPERATOR:	return "operator";
+    case SCE_TCL_IDENTIFIER:	return "identifier";
+    case SCE_TCL_EOL:		return "eol";
+    case SCE_TCL_VARIABLE:	return "variable";
+    case SCE_TCL_ARRAY:		return "array";
+    default:			return "unknown";
+    }
+}
+
+static void describeString(unsigned int end, int state, Accessor &styler) {
+    char s[1024];
+    unsigned int start = styler.GetStartSegment();
+    unsigned int len = end - start + 1;
+
+    if (!len) { return; }
+
+    for (unsigned int i = 0; i < len && i < 100; i++) {
+	s[i] = styler[start + i];
+	s[i + 1] = '\0';
+    }
+
+    int start_line = styler.GetLine(start);
+    int start_pos = start - styler.LineStart(start_line);
+    int end_line = styler.GetLine(end);
+    int end_pos = end - styler.LineStart(end_line);
+
+    fprintf(stderr, "%s [%d] [(%d:%d)=>(%d:%d)]:\t'%s'\n",
+	    stateToString(state), len,
+	    start_line, start_pos,
+	    end_line, end_pos,
+	    s); fflush(stderr);
+}
+#endif
+
+static inline bool isTclOperator(char ch) {
+    return strchr("(){}[];!%^&*-=+|<>?/", ch) != NULL;
+}
+
+static void classifyWordTcl(unsigned int start,
+			    unsigned int end,
+			    WordList &keywords,
+			    Accessor &styler) {
+    char s[100];
+    char chAttr;
+    bool wordIsNumber = isdigit(styler[start]) || (styler[start] == '.');
+
+    for (unsigned int i = 0; i < end - start + 1 && i < 40; i++) {
+	s[i] = styler[start + i];
+	s[i + 1] = '\0';
+    }
+
+    if (wordIsNumber) {
+	chAttr = SCE_TCL_NUMBER;
+    } else if (keywords.InList(s)) {
+	chAttr = SCE_TCL_WORD;
+    } else {
+	// was default, but that should be reserved for white-space,
+	// and we had to see an alpha-char to get here
+	chAttr = SCE_TCL_IDENTIFIER;
+    }
+
+    colourString(end, chAttr, styler);
+}
+
+// KOMODO  see if a style is one of our IO styles
+static inline bool IsIOStyle(int style) {
+	return style == SCE_TCL_STDIN ||
+		style == SCE_TCL_STDOUT ||
+		style == SCE_TCL_STDERR;
+}
+
+// By default there are 5 style bits, plenty for Tcl
+#define STYLE_MASK 31
+#define actual_style(style) (style & STYLE_MASK)
+
+// Null transitions when we see we've reached the end
+// and need to relex the curr char.
+
+static void redo_char(unsigned int &i, char &ch, char &chNext, int &state) {
+    i--;
+    chNext = ch;
+    state = SCE_TCL_DEFAULT;
+}
+
+// Because of the quote-in-brace problem, sync at the first
+// line that starts with a keyword
+
+static void synchronizeDocStart(unsigned int& startPos,
+				int &length,
+				int &initStyle,
+				Accessor &styler
+				// Left for compatibility with other lexers
+				// ,bool skipWhiteSpace=false
+				) {
+
+    styler.Flush();
+    int style = actual_style(styler.StyleAt(startPos));
+    switch (style) {
+	case SCE_TCL_STDIN:
+	case SCE_TCL_STDOUT:
+	case SCE_TCL_STDERR:
+	    // Don't do anything else with these.
+	    return;
+    }
+    int start_line, start_line_pos, start_style;
+    char ch;
+    int minLinesUp = 3;
+    for (start_line = styler.GetLine(startPos) - minLinesUp; start_line > 0; start_line--) {
+	start_line_pos = styler.LineStart(start_line);
+	start_style = actual_style(styler.StyleAt(start_line_pos));
+	// We like lines that start with a keyword or comment
+	if (start_style == SCE_TCL_WORD
+	    || start_style == SCE_TCL_COMMENT) {
+	    length += startPos - start_line_pos;
+	    startPos = start_line_pos;
+	    initStyle = start_style;
+	    return;
+	} else if (start_style == SCE_TCL_DEFAULT) {
+	    // Look for ^\s+<keyword>
+	    int i = start_line_pos;
+	    int lim = styler.LineStart(start_line + 1); // has to exist
+	    for (i = start_line_pos; i < lim; i++) {
+		ch = styler[i];
+		if (ch != ' ' && ch != '\t') {
+		    break;
+		} else {
+		    int next_style = actual_style(styler.StyleAt(i + 1));
+		    if (next_style == SCE_TCL_WORD) {
+			length += startPos - start_line_pos;
+			startPos = start_line_pos;
+			initStyle = start_style;
+			return;
+		    } else if (next_style != SCE_TCL_DEFAULT) {
+			break;
+		    }
+		}
+	    }
+	} else {
+	    break;
+	}
+    }
+    // Go back to the beginning.
+    length += startPos;
+    startPos = 0;
+    initStyle = SCE_TCL_DEFAULT;
+}
+
+static inline bool isSafeAlnum(char ch) {
+    return ((unsigned int) ch >= 128) || isalnum(ch) || ch == '_';
+}
+
+static inline void advanceOneChar(unsigned int& i, char&ch, char& chNext, char chNext2) {
+    i++;
+    ch = chNext;
+    chNext = chNext2;
+}
+
+static void ColouriseTclDoc(unsigned int startPos,
+			    int length,
+			    int initStyle,
+			    WordList *keywordlists[],
+			    Accessor &styler) {
+    WordList &keywords = *keywordlists[0];
+
+    int inEscape	= 0;
+    int inStrBraceCnt	= 0;
+    int inCmtBraceCnt    = 0; 
+    int lastQuoteSpot   = -1;
+    // We're not always sure of the command start, but make an attempt
+    bool cmdStart	= true;
+    // Keep track of whether a variable is using braces or it is an array
+    bool varBraced	= 0;
+    bool isMultiLineString = false;
+
+    //fprintf(stderr, "Start lexing at pos %d, len %d, style %d\n", startPos, length, initStyle);
+    
+    int state;
+    unsigned int lengthDoc = startPos + length;
+    if (IsIOStyle(initStyle)) {
+	// KOMODO
+	// Skip initial IO Style?
+	while (startPos < lengthDoc
+	       && IsIOStyle(actual_style(styler.StyleAt(startPos)))) {
+	    startPos++;
+	}
+	state = SCE_P_DEFAULT;
+    } else {
+	synchronizeDocStart(startPos, length, initStyle, styler);
+	lengthDoc = startPos + length;
+	state = initStyle;
+    }
+    //fprintf(stderr, "After sync, start at pos %d, len %d, style %d\n", startPos, length, initStyle);
+    char chPrev		= ' ';
+    char chNext		= styler[startPos];
+
+    // Folding info
+    int visibleChars = 0;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelPrev   = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+    int levelCurrent = levelPrev;
+    bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+
+    struct tag_lineInfo {
+	int lineCurrent, levelCurrent, levelPrev, visibleChars;
+    } heldLineInfo = {0, 0, 0, 0};
+
+    styler.StartAt(startPos);
+    styler.StartSegment(startPos);
+    for (unsigned int i = startPos; i < lengthDoc; i++) {
+	char ch = chNext;
+	chNext = styler.SafeGetCharAt(i + 1);
+
+	if (styler.IsLeadByte(ch)) {
+	    chNext = styler.SafeGetCharAt(i + 2);
+	    chPrev = ' ';
+	    i += 1;
+	    visibleChars++;
+	    continue;
+	}
+
+	if (chPrev == '\\') {
+	    // If the prev char was the escape char, flip the inEscape bit.
+	    // This works because colorization always starts at the
+	    // beginning of the line.
+	    inEscape = !inEscape;
+	} else if (inEscape) {
+	    if (chPrev == '\r' && ch == '\n') {
+		// Keep inEscape for one more round
+	    } else {
+		// Otherwise we aren't in an escape sequence
+		inEscape = 0;
+	    }
+	}
+
+	if ((ch == '\r' && chNext != '\n') || (ch == '\n')) {
+	    // Trigger on CR only (Mac style) or either on LF from CR+LF
+	    // (Dos/Win) or on LF alone (Unix) Avoid triggering two times on
+	    // Dos/Win End of line
+	    if (state == SCE_TCL_EOL) {
+		colourString(i, state, styler);
+		state = SCE_TCL_DEFAULT;
+	    }
+#if 0
+	    fprintf(stderr, "end of line %d, levelPrev=0x%0x, levelCurrent=0x%0x\n",
+		    lineCurrent, levelPrev, levelCurrent);
+#endif
+	    int lev = levelPrev;
+	    if (lev < SC_FOLDLEVELBASE) {
+		lev = SC_FOLDLEVELBASE;
+	    }
+	    if (visibleChars == 0 && foldCompact) {
+		lev |= SC_FOLDLEVELWHITEFLAG;
+	    }
+	    if ((levelCurrent > levelPrev) && (visibleChars > 0)) {
+		lev |= SC_FOLDLEVELHEADERFLAG;
+	    }
+	    if (lev != styler.LevelAt(lineCurrent)) {
+		styler.SetLevel(lineCurrent, lev);
+	    }
+	    lineCurrent++;
+	    levelPrev = levelCurrent;
+	    visibleChars = 0;
+	} else if (!isspacechar(ch)) {
+	    visibleChars++;
+	}
+
+	if (state == SCE_TCL_DEFAULT) {
+	    if ((ch == '#') && cmdStart) {
+		colourString(i-1, state, styler);
+		state = SCE_TCL_COMMENT;
+		inCmtBraceCnt = 0; 
+	    } else if ((ch == '\"') && !inEscape) {
+		colourString(i-1, state, styler);
+		isMultiLineString = false;
+		state = SCE_TCL_STRING;
+		inStrBraceCnt = 0;
+		lastQuoteSpot = i;
+		heldLineInfo.lineCurrent = lineCurrent;
+		heldLineInfo.levelCurrent = levelCurrent;
+		heldLineInfo.levelPrev = levelPrev;
+		heldLineInfo.visibleChars = visibleChars;
+	    } else if (ch == '$') {
+		colourString(i-1, state, styler);
+		if (chNext == '{') {
+		    varBraced = true;
+		    advanceOneChar(i, ch, chNext, styler.SafeGetCharAt(i + 1));
+		    state = SCE_TCL_VARIABLE;
+		} else if (iswordchar(chNext)) {
+		    varBraced = false;
+		    state = SCE_TCL_VARIABLE;
+		} else {
+		    colourString(i, SCE_TCL_OPERATOR, styler);
+		    // Stay in default mode.
+		}
+	    } else if (isTclOperator(ch) || ch == ':') {
+		if (ch == '-' && isascii(chNext) && isalpha(chNext)) {
+		    colourString(i-1, state, styler);
+		    // We could call it an identifier, but then we'd need another
+		    // state.  classifyWordTcl will do the right thing.
+		    state = SCE_TCL_WORD;
+		} else {
+		    // color up this one character as our operator
+		    // multi-character operators will have their second
+		    // character colored on the next pass
+		    colourString(i-1, state, styler);
+		    colourString(i, SCE_TCL_OPERATOR, styler);
+		    if (!inEscape) {
+			if (ch == '{' || ch == '[') {
+			    ++levelCurrent;
+			    cmdStart = true;
+			} else if  (ch == ']' || ch == '}') {
+			    if ((levelCurrent & SC_FOLDLEVELNUMBERMASK) > SC_FOLDLEVELBASE) {
+				--levelCurrent;
+			    }
+			}
+		    }
+		}
+	    } else if (iswordstart(ch)) {
+		colourString(i-1, state, styler);
+		if (iswordchar(chNext)) {
+		    state = SCE_TCL_WORD;
+		} else {
+		    classifyWordTcl(styler.GetStartSegment(), i,
+				    keywords, styler);
+		    // Stay in the default state
+		}
+	    }
+	} else if (state == SCE_TCL_WORD) {
+	    if (!iswordchar(chNext)) {
+		classifyWordTcl(styler.GetStartSegment(), i,
+				keywords, styler);
+		state = SCE_TCL_DEFAULT;
+	    }
+	} else {
+	    if (state == SCE_TCL_VARIABLE) {
+		/*
+		 * A variable is ${?\w*}? and may be directly followed by
+		 * another variable.  This should handle weird cases like:
+		 * $a$b           ;# multiple vars
+		 * ${a(def)(def)} ;# all one var
+		 * ${abc}(def)    ;# (def) is not part of the var name now
+		 * Previous to Komodo 4.2.1:
+		 * $a(def)(ghi)   ;# (def) is array key, (ghi) is just chars
+		 * ${a...}(def)(ghi)   ;# ( and ) are operators, def and ghi are chars
+		 */
+		if (!iswordchar(chNext)) {
+		    bool varEndsHere = false;
+		    if (varBraced) {
+			if (chNext == '}') {
+			    varBraced = false;
+			    colourString(i + 1, state, styler);
+			    state = SCE_TCL_DEFAULT;
+			    advanceOneChar(i, ch, chNext, styler.SafeGetCharAt(i + 2));
+			}
+			// else continue building a var-braced string
+		    } else if (chNext == ':' && styler.SafeGetCharAt(i + 2) == ':') {
+			// continue, it's part of a simple name, but advance
+			// so we don't stumble on the second colon
+			advanceOneChar(i, ch, chNext, ':');
+		    } else {
+			varEndsHere = true;
+		    }
+		    if (varEndsHere) {
+			colourString(i, state, styler);
+			state = SCE_TCL_DEFAULT;
+		    }
+		}
+	    } else if (state == SCE_TCL_OPERATOR) {
+		/* not reached */
+		if (ch == '}') {
+		    colourString(i-1, state, styler);
+		    state = SCE_TCL_DEFAULT;
+		}
+	    } else if (state == SCE_TCL_COMMENT) {
+		/*
+		 * The line continuation character also works for comments.
+		 */
+		if ((ch == '\r' || ch == '\n') && !inEscape) {
+		    colourString(i-1, state, styler);
+		    state = SCE_TCL_DEFAULT;
+		} else if ((ch == '{') && !inEscape) {
+		    inCmtBraceCnt++;
+		} else if ((ch == '}') && !inEscape) {
+		    inCmtBraceCnt--;
+		    if (inCmtBraceCnt < 0) {
+			if (levelCurrent > levelPrev) {
+			    colourString(i - 1, state, styler);
+			    redo_char(i, ch, chNext, state); // pass by ref
+			}
+		    }
+		}
+	    } else if (state == SCE_TCL_STRING) {
+		if ((ch == '\r' || ch == '\n') && !inEscape) {
+		    /*
+		     * In the case of EOL in a string where the line
+		     * continuations character isn't used, leave us in the
+		     * SCE_TCL_STRING state, but color the newline.
+		     */
+		    // No I think this is wrong -- EP
+		    // The lexer will color it as a string if it hits
+		    // a quote or EOF, otherwise it'll hit the brace
+		    // and whip back.
+		    
+		    //!! colourString(i-1, state, styler);
+		    isMultiLineString = true;
+		    //colourString(i, SCE_TCL_EOL, styler);
+		    /*
+		     * We are in a string, but in Tcl you can never really
+		     * say when a command starts or not until eval.
+		     */
+		    cmdStart = true;
+		} else if ((ch == '\"') && !inEscape) {
+		    colourString(i, state, styler);
+		    state = SCE_TCL_DEFAULT;
+		} else if ((ch == '{') && !inEscape) {
+		    inStrBraceCnt++;
+		} else if ((ch == '}') && !inEscape) {
+		    inStrBraceCnt--;
+		    if (inStrBraceCnt < 0) {
+			bool inside_brace;
+			if (levelCurrent > levelPrev) {
+			    inside_brace = true;
+			} else {
+			    int lev = styler.LevelAt(lineCurrent > 0 ? lineCurrent - 1 : 0);
+			    //fprintf(stderr, "pos %d, line %d, raw level=0x%0x\n", i, lineCurrent, lev);
+			    inside_brace = (((lev
+					      & (SC_FOLDLEVELNUMBERMASK
+						 & ~SC_FOLDLEVELBASE))) > 0);
+			}
+			if (inside_brace) {
+			    /*
+			     * We have hit a situation where brace counting
+			     * inside the string is < 0, so this was likely
+			     * a lone unescaped " character is a {}ed string.
+			     * Color it as a literal, and then relex from
+			     * the point after it.
+			     */
+			    state = SCE_TCL_DEFAULT;
+			    if (lastQuoteSpot >= 0) {
+				if (isMultiLineString) {
+				    // recolor
+				    styler.StartSegment(lastQuoteSpot);
+				    isMultiLineString = false;
+				}
+				colourString(lastQuoteSpot, SCE_TCL_LITERAL, styler);
+				chPrev = styler[i = lastQuoteSpot];
+				chNext = styler[lastQuoteSpot + 1];
+				lastQuoteSpot = -1;
+				lineCurrent = heldLineInfo.lineCurrent;
+				levelCurrent = heldLineInfo.levelCurrent;
+				levelPrev = heldLineInfo.levelPrev;
+				visibleChars = heldLineInfo.visibleChars;
+				continue;
+			    
+			    } else {
+				colourString(i-1, SCE_TCL_LITERAL, styler);
+				colourString(i, SCE_TCL_OPERATOR, styler);
+			    }
+			}
+		    }
+		}
+	    }
+	}
+
+	cmdStart = ((!inEscape && strchr("\r\n;[", ch)) // XXX '[' not needed?
+		    || (cmdStart && strchr(" \t[{", ch)));
+
+	chPrev = ch;
+    }
+    // Make sure to colorize last part of document
+    // If it was SCE_TCL_WORD (the default if we were in a word), then
+    // check to see whether it's a legitamite word.
+    if (state == SCE_TCL_WORD) {
+	classifyWordTcl(styler.GetStartSegment(), lengthDoc - 1,
+			keywords, styler);
+    } else {
+	colourString(lengthDoc - 1, state, styler);
+    }
+    int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+    styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+    styler.Flush();
+}
+
+static const char * const tclWordListDesc[] = {
+    "Tcl keywords",
+    0
+};
+
+LexerModule lmTcl(SCLEX_TCL, ColouriseTclDoc, "tcl", NULL,
+		  tclWordListDesc);
diff -ruN scintilla.orig/src/LexUDL.cxx scintilla/src/LexUDL.cxx
--- scintilla.orig/src/LexUDL.cxx	1969-12-31 18:00:00.000000000 -0600
+++ scintilla/src/LexUDL.cxx	2011-05-29 16:22:12.000000000 -0500
@@ -0,0 +1,3552 @@
+// Scintilla source code edit control
+/** @file LexUDL.cxx
+ ** Lexer for user-defined templates -- first try, with a hard-wired table
+ **/
+// Copyright 2006 by ActiveState Software Inc.
+// Authors: Eric Promislow <ericp@activestate.com>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#define _CRT_SECURE_NO_WARNINGS
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <string> // for current_delimiter
+
+// Perl-compatible regular expression library -- see pcre.org
+#define PCRE_STATIC
+#include <pcre.h>
+
+#define UDL_DEBUG 0
+#define UDL_DEBUG_TIME 0
+#define UDL_WINDEBUG 0
+
+#if UDL_DEBUG_TIME
+#include <sys/time.h>
+#endif
+
+#if UDL_WINDEBUG
+#include <time.h>
+#endif
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+#define assert PLATFORM_ASSERT
+
+//XXX Identical to Perl, put in common area
+static inline bool isEOLChar(char ch) {
+    return (ch == '\r') || (ch == '\n');
+}
+
+#define isSafeASCII(ch) ((unsigned int)(ch) <= 127)
+// This one's redundant, but makes for more readable code
+#define isHighBitChar(ch) ((unsigned int)(ch) > 127)
+
+// #pragma message("Compiling Komodo-devel/contrib/scintilla/src/LexUDL.cxx")
+
+static inline bool isSafeAlpha(char ch) {
+    return (isSafeASCII(ch) && isalpha(ch)) || ch == '_';
+}
+
+static inline bool isSafeAlnum(char ch) {
+    return (isSafeASCII(ch) && isalnum(ch)) || ch == '_';
+}
+
+static inline bool isSafeAlnumOrHigh(char ch) {
+    return isHighBitChar(ch) || isalnum(ch) || ch == '_';
+}
+
+static inline bool isSafeDigit(char ch) {
+    return isSafeASCII(ch) && isdigit(ch);
+}
+
+static inline bool isSafeWordcharOrHigh(char ch) {
+    // Error: scintilla's KeyWords.h includes '.' as a word-char
+    // we want to separate things that can take methods from the
+    // methods.
+    return isHighBitChar(ch) || isalnum(ch) || ch == '_';
+}
+
+static bool inline iswhitespace(char ch) {
+    return ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n';
+}
+
+#define STYLE_MASK 63
+#define actual_style(style) (style & STYLE_MASK)
+
+static inline int safeStyleAt(int pos, Accessor &styler) {
+    return actual_style((unsigned int)styler.StyleAt(pos));
+}
+
+#define MAX_KEYWORD_LENGTH 200
+
+static char opposite(char ch) {
+    if (ch == '(')
+        return ')';
+    if (ch == '[')
+        return ']';
+    if (ch == '{')
+        return '}';
+    if (ch == '<')
+        return '>';
+    return ch;
+}
+
+static void getRange(unsigned int start,
+                     unsigned int end,
+                     Accessor &styler,
+                     char *s,
+                     unsigned int len) {
+    unsigned int i = 0;
+    while ((i < end - start + 1) && (i < len-1)) {
+        s[i] = styler[start + i];
+        i++;
+    }
+    s[i] = '\0';
+}
+
+static void GetCurrent(char *s, unsigned int len, unsigned int end,
+                       Accessor &styler) {
+        getRange(styler.GetStartSegment(), end, styler, s, len);
+}
+
+#ifndef LOG_MEM
+#define LOG_MEM
+#endif
+#undef LOG_MEM
+#ifdef LOG_MEM
+
+static FILE *fp_log = NULL;
+
+#if _WIN32
+#pragma message("XXX: #undef LOG_MEM to stop logging mem usage in UDL")
+#endif
+
+static void OpenFPLog()
+{
+    fp_log = fopen("LexUDL.log", "w");
+}
+
+#include <time.h>
+
+static void LogEvent(bool entering, char *funcname, void *p)
+{
+    if (fp_log) {
+        time_t t;
+        time(&t);
+        struct tm* p_tm = localtime(&t);
+        
+        if (fp_log) {
+            fprintf(fp_log, "%04d-%02d-%02dT%02d:%02d:%02d -- %s: %s(0x%lx)\n",
+                    p_tm->tm_year % 100,
+                    p_tm->tm_mon + 1,
+                    p_tm->tm_mday,
+                    p_tm->tm_hour,
+                    p_tm->tm_min,
+                    p_tm->tm_sec,
+                    funcname,
+                    entering ? ">> Entering" : "<< Exiting",
+                    p);
+            fflush(fp_log);
+        }
+    }
+}
+#else
+#define OpenFPLog()
+#define LogEvent(status, funcname, p)
+#endif
+// end ifdef LOG_MEM
+
+
+// ****************************************************************
+// **************** Classes from UDL_Tables.h ****************
+// ****************************************************************
+
+
+// Definitions used by parts of the lexer
+
+/* Define the transition table -- these should be cached during a session,
+ * in each instance of the lexer.
+ */
+
+#define TRAN_SEARCH_STRING 1
+#define TRAN_SEARCH_REGEX  2
+#define TRAN_SEARCH_EMPTY  3
+#define TRAN_SEARCH_EOF    4
+#define TRAN_SEARCH_DELIMITER    5
+
+/* Definitions used for look-back tests in languages that
+ * have ambiguous lexemes, like '/' in JS/Perl/Ruby that can 
+ * either start a reg-ex or be the division operator.
+ */
+
+#define LBTEST_ACTION_SKIP	0
+#define LBTEST_ACTION_ACCEPT	1
+#define LBTEST_ACTION_REJECT	2
+#define LBTEST_NUM_ACTIONS		3
+
+#define LBTEST_LIST_ALL			1
+#define LBTEST_LIST_KEYWORDS	2
+#define LBTEST_LIST_STRINGS		3
+
+// We always have up to five families of styles
+
+#define TRAN_FAMILY_MARKUP		0
+#define TRAN_FAMILY_CSS			1
+#define TRAN_FAMILY_CSL			2 // Client-side lang, usually JS
+#define TRAN_FAMILY_SSL			3 // Server-side lang -- PHP,Ruby,Python,etc
+#define TRAN_FAMILY_TEMPLATE	4 // Template augmentation lang, like Smarty
+
+// No way we're going to have thousands of states, right...?
+
+#define SF_MAKE_PAIR(state, family) 	((family) << 24 | (state))
+#define SF_GET_STATE(fstate)			((fstate) & 0x00ffffff)
+#define SF_GET_FAMILY(fstate)			(((fstate) & ~0x00ffffff) >> 24)
+
+// ASTC : ActiveState Template Code
+
+// In most of these code words like 'set' and 'current' are implicit
+
+// 'F' : "FAMILY"
+// 'LBT' : Lookback test"
+
+// See bytecode.txt for a fuller description
+
+#define ASTC_NOP					0
+
+#define ASTC_META_COMMENTS			1
+#define ASTC_META_VERSION_MAJOR		2
+#define ASTC_META_VERSION_MINOR		3
+#define ASTC_META_VERSION_SUBMINOR	4
+
+#define ASTC_SCRATCH_BUFFER_START	11
+#define ASTC_SCRATCH_BUFFER_APPEND	12
+
+#define ASTC_LANGUAGE_NAME			13
+#define ASTC_F_COLOR				14
+#define ASTC_F_STYLE	    		15
+#define ASTC_F_OPERATOR				16
+#define ASTC_FLIPPER_COUNT			17
+#define ASTC_CURRENT_FAMILY			18
+#define ASTC_F_DEFAULT_STATE		19
+#define ASTC_F_FLIPPER				20
+#define ASTC_F_WORDLIST				21
+#define ASTC_F_KEYWORD_STYLE		22
+
+#define ASTC_F_LOOKBACK_TESTS_CREATE	23
+#define ASTC_F_LOOKBACK_TESTS_INIT	24
+#define ASTC_F_LOOKBACK_TESTS_COUNT	25
+
+#define ASTC_LBT_GET				26
+#define ASTC_LBT_ACTION_STYLE		27
+#define ASTC_LBT_STRINGS			28
+#define ASTC_LBT_WORDLIST			29
+#define ASTC_LBT_DEFAULT			30
+#define ASTC_LBT_TEST				31
+
+#define ASTC_TTABLE_NUM_UNIQUE_STATES	32
+#define ASTC_TTABLE_UNIQUE_STATE	33
+#define ASTC_TTABLE_CREATE_TRANS	34
+#define ASTC_TTABLE_GET_TBLOCK		35
+#define ASTC_CREATE_NEW_TRAN		36
+#define ASTC_TRAN_SET_F				37
+#define ASTC_TRAN_PUSH_STATE		38
+#define ASTC_TRAN_POP_STATE			39
+#define ASTC_TBLOCK_APPEND_TRAN		40
+#define ASTC_TBLOCK_EOF_TRAN		41
+#define ASTC_TBLOCK_EMPTY_TRAN		42
+
+#define ASTC_SUBLANGUAGE_NAME		43
+#define ASTC_EXTENSION				44
+#define ASTC_TRAN_EOL_STATE			45
+#define ASTC_TRAN_SET_DELIMITER		46
+#define ASTC_TRAN_KEEP_DELIMITER	47
+
+#define ASTC_TRAN_WRITER_VERSION	48
+
+#define ASTC_TRAN_CLEAR_DELIMITER	49
+
+#define READER_VERSION_MAJOR	1
+#define READER_VERSION_MINOR	1
+#define READER_VERSION_SUBMINOR	0
+
+static char *new_strdup(const char *s) {
+    if (!s) {
+        return NULL;
+    }
+    size_t slen = strlen(s);
+    char *ns = new char[slen + 1];
+    if (!ns) {
+        return NULL;
+    }
+    strcpy(ns, s);
+    return ns;
+}
+
+// There's probably a more OO-way of doing this...  see gang of 4
+
+// A test-obj is either a wordlist -- testing for membership,
+// a list of strings -- used to see if we're looking at one
+// of them when two or more contiguous tokens can have the same
+// style
+// or it's "ALL", which means all instances of this style are
+// handled the same way.
+
+class LookBackTestObj {
+    private:
+    int			test_type;   // strings/keywords/all
+    int			test_style;  // style it expects to test on
+    int			result_action; // accept/reject/skip
+    WordList   *p_wl;
+    char	  **pp_strings;
+    char	   *p_buf;
+    public:
+    LookBackTestObj() {
+        test_type = LBTEST_LIST_ALL; // The default
+        pp_strings = NULL;
+        p_wl = NULL;
+        p_buf = NULL;
+    };
+    ~LookBackTestObj() {
+        if (test_type == LBTEST_LIST_KEYWORDS) {
+            delete p_wl;
+        } else if (test_type == LBTEST_LIST_STRINGS) {
+            //XXX: This used to be scalar delete.
+            // Does this fix crash bug 59067?
+            delete[] p_buf;
+            if (pp_strings)
+                delete[] pp_strings;
+        }
+    };
+
+    inline void SetActionStyle(int result_action_, int test_style_) {
+        result_action = result_action_;
+        test_style = test_style_;
+    };
+    inline int Action() {
+        return result_action;
+    };
+    inline int Style() {
+        return test_style;
+    };
+    inline int Type() {
+        return test_type;
+    };
+    bool SetWordList(const char *s) {
+        if (p_wl) {
+            delete p_wl;
+        }
+        p_wl = new WordList;
+        if (!p_wl)
+            return false;
+        p_wl->Set(s);
+        test_type = LBTEST_LIST_KEYWORDS;
+        return true;
+    };
+    bool InKeywords(const char *s) {
+        return (p_wl && p_wl->InList(s));
+    };
+    bool SetStrings(const char *s) {
+        // Here we copy the incoming string into a work-buffer,
+        // and then build an array pointing to it as we zero-terminate
+        // the pieces
+        if (p_buf) {
+            delete[] p_buf;
+        }
+        if (pp_strings) {
+            delete[] pp_strings;
+        }
+        p_buf = new_strdup(s);
+        if (!p_buf)
+            return false;
+        char *p_workBuf = p_buf;
+        char *p_end = p_workBuf + strlen(p_buf);
+
+        int numStrings = 0;
+        bool inToken = false;
+        
+        // First figure out how big the array will be, and then
+        // go back and create it.
+        while (p_workBuf < p_end) {
+            if (iswhitespace(*p_workBuf)) {
+                inToken = false;
+            } else if (!inToken) {
+                inToken = true;
+                numStrings += 1;
+            }
+            ++p_workBuf;
+        }
+        pp_strings = new char*[numStrings + 1];
+        if (!pp_strings)
+            return false;
+        int n = 0; // current index
+        inToken = false;
+        for (p_workBuf = p_buf; p_workBuf < p_end; ++p_workBuf) {
+            if (iswhitespace(*p_workBuf)) {
+                if (inToken) {
+                    // zero-terminate the previous string.
+                    inToken = false;
+                    *p_workBuf = 0;
+                }
+            } else if (!inToken) {
+                inToken = true;
+                assert(n < numStrings);
+                pp_strings[n] = p_workBuf;
+                ++n;
+            }
+        }
+        assert(n == numStrings);
+        pp_strings[n] = 0;
+        test_type = LBTEST_LIST_STRINGS;
+        return true;
+    };
+    char **Strings() {
+        return pp_strings;
+    };
+};
+
+// A sparse array of array of LookBackTestObj items or nulls
+// Take the easy way out and allocate a [num styles] x 3 array,
+// as the number of styles is always low, around 10 -- 10 * 3 * 4
+// => 120 bytes per language
+
+// Since C++ doesn't handle multi-dimensional arrays to easily,
+// and I don't want to bring in vectors (or anything from STL,
+// as scintilla doesn't use it), I'll do manual conversion.
+
+class LookBackTests {
+    private:
+    int				  base_style;  // The default style for this sub-language
+    int				  num_tests;
+    LookBackTestObj	 **p_LBTests;  // Unmanaged array of LookBackTestObj objects
+    int				  num_styles;
+    int			     *p_defaults;
+
+    public:
+    LookBackTests() {
+        base_style = num_styles = num_tests = 0;
+        p_LBTests = NULL;
+        p_defaults = NULL;
+    };
+    ~LookBackTests() {
+        ClearTests();
+        if (p_defaults) {
+            delete[] p_defaults;
+        }
+    };
+
+    bool Init(int base_style_, int num_styles_) {
+        base_style = base_style_;
+        num_styles = num_styles_;
+        p_defaults = new int[num_styles];
+        if (!p_defaults) {
+            return false;
+        }
+        for (int i = 0; i < num_styles; i++) {
+            p_defaults[i] = LBTEST_ACTION_REJECT;
+        }
+        return true;
+    };
+
+    void SetTestCount(int n) {
+        ClearTests();
+        num_tests = n;
+        p_LBTests = new LookBackTestObj*[num_tests];
+        if (!p_LBTests) {
+            assert(0 && "Failed to allocate memory for the tests");
+            return;
+        }
+        for (int i = 0; i < num_tests; i++) {
+            p_LBTests[i] = new LookBackTestObj();
+        }
+    };
+    int GetTestCount() {
+        return num_tests;
+    };
+    void ClearTests() {
+        if (p_LBTests) {
+            for (int i = 0; i < num_tests; i++) {
+                delete p_LBTests[i];
+            }
+            delete[] p_LBTests;
+        }
+    }
+
+    // Policy: once a test is placed in this container,
+    // the container is responsible for deleting it.
+    
+    void SetTest(int i, LookBackTestObj *p_Test) {
+        if (i >= 0 && i < num_tests) {
+            p_LBTests[i] = p_Test;
+        } else {
+            assert(0 && "SetTest -- bad index");
+        }
+    };
+    LookBackTestObj * GetTest(int i) {
+        if (i < 0 || i >= num_tests) {
+            return NULL;
+        }
+        return p_LBTests[i];
+    };
+
+    int GetDefault(int style) {
+        int actIndex = ActualIndex(style);
+        assert(actIndex >= 0 && actIndex < num_styles * LBTEST_NUM_ACTIONS);
+        return p_defaults[actIndex];
+    };
+
+    void SetDefault(int style, int defaultAction) {
+        p_defaults[ActualIndex(style)] = defaultAction;
+    };
+
+    bool StyleInRange(int style) {
+        return style >= base_style && style < (base_style + num_styles);
+    };
+
+    private:        
+    inline int ActualIndex(int style) {
+        return style - base_style;
+    };
+        
+};
+
+// Info for pushing and popping states, effectively turning
+// our state machine into a pushdown automaton.  For now,
+// only one type can be pushed and popped.
+
+class StackItem {
+    public:
+    int state;
+    StackItem *p_next;
+    StackItem() : state(0), p_next(NULL) {
+    };
+    StackItem(int state_) : state(state_), p_next(NULL) {
+    };
+    StackItem(int state_, StackItem *p_si) : state(state_), p_next(p_si) {
+    };
+    ~StackItem() {
+    };
+};
+
+class StateStack {
+    private:
+    StackItem *p_top;
+    int        size;
+    public:
+    StateStack() : p_top(NULL), size(0) {
+    };
+    ~StateStack() {
+        while (p_top) {
+            (void) Pop();
+        }
+    };
+    void Push(int state) {
+        StackItem *p_tmp = new StackItem(state, p_top);
+        p_top = p_tmp;
+        size += 1;
+    };
+    int Pop() {
+        if (!p_top) {
+            return 0;
+        }
+        int i = p_top->state;
+        StackItem *p_tmp = p_top;
+        p_top = p_top->p_next;
+        delete p_tmp;
+        size -= 1;
+        return i;
+    };
+    int Size() {
+        return size;
+    };
+};
+
+// A "flipper" is a (string, style, direction value) tuple that
+// helps us determine the change in the line-level as we run
+// through a line
+
+class Flipper {
+    private:
+    char *s;
+    int style;
+    int direction;
+    friend class MainInfo;
+    public:
+    char *dump(char buf[]) {
+        sprintf(buf, "<Flipper: s:%s, style:%d, dir:%d>",
+                s, style, direction);
+        return buf;
+    };
+    Flipper() {
+        s = NULL;
+        style = -1;
+        direction = 0;
+    };
+    ~Flipper() {
+        if (s) {
+            delete[] s;
+        }
+    };
+    bool Init(char *s_, int style_, int direction_) {
+        if (direction_ == 0) return false;
+        s = new_strdup(s_);
+        if (!s) return false;
+        style = style_;
+        direction = direction_;
+        return true;
+    };
+    bool Match(char *s_, int style_, int pos, int docEnd,
+                int &ret_direction,
+                int &ret_amtMatched,
+                Accessor &styler) {
+        if (style != style_) {
+            return false;
+        }
+        int lim = strlen(s);
+        if (lim > docEnd - pos) {
+            return false;
+        }
+        if (strncmp(s, s_, lim)) {
+            return false;
+        }
+        for (int i = 0; i < lim; i++, pos++) {
+            if (safeStyleAt(pos, styler) != style_) {
+                return false;
+            }
+        }
+        ret_amtMatched = lim;
+        ret_direction = direction;
+        return true;
+    };
+};
+
+// This class influences how we lex the code for the
+// current family
+
+class FamilyInfo {
+
+    private:
+    LookBackTests      *p_LookBackTests;
+    WordList		   *keyword_list;  // Use scintilla's
+    char			   *p_sub_language_name;
+    int         		start_state;
+    int					identifier_style;
+    int					keyword_style;
+    
+    public:
+    FamilyInfo() {
+        keyword_list = NULL;
+        p_LookBackTests = NULL;
+        p_sub_language_name = NULL;
+        start_state = identifier_style = keyword_style = -1;
+    };
+    ~FamilyInfo() {
+        delete p_LookBackTests;
+        delete keyword_list;
+        delete[] p_sub_language_name;
+    };
+
+    void Init(int start_state_) {
+        start_state = start_state_;
+    }
+
+    LookBackTests *CreateNewLookBackTests() {
+        if (p_LookBackTests) {
+            delete p_LookBackTests;
+        }
+        p_LookBackTests = new LookBackTests();
+        return p_LookBackTests;
+    };
+
+    inline LookBackTests *GetLookBackTests() {
+        return p_LookBackTests;
+    };
+
+    int DefaultStartState() {
+        return start_state;
+    }
+
+    void SetWordList(const char *s) {
+        if (keyword_list) {
+            delete keyword_list;
+        }
+        keyword_list = new WordList;
+        if (keyword_list)
+            keyword_list->Set(s);
+        // Fail quietly, as this is in the generated code.
+    };
+    WordList &GetWordList() {
+        return *keyword_list;
+    };
+
+    void SetKeywordStyle(int identifier_style_, int keyword_style_) {
+        identifier_style = identifier_style_;
+        keyword_style = keyword_style_;
+    };
+    inline int GetIdentifierStyle() {
+        return identifier_style;
+    };
+    inline int GetKeywordStyle() {
+        return keyword_style;
+    };
+
+    inline void SetSublanguageName(char *p_Buf) {
+        delete[] p_sub_language_name;
+        p_sub_language_name = new_strdup(p_Buf);
+    };
+    inline char *GetSublanguageName() {
+        return p_sub_language_name;
+    };
+};
+       
+class Transition {
+    public: //XXX Make private
+    int     search_type;        // instance of TRAN_SEARCH_*
+    char   *p_search_string;    // new'ed pointer to a string
+    pcre   *p_pattern;
+    int     upto_color;         // if not -1, color upto starting pt this color
+    int     include_color;      // if not -1, color upto current pt this color
+    bool    do_redo;            // redo at this point
+    bool    no_keyword;         // This transition does no keyword promotion
+    int     new_state;          // -1: no new state
+    int     new_family;          // -1: stay in same family
+    int		token_check;		// 0: no check needed, !0: do a check
+    int		push_pop_state;		// Used with the state-stack
+    int     eol_target_state;     // Used with the at_eol directive.
+    int		target_delimiter;
+    bool	keep_current_delimiter;
+    bool	clear_current_delimiter;
+
+    class Transition *p_next;  // For the linked list
+
+    public:
+    Transition(int search_type_,
+               char   *p_search_string_,
+               int  upto_color_,
+               int  include_color_,
+               bool do_redo_,
+               int      new_state_,
+               int		token_check_,
+               int		ignore_case_,
+               bool no_keyword_
+) :
+            search_type(search_type_),
+            upto_color(upto_color_),
+            include_color(include_color_),
+            do_redo(do_redo_),
+            no_keyword(no_keyword_),
+            new_state(new_state_),
+            token_check(token_check_),
+            push_pop_state(0),
+            eol_target_state(0),
+            target_delimiter(0),
+            keep_current_delimiter(false),
+            clear_current_delimiter(false),
+            p_next(NULL) {
+        new_family = -1;
+        p_search_string = new_strdup(p_search_string_);
+        if (search_type == TRAN_SEARCH_REGEX && p_search_string) {
+            int options = PCRE_ANCHORED;
+            if (ignore_case_) {
+                options |= PCRE_CASELESS;
+            }
+            const char *errptr;
+            int   erroffset;
+            p_pattern = pcre_compile(p_search_string, options,
+                                     &errptr, &erroffset, NULL);
+            if (!p_pattern) {
+                //XXX Remove
+                fprintf(stderr, "udl: failed to compile ptn <%s>: failed at offset %d (%s): %s\n",
+                        p_search_string, erroffset, &p_search_string[erroffset],
+                        errptr);
+            }
+        } else {
+            p_pattern = NULL;
+        }
+    };
+    
+    ~Transition() {
+        delete[] p_search_string;
+        if (p_pattern) {
+            LogEvent(true, "~Transition::pcre_free(p_pattern)", p_pattern);
+            (*pcre_free)((void *) p_pattern);
+            LogEvent(false, "... pcre_free(p_pattern)", p_pattern);
+            p_pattern = NULL;
+        }
+    };
+    Transition *Next() {
+        return p_next;
+    };
+    inline void SetNewFamily(int new_family_) {
+        new_family = new_family_;
+    };
+    inline void SetPushState(int state, int family) {
+        push_pop_state = SF_MAKE_PAIR(state, family);
+    };
+    inline void SetPopState() {
+        push_pop_state = -1;
+    };
+    inline void SetEolTransition(int state, int family) {
+        eol_target_state = SF_MAKE_PAIR(state, family);
+    };
+    inline void SetDelimiter(int use_opposite, int group_num) {
+        target_delimiter = SF_MAKE_PAIR(use_opposite, group_num);
+    };
+    inline void KeepDelimiter() {
+        keep_current_delimiter = true;
+    };
+    inline void SetClearDelimiter() {
+        clear_current_delimiter = true;
+    };
+};
+
+// Each state for a template type has zero or more transitions
+
+class TransitionInfo {
+    public:
+    TransitionInfo() {
+        p_first = p_last = p_EOF = p_Empty = NULL;
+    };
+    ~TransitionInfo() {
+        Transition *p_curr = p_first, *p_next;
+        while (p_curr) {
+            p_next = p_curr->p_next;
+            delete p_curr;
+            p_curr = p_next;
+        }
+        p_first = p_last = NULL;
+        if (p_EOF) {
+            delete p_EOF;
+            p_EOF = NULL;
+        }
+        if (p_Empty) {
+            delete p_Empty;
+            p_Empty = NULL;
+        }
+    };
+    void Append(Transition *p_node) {
+        if (!p_last) {
+            assert(!p_first);
+            p_first = p_last = p_node;
+        } else {
+            p_last->p_next = p_node;
+            p_last = p_node;
+        }
+    };
+    void SetEOFInfo(Transition *p_node) {
+        p_EOF = p_node;
+    };
+    Transition *GetEOFInfo() {
+        return p_EOF;
+    };
+    void SetEmptyInfo(Transition *p_node) {
+        p_Empty = p_node;
+    };
+    Transition *GetEmptyInfo() {
+        return p_Empty;
+    };
+    
+
+    Transition *First() {
+        return p_first;
+    };
+    Transition *Next(Transition *p_curr) {
+        return p_curr->p_next;
+    };
+
+    private:
+    Transition *p_first, *p_last, *p_EOF, *p_Empty;
+};
+
+// Each template type has a set of types
+
+class TransitionTable {
+    private:
+    TransitionInfo  *p_transitions;
+
+    int count; // num transition info headers, one for each state, one for 0
+
+    int         	 num_unique_states;
+    int        		*p_unique_state_map;
+
+
+    public:
+    TransitionTable() {
+        p_transitions = NULL;
+        count = 0;
+        num_unique_states = 0;
+    };
+    ~TransitionTable() {
+        Clear();
+    };
+    
+    void CreateNewTransitions(int count_) {
+        Clear();
+        count = count_;
+        p_transitions = new TransitionInfo[count];
+    };
+
+    //XXX -- drop these
+    void SetNumUniqueStates(int i) {
+        num_unique_states = i;
+        p_unique_state_map = new int[2 * i];
+    };
+
+    void SetUniqueState(int index, int style_num, int internal_state_num) {
+        assert(index < num_unique_states);
+        p_unique_state_map[2 * index] = style_num;
+        p_unique_state_map[2 * index + 1] = internal_state_num;
+    };
+
+    int GetUniqueState(int style_num) {
+        int num_unique_states_adj = num_unique_states * 2;
+        for (int i = 0; i < num_unique_states_adj; i += 2) {
+            if (p_unique_state_map[i] == style_num) {
+                return p_unique_state_map[i + 1];
+            }
+        }
+        return -1; // failure
+    };
+
+    inline int Count() {
+        return count;
+    };
+
+    void Clear() {
+        delete[] p_transitions;
+        count = 0;
+    };
+    bool IsEmpty() {
+        return count == 0;
+    };
+
+    TransitionInfo *Get(int i) {
+        if (i < 0 || i >= count) {
+            assert(i >= 0 && i < count && "in TransitionTable::Get");
+            return NULL;
+        }
+        return &p_transitions[i];
+    };
+
+};
+
+#define NUM_FAMILIES 5
+#define NUM_VECTORS 30
+
+// Global info
+
+class StringStack;
+
+class MainInfo {
+    private:
+    TransitionTable   *p_TTable;
+    FamilyInfo		   **pp_FamilyInfo;
+    Flipper   		  **pp_Flippers; // for tracking levels
+    StateStack		   *p_StateStack;
+    int					flipper_count;
+
+    int 				curr_family;
+    char			   *p_language_name;
+
+    int					familyColors[NUM_FAMILIES];
+    int					familyOperators[NUM_FAMILIES];
+    int					familyStyles[NUM_FAMILIES];
+
+    bool					ready;
+
+    public:
+    char		   	   *p_raw_sublang_file; // Key for lookup
+    MainInfo		   *p_Next; // Used by LexerInfoList only
+
+    // Used semi-globally to transition when we hit the end-of-line
+    // Once one is set, nothing can override it.
+    
+    int					curr_eol_transition;
+
+    // Vars used for managing captured groups
+    int					ovec_count;  // space to work with captured groups
+    int					ovector[NUM_VECTORS];
+
+    public:
+    MainInfo(char *p_raw_sublang_file_) {
+        p_TTable = new TransitionTable();
+        pp_FamilyInfo = new FamilyInfo*[NUM_FAMILIES];
+        for (int i = 0; i < NUM_FAMILIES; i++) {
+            pp_FamilyInfo[i] = new FamilyInfo;
+        }
+        pp_Flippers = NULL;
+        p_language_name = NULL; // Not used?
+        flipper_count = 0;
+        p_StateStack = new StateStack;
+        ready = false;
+        p_raw_sublang_file = new_strdup(p_raw_sublang_file_);
+        p_Next = NULL;
+        ovec_count = NUM_VECTORS;
+    };
+    ~MainInfo() {
+        Clear();
+    };
+
+    inline bool IsReady() { return ready; };
+
+    void Clear() {
+        delete p_TTable;
+        delete[] p_language_name;
+        p_TTable = 0;
+        if (pp_FamilyInfo) {
+            for (int i = 0; i < NUM_FAMILIES; i++) {
+                delete pp_FamilyInfo[i];
+            }
+            delete[] pp_FamilyInfo;
+            pp_FamilyInfo = 0;
+        }
+        if (pp_Flippers) {
+            for (int i = 0; i < flipper_count; i++) {
+                delete pp_Flippers[i];
+            }
+            delete[] pp_Flippers;
+            pp_Flippers = 0;
+        }
+        delete p_StateStack;
+        p_StateStack = 0;
+        delete[] p_raw_sublang_file;
+        p_raw_sublang_file = 0;
+    };
+    bool Init(const char *sublang=NULL);
+    
+    void SetCurrFamily(int curr_family_) {
+        curr_family = curr_family_;
+    };
+    inline TransitionTable *GetTable() {
+        return p_TTable;
+    };
+    int CurrFamilyIdx() {
+        return curr_family;
+    };
+    FamilyInfo*	GetCurrFamily() {
+        if (curr_family < 0 || curr_family >= NUM_FAMILIES) {
+            assert(0 && "Bad family index");
+            return NULL;
+        }
+        return pp_FamilyInfo[curr_family];
+    };
+
+    int StyleToFamily(int currStyle) {
+        if (currStyle < SCE_UDL_CSS_DEFAULT) {
+            return TRAN_FAMILY_MARKUP;
+        } else if (currStyle < SCE_UDL_CSL_DEFAULT) {
+            return TRAN_FAMILY_CSS;
+        } else if (currStyle < SCE_UDL_SSL_DEFAULT) {
+            return TRAN_FAMILY_CSL;
+        } else if (currStyle < SCE_UDL_TPL_DEFAULT) {
+            return TRAN_FAMILY_SSL;
+        } else {
+            return TRAN_FAMILY_TEMPLATE;
+        }
+    };
+
+    int GetFamilyDefaultColor(int family) {
+        if (family < 0 || family >= NUM_FAMILIES) {
+            return -1;
+        }
+        return familyColors[family];
+    };
+
+    int GetFamilyDefaultStyle(int family) {
+        if (family < 0 || family >= NUM_FAMILIES) {
+            return -1;
+        }
+        return familyStyles[family];
+    };
+
+    void SetFlipperCount(int n) {
+        flipper_count = n;
+        pp_Flippers = new Flipper* [flipper_count];
+        for (int i = 0; i < flipper_count; i++) {
+            pp_Flippers[i] = new Flipper;
+        }
+    };
+
+    bool SetFlipper(int i, char *s, int style, int direction) {
+        if (i < 0 || i >= flipper_count) {
+            return false;
+        }
+        pp_Flippers[i]->Init(s, style, direction);
+        return true;
+    };
+
+private:
+    static int CompareFlippers(const void *p_data1, const void *p_data2) {
+        Flipper *p_flipper1 = *(Flipper **) p_data1;
+        Flipper *p_flipper2 = *(Flipper **) p_data2;
+        if (p_flipper1->style != p_flipper2->style) {
+            return p_flipper1->style - p_flipper2->style;
+        }
+        // Reverse ordering so we try longest matches first.
+        return strcmp(p_flipper2->s, p_flipper1->s);
+    }
+
+public:
+
+    void SortFlippers() {
+        qsort((void *) pp_Flippers,
+              (size_t) flipper_count,
+              (size_t) sizeof(Flipper *),
+              CompareFlippers);
+    };
+
+    void GetFoldChangeForLine(int lineStartPos,
+                              int lineEndPos,
+                             Accessor &styler,
+                             int& foldChange,
+                             bool& hasNonSpace,
+                              StringStack *p_tagStack);
+    int NumTransitions() {
+        return p_TTable->Count();
+    };
+
+    void PushState(int family_state) {
+        p_StateStack->Push(family_state);
+    };
+    int PopState() {
+        return p_StateStack->Pop();
+    };
+    int StateStackSize() {
+        return p_StateStack->Size();
+    };
+
+    // Helpers and internal routines
+    private:
+
+    char *GetNextNumber(char *p_readBuf, int& code) {
+        char *p_end;
+        long int val = strtol(p_readBuf, &p_end, 10);
+        code = (int) val;
+        return p_end;
+    };
+
+    void GetNumsFromLine(char *p_readBuf, int args[], size_t n_args,
+                         int *p_arg_count) {
+        int i = 0, tmp;
+        char *p_next;
+        while (i < (int) n_args) {
+            p_next = GetNextNumber(p_readBuf, tmp);
+            if (p_next == p_readBuf) break;
+            args[i++] = tmp;
+            
+            if (*p_next != ':') break;
+            p_readBuf = p_next + 1;
+        }
+        *p_arg_count = i;
+        for (;i < (int) n_args; i++) {
+            args[i] = -9999;
+        }
+    };
+
+    char *wrap_fgets(char *p_readBuf, int readBufSize, FILE *fp) {
+        char *p_buf = fgets(p_readBuf, readBufSize, fp);
+        if (!p_buf) return p_buf;
+        int slen = (int) strlen(p_readBuf) - 1;
+        if (slen >= 0) {
+            if (p_readBuf[slen] == '\n') {
+                p_readBuf[slen] = 0;
+                if (slen >= 1 && p_readBuf[slen - 1] == '\r') {
+                    p_readBuf[slen - 1] = 0;
+                }
+            } else if (!p_readBuf[slen]) {
+                fprintf(stderr, "udl: don't get it, p_readBuf[%d] = %d\n",
+                        slen, p_readBuf[slen]);
+            }
+        }
+        return p_buf;
+    };
+
+    bool verifyArgs(int args[], int arg_count, int num_needed, const char *sig) {
+        if (num_needed != arg_count) {
+            fprintf(stderr, "udl: verifyArgs: expecting %d args for the current opcode, got %d\n",
+                    num_needed, arg_count);
+            return false;
+        }
+        int *p_args = args;
+        const char *p_sig = sig;
+        int i = 0;
+        int mult = 0;// msvc warning 4701
+        int targ = 0;
+        for (i = 0; i < arg_count; i++, p_sig++, p_args++) {
+            if (!*p_sig) {
+                fprintf(stderr, "udl: verifyArgs: ran out of sig chars at item %d\n", i);
+                return false;
+            }
+            switch (*p_sig) {
+            case 'd': mult = 0; targ = 0; break;  // any integer
+            case 'p': mult = 1; targ = 1; break; // > 0
+            case 'P': mult = 1; targ = 0; break; // >= 0
+            case 'n': mult = -1; targ = 1; break; // < 0
+            case 'N': mult = -1; targ = 0; break; // <= 0
+            }
+            if (mult * *p_args < targ) {
+                fprintf(stderr, "udl: expecting arg %d to be of type %c, got %d\n",
+                        i, *p_sig, *p_args);
+                return false;
+            }
+        }
+        return true;
+    };
+
+    bool processingOlderFormat(int *writer_version) {
+        if (writer_version[0] < READER_VERSION_MAJOR) return true;
+        else if (writer_version[0] > READER_VERSION_MAJOR) return false;
+        else if (writer_version[1] < READER_VERSION_MINOR) return true;
+        // changes in subminor version are ignored.
+        else return false;
+    };
+
+    bool processingNewerFormat(int *writer_version) {
+        if (writer_version[0] > READER_VERSION_MAJOR) return true;
+        else if (writer_version[0] < READER_VERSION_MAJOR) return false;
+        else if (writer_version[1] > READER_VERSION_MINOR) return true;
+        // changes in subminor version are ignored.
+        else return false;
+    };
+};
+
+class BufferStateInfo {
+    // This class contains state info, used once per call
+    // to colourise.
+    
+    // Used semi-globally to transition when we hit the end-of-line
+    // Once one is set, nothing can override it.
+public:
+    int					curr_eol_transition;
+    int					num_captured_groups;
+    std::string			current_delimiter;
+    bool    				do_redo;
+
+    BufferStateInfo() {
+        curr_eol_transition = num_captured_groups = 0;
+        current_delimiter.clear();
+    };
+};
+
+#if _WIN32
+#pragma warning( disable : 4127)
+#endif
+
+#define null_check(constx, var) \
+do { \
+  if (!var) { \
+    fprintf(stderr, "udl: error: " #constx " at line %d: " #var " is null\n", __LINE__); \
+    goto free_stuff; \
+  } \
+} while (0)
+
+bool MainInfo::Init(const char *p_sublang_file) {
+    // This variant finds and reads in a lexer resource.
+    // Resource files have form of path/<sublang-name>.lexres
+
+
+    // Variables we'll need for reading:
+    int scratchBufSize = 255;
+    char *p_scratchBuf = NULL;
+    int numScratchCharsWritten = 0;
+
+    int readBufSize = 255;
+    char *p_readBuf = NULL;
+
+    TransitionTable *p_TransitionTable;
+    TransitionInfo *p_TranBlock = NULL;
+    Transition *p_Tran = NULL;
+    FamilyInfo *p_FamilyInfo = NULL;
+    LookBackTests *p_LBTests = NULL;
+    LookBackTestObj *p_LBTestObj = NULL;
+    int				versionInfo[3];
+    int bytecode;
+    int args[10];
+    int arg_count;
+    int writer_version[3] = {1, 0, 0};
+    int lineNo = 1;
+    char *p_lang = NULL;
+    FILE *fp = NULL;
+    bool rc = false;
+
+    // Don't define any other vars for this routine below
+    // this point due to the goto to the free_stuff thing.
+
+    fp = fopen(p_sublang_file, "r");
+    if (!fp) {
+        fprintf(stderr, "udl: can't open file %s (who knows why)\n",
+                p_sublang_file);
+        goto free_stuff;
+    }
+    p_TransitionTable = GetTable();
+    if (!p_TransitionTable) {
+        fprintf(stderr, "udl: no transition table\n");
+        goto free_stuff;
+    }
+    p_scratchBuf = (char *) malloc(scratchBufSize + 1);
+    if (!p_scratchBuf) {
+        fprintf(stderr, "udl: no memory for p_scratchBuf\n");
+        goto free_stuff;
+    }
+    p_readBuf = (char *) malloc(readBufSize + 1);
+    if (!p_readBuf) {
+        fprintf(stderr, "udl: no memory for p_readBuf\n");
+        goto free_stuff;
+    }
+    
+
+    for (;wrap_fgets(p_readBuf, readBufSize, fp); ++lineNo) {
+        if ((int) strlen(p_readBuf) >= readBufSize - 2) {
+            fprintf(stderr, "udl: internal error: line %d too big\n", lineNo);
+            goto free_stuff;
+        }
+        if (*p_readBuf == '#') {
+            // #-delimited comments ok
+            continue;
+        }
+        char *p_rest = GetNextNumber(p_readBuf, bytecode); // pass by ref
+        // Big switch stmt, better to make this a dispatcher
+        if (bytecode <= 0) {
+            fprintf(stderr, "udl: error: bad bytecode %d\n", bytecode);
+            goto free_stuff;
+        }
+        if (*p_rest == ':') p_rest++;
+        switch((int) bytecode) {
+        case ASTC_META_COMMENTS:
+        case ASTC_SCRATCH_BUFFER_APPEND:
+        case ASTC_LANGUAGE_NAME:
+        case ASTC_SUBLANGUAGE_NAME:
+            arg_count = 0; // Not used, squelch msvc warning 4701
+            break;
+        default:
+            GetNumsFromLine(p_rest, args, sizeof(args)/sizeof(args[0]),
+                            &arg_count);
+        }
+        
+        switch((int) bytecode) {
+        case ASTC_META_COMMENTS:
+            // fprintf(stderr, "udl: comment: %s\n", p_readBuf);
+            break;
+        case ASTC_META_VERSION_MAJOR:
+        case ASTC_META_VERSION_MINOR:
+        case ASTC_META_VERSION_SUBMINOR:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            versionInfo[bytecode - ASTC_META_VERSION_MAJOR] = args[0];
+            break;
+        case ASTC_SCRATCH_BUFFER_START:
+            if (!verifyArgs(args, arg_count, 1, "p"))
+                goto free_stuff;
+            if (scratchBufSize < args[0]) {
+                scratchBufSize = args[0];
+                char *p_hold = (char *) realloc(p_scratchBuf, scratchBufSize + 1);
+                if (!p_hold) {
+                    fprintf(stderr, "udl: MainInfo::Init: can't realloc scratch-buf\n");
+                    goto free_stuff;
+                }
+                p_scratchBuf = p_hold;
+            }
+            numScratchCharsWritten = 0;
+            p_scratchBuf[0] = 0;
+            break;
+            
+        case ASTC_SCRATCH_BUFFER_APPEND:
+            {
+                int numCharsToAdd = (int) strlen(p_rest);
+                if (numScratchCharsWritten + numCharsToAdd > scratchBufSize) {
+                    fprintf(stderr, 
+                            "udl: internal error: can't hold %d chars in a buf containing %d chars\n",
+                            numScratchCharsWritten + numCharsToAdd,
+                            scratchBufSize);
+                    goto free_stuff;
+                }
+                strncpy(&p_scratchBuf[numScratchCharsWritten], p_rest,
+                        numCharsToAdd);
+                numScratchCharsWritten += numCharsToAdd;
+                p_scratchBuf[numScratchCharsWritten] = 0;
+            }
+            break;
+
+        case ASTC_LANGUAGE_NAME:
+            if (!p_scratchBuf[0]) {
+                fprintf(stderr, "udl: language-name: p_scratchBuf is empty\n");
+                goto free_stuff;
+            }
+            delete[] p_language_name;
+            p_language_name = new_strdup(p_scratchBuf);
+            break;
+
+        case ASTC_SUBLANGUAGE_NAME:
+            if (!p_scratchBuf[0]) {
+                fprintf(stderr, "udl: sub-language-name: p_scratchBuf is empty\n");
+                goto free_stuff;
+            }
+            null_check(ASTC_SUBLANGUAGE_NAME, p_FamilyInfo);
+            p_FamilyInfo->SetSublanguageName(p_scratchBuf);
+            break;
+
+        case ASTC_F_COLOR:
+            if (!verifyArgs(args, arg_count, 2, "PP"))
+                goto free_stuff;
+            familyColors[args[0]] = args[1];
+            break;
+
+        case ASTC_F_STYLE:
+            if (!verifyArgs(args, arg_count, 2, "PP"))
+                goto free_stuff;
+            familyStyles[args[0]] = args[1];
+            break;
+
+        case ASTC_F_OPERATOR:
+            if (!verifyArgs(args, arg_count, 2, "Pp"))
+                goto free_stuff;
+            familyOperators[args[0]] = args[1];
+            break;
+            
+        case ASTC_FLIPPER_COUNT:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            SetFlipperCount(args[0]);
+            break;
+
+        case ASTC_CURRENT_FAMILY:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            SetCurrFamily(args[0]);
+            p_FamilyInfo = GetCurrFamily();
+            p_LBTests = NULL;
+            p_LBTestObj = NULL;
+            null_check(ASTC_CURRENT_FAMILY, p_FamilyInfo);
+            break;
+
+        case ASTC_F_DEFAULT_STATE:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_F_DEFAULT_STATE, p_FamilyInfo);
+            p_FamilyInfo->Init(args[0]);
+            break;
+
+        case ASTC_F_FLIPPER:
+            if (!verifyArgs(args, arg_count, 3, "PPd")) // non-neg twice, any
+                goto free_stuff;
+            if (!p_scratchBuf[0]) {
+                fprintf(stderr, "udl: set-flipper: p_scratchBuf is empty\n");
+                goto free_stuff;
+            }
+            // scratch-buf copied here
+            SetFlipper(args[0], p_scratchBuf, args[1], args[2]);
+            break;
+
+        case ASTC_F_WORDLIST:
+            if (!p_scratchBuf[0]) {
+                fprintf(stderr, "udl: set-wordlist: p_scratchBuf is empty\n");
+                goto free_stuff;
+            }
+            null_check(ASTC_F_WORDLIST, p_FamilyInfo);
+            // scratch-buf copied by the word-list thing
+            p_FamilyInfo->SetWordList(p_scratchBuf);
+            break;
+
+        case ASTC_F_KEYWORD_STYLE:
+            if (!verifyArgs(args, arg_count, 2, "PP"))
+                goto free_stuff;
+            null_check(ASTC_F_KEYWORD_STYLE, p_FamilyInfo);
+            p_FamilyInfo->SetKeywordStyle(args[0], args[1]);
+            break;
+
+        case ASTC_F_LOOKBACK_TESTS_CREATE:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_F_LOOKBACK_TESTS_CREATE, p_FamilyInfo);
+            p_LBTests = p_FamilyInfo->CreateNewLookBackTests();
+            p_LBTestObj = NULL;
+            if (!p_LBTests) {
+                fprintf(stderr, "udl: ASTC_F_LOOKBACK_TESTS_CREATE: failed to create p_LBTests\n");
+                goto free_stuff;
+            }
+            break;
+
+        case ASTC_F_LOOKBACK_TESTS_INIT:
+            if (!verifyArgs(args, arg_count, 2, "Pp"))
+                goto free_stuff;
+            null_check(ASTC_F_LOOKBACK_TESTS_INIT, p_LBTests);
+            p_LBTests->Init(args[0], args[1]);
+            break;
+            
+        case ASTC_F_LOOKBACK_TESTS_COUNT:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_F_LOOKBACK_TESTS_COUNT, p_LBTests);
+            p_LBTests->SetTestCount(args[0]);
+            break;
+            
+        case ASTC_LBT_GET:
+            if (!verifyArgs(args, arg_count, 1, "P")) // can have test 0
+                goto free_stuff;
+            null_check(ASTC_LBT_GET, p_LBTests);
+            p_LBTestObj = p_LBTests->GetTest(args[0]);
+            if (!p_LBTestObj) {
+                fprintf(stderr, "udl: ASTC_LBT_GET: failed to get p_LBTestObj\n");
+                goto free_stuff;
+            }
+            break;
+            
+        case ASTC_LBT_ACTION_STYLE:
+            if (!verifyArgs(args, arg_count, 2, "PP"))
+                goto free_stuff;
+            null_check(ASTC_LBT_ACTION_STYLE, p_LBTestObj);
+            p_LBTestObj->SetActionStyle(args[0], args[1]);
+            break;
+            
+        case ASTC_LBT_STRINGS:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_LBT_STRINGS, p_LBTestObj);
+            // scratch-buf copied by SetStrings
+            p_LBTestObj->SetStrings(p_scratchBuf);
+            break;
+            
+        case ASTC_LBT_WORDLIST:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_LBT_WORDLIST, p_LBTestObj);
+            if (!p_scratchBuf[0]) {
+                fprintf(stderr, "udl: ASTC_LBT_WORDLIST: p_scratchBuf is empty\n");
+                goto free_stuff;
+            }
+            // scratch-buf copied by the word-list thing
+            p_LBTestObj->SetWordList(p_scratchBuf); // no need to copy
+            break;
+
+        case ASTC_LBT_DEFAULT:
+            if (!verifyArgs(args, arg_count, 2, "PP"))
+                goto free_stuff;
+            null_check(ASTC_LBT_DEFAULT, p_LBTests);
+            p_LBTests->SetDefault(args[0], args[1]);
+            break;
+
+        case ASTC_LBT_TEST:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_LBT_TEST, p_LBTestObj);
+            null_check(ASTC_LBT_TEST, p_LBTests);
+            p_LBTests->SetTest(args[0], p_LBTestObj);
+            break;
+
+        case ASTC_TTABLE_NUM_UNIQUE_STATES:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_TTABLE_NUM_UNIQUE_STATES, p_TransitionTable);
+            p_TransitionTable->SetNumUniqueStates(args[0]);
+            break;
+
+        case ASTC_TTABLE_UNIQUE_STATE:
+            if (!verifyArgs(args, arg_count, 3, "PPp"))
+                goto free_stuff;
+            null_check(ASTC_TTABLE_UNIQUE_STATE, p_TransitionTable);
+            p_TransitionTable->SetUniqueState(args[0], args[1], args[2]);
+            break;
+
+        case ASTC_TTABLE_CREATE_TRANS:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_TTABLE_CREATE_TRANS, p_TransitionTable);
+            p_TransitionTable->CreateNewTransitions(args[0]);
+            break;
+
+        case ASTC_TTABLE_GET_TBLOCK:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_TTABLE_GET_TBLOCK, p_TransitionTable);
+            p_TranBlock = p_TransitionTable->Get(args[0]);
+            p_Tran = NULL;
+            if (!p_TranBlock) {
+                fprintf(stderr, "udl: ASTC_TTABLE_GET_TBLOCK: failed to get p_TranBlock");
+                goto free_stuff;
+            }
+            break;
+
+            // This went from 7 args to 8 post version 4.0 alpha 5
+        case ASTC_CREATE_NEW_TRAN:
+        {
+            bool no_keyword;
+            if (arg_count == 7) {
+                if (!verifyArgs(args, arg_count, 7, "PddPdPP"))
+                    goto free_stuff;
+                no_keyword = false;
+            } else {
+                if (!verifyArgs(args, arg_count, 8, "PddPdPPP"))
+                    goto free_stuff;
+                no_keyword = args[7] == 0 ? false : true;
+            }
+            // scratch-buf copied by the Transition ctor
+            p_Tran = new Transition(args[0],   // TRAN_regex|string|empty|eof
+                                    p_scratchBuf,
+                                    args[1],	// upto-color|-1
+                                    args[2],	// inc-color|-1
+                                    args[3] == 1 ? true : false,	// redo?
+                                    args[4],	// => state | -1 (don't)
+                                    args[5],	// token-check? 0 | 1
+                                    args[6],	// ignore-case? 0 | 1
+                                    no_keyword 	// no_keyword? 0 | 1
+                                    );
+            if (!p_Tran) {
+                fprintf(stderr, "udl: ASTC_CREATE_NEW_TRAN: failed to get p_Tran");
+                goto free_stuff;
+            }
+        }
+        break;
+
+        case ASTC_TRAN_SET_F:
+            if (!verifyArgs(args, arg_count, 1, "P"))
+                goto free_stuff;
+            null_check(ASTC_TRAN_SET_F, p_Tran);
+            p_Tran->SetNewFamily(args[0]);
+            break;
+
+        case ASTC_TRAN_PUSH_STATE:
+            if (!verifyArgs(args, arg_count, 2, "pP"))
+                goto free_stuff;
+            null_check(ASTC_TRAN_PUSH_STATE, p_Tran);
+            p_Tran->SetPushState(args[0], args[1]);
+            break;
+
+        case ASTC_TRAN_POP_STATE:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TRAN_POP_STATE, p_Tran);
+            p_Tran->SetPopState();
+            break;
+
+        case ASTC_TBLOCK_APPEND_TRAN:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TBLOCK_APPEND_TRAN, p_Tran);
+            p_TranBlock->Append(p_Tran);
+            break;
+
+        case ASTC_TBLOCK_EOF_TRAN:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TBLOCK_EOF_TRAN, p_Tran);
+            p_TranBlock->SetEOFInfo(p_Tran);
+            break;
+
+        case ASTC_TBLOCK_EMPTY_TRAN:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TBLOCK_EMPTY_TRAN, p_Tran);
+            p_TranBlock->SetEmptyInfo(p_Tran);
+            break;
+
+        case ASTC_TRAN_EOL_STATE:
+            if (!verifyArgs(args, arg_count, 2, "pP"))
+                goto free_stuff;
+            null_check(ASTC_TRAN_EOL_STATE, p_Tran);
+            p_Tran->SetEolTransition(args[0], args[1]);
+            break;
+
+        case ASTC_TRAN_SET_DELIMITER:
+            if (!verifyArgs(args, arg_count, 2, "Pp"))
+                goto free_stuff;
+            null_check(ASTC_TRAN_SET_DELIMITER, p_Tran);
+            p_Tran->SetDelimiter(args[0], args[1]);
+            break;
+
+        case ASTC_TRAN_KEEP_DELIMITER:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TRAN_KEEP_DELIMITER, p_Tran);
+            p_Tran->KeepDelimiter();
+            break;
+
+        case ASTC_TRAN_CLEAR_DELIMITER:
+            if (!verifyArgs(args, arg_count, 0, ""))
+                goto free_stuff;
+            null_check(ASTC_TRAN_KEEP_DELIMITER, p_Tran);
+            p_Tran->SetClearDelimiter();
+            break;
+
+        case ASTC_TRAN_WRITER_VERSION:
+            if (!verifyArgs(args, arg_count, 3, "PPP"))
+                goto free_stuff;
+            memcpy((void *) writer_version, (void *) args,
+                   (size_t) sizeof(writer_version));
+            break;
+            
+        default:
+            // If we're processing this version's format, or an older
+            // one, complain and stop.  Otherwise quietly ignore
+            // bytecodes from the future.
+            if (!processingNewerFormat(writer_version)) {
+                fprintf(stderr, "udl: found unknown op %d\n", bytecode);
+                goto free_stuff;
+            } else {
+                fprintf(stderr, "udl: reader/writer mismatch: reader (Komodo) is built for lexres version %d.%d,\ngiven file is version %d.%d -- ignoring op %d\n",
+                        READER_VERSION_MAJOR,
+                        READER_VERSION_MINOR,
+                        writer_version[0],
+                        writer_version[1],
+                        bytecode);
+            }
+            break;
+        }
+    }
+    SortFlippers();
+    rc = true;
+
+    // Jump to here and continue;
+    free_stuff:
+    if (!rc) {
+        fprintf(stderr, "udl: bailing out of file '%s' at line %d\n",
+                p_sublang_file, lineNo);
+        Clear();
+    } else {
+        ready = true;
+    }
+    if (p_lang) free(p_lang);
+    if (p_scratchBuf)  free(p_scratchBuf);
+    if (p_readBuf) free(p_readBuf);
+    if (fp) fclose(fp);             
+    return rc;
+}
+
+#if _WIN32
+#pragma warning( default : 4127)
+#endif
+
+// Note -- the second value is zero-terminated
+static int udl_strncasecmp(const char *a, char *b, int len) {
+    while (--len >= 0) {
+        int diff = tolower(*a++) - tolower(*b++);
+        if (diff) {
+            return diff;
+        }
+    }
+    // Verify that the both end here.
+    if (*b) {
+        return 0 - tolower(*b);
+    }
+    return 0;
+}
+
+class StringStack {
+private:
+    char *tagNameStorageBase;
+    char *tagNameStorageAvail;
+    char *tagNameStorageIndex;
+    char **stack;
+    int   stackSize;
+    int   stackIndex;
+    StringStack &operator=(StringStack&) {return *this;}; // Not avail or used
+    void finishInit(int numStackItems, int tagNameStorageSpace) {
+        stack = new char*[numStackItems];
+        stackSize = numStackItems;
+        stackIndex = 0;
+        tagNameStorageBase = new char[tagNameStorageSpace];
+        tagNameStorageIndex = tagNameStorageBase;
+        tagNameStorageAvail = tagNameStorageBase + tagNameStorageSpace * sizeof(char);
+    }
+    bool verifyStackSpace() {
+        if (stackIndex >= stackSize) {
+            char **tmp = new char*[stackSize * 2];
+            if (!tmp) {
+                return false;
+            }
+            stackSize *= 2;
+            memcpy(tmp, stack, stackIndex * sizeof(stack[0]));
+            delete[] stack;
+            stack = tmp;
+        }
+        return true;
+    }
+
+    void updateStackPointers(char *newNameStorageBase) {
+        // Old names are stored in tagNameStorageBase.
+        // The pointers to them need to be updated to point into newNameStorageBase
+
+        int i;
+        int delta;
+        char *p_dest = newNameStorageBase;
+        for (i = 0; i < stackIndex - 1; i++) {
+            delta = stack[i + 1] - stack[i];
+            stack[i] = p_dest;
+            p_dest += delta;
+        }
+        stack[i] = p_dest;
+    }
+
+    bool verifyStringSpace(int strLen) {
+        int strLenWithNullByte = strLen + 1;
+        if (tagNameStorageIndex + strLenWithNullByte > tagNameStorageAvail) {
+            int newSize = (tagNameStorageAvail - tagNameStorageBase) * 2;
+            int oldIndex = tagNameStorageIndex - tagNameStorageBase;
+            int sentinel = 0;
+            while (newSize < oldIndex + strLenWithNullByte) {
+                newSize *= 2;
+                if (++sentinel >= 100) {
+                    fprintf(stderr, "UDL::verifyStringSpace -- internal error calculating memory requirements\n");
+                    return false;
+                }
+            }
+            char *tmp = new char[newSize];
+            if (!tmp) return false;
+            memcpy(tmp, tagNameStorageBase, oldIndex);
+            updateStackPointers(tmp);
+            delete[] tagNameStorageBase;
+            tagNameStorageBase = tmp;
+            tagNameStorageAvail = tagNameStorageBase + newSize;
+            tagNameStorageIndex = tagNameStorageBase + oldIndex;
+        }
+        return true;
+    }
+public:
+    StringStack(int n) {
+        finishInit(n, 128);
+    };
+    StringStack() {
+        finishInit(10, 128);
+    };
+    ~StringStack() {
+        delete[] stack;
+        delete[] tagNameStorageBase;
+    }
+    bool isEmpty() {
+        return stackIndex == 0;
+    };
+    void push(const char *s, int slen) {
+        verifyStackSpace();
+        verifyStringSpace(slen);
+        int i;
+        const char *ps;
+        for (i = 0, ps = s; i < slen; i++, ps++) {
+            tagNameStorageIndex[i] = tolower(*ps);
+        }
+        tagNameStorageIndex[i] = 0;
+        stack[stackIndex] = tagNameStorageIndex;
+        tagNameStorageIndex += slen + 1; // skip the null byte;
+        ++stackIndex;
+    }
+    char *top() {
+        return stackIndex == 0 ? NULL : stack[stackIndex - 1];
+    }
+    char *pop() {
+        if (stackIndex == 0) return NULL;
+        char *s = stack[stackIndex - 1];
+        tagNameStorageIndex = stack[stackIndex - 1];
+        stackIndex -= 1;
+        return s;
+    }
+    void empty() {
+        stackIndex = 0;
+        tagNameStorageIndex = tagNameStorageBase;
+    }
+    bool contains(char *s, int slen) {
+        for (int i = 0; i < stackIndex; i++) {
+            if (!udl_strncasecmp(s, stack[i], slen)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    void dump() {
+        fprintf(stderr, "tagstack: stackIndex:%d, stackSize:%d, tagIndx: %ld, tagAvail:%ld, stack:\n   ",
+                stackIndex, stackSize,
+                (long) (tagNameStorageIndex - tagNameStorageBase),
+                (long) (tagNameStorageAvail - tagNameStorageBase));
+        for (int i = 0; i < stackIndex; i++) {
+            fprintf(stderr, "%d:%s  ", i, stack[i]);
+        }
+        fprintf(stderr, "\n");
+    }
+};
+
+static const char *html_no_close_tags[] =  {
+        "basefont", "br", "area", "link", "img", "param", "hr", "input",
+        "col", "frame", "isindex", "base", "meta", NULL
+};
+static const char *html_optional_close_tags[] = {
+        "p", "dt", "dd", "li", "option", "thead", "tfoot", "colgroup",
+        "col", "tr", "th", "td", "script", "style", NULL
+    };
+static const char *html_block_tags[] = {
+        "p", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "pre", "dl", "div", "noscript", 
+        "blockquote", "form", "hr", "table", "fieldset", "address",
+        "script", "style", NULL
+    };
+static const char *html_cannot_contain_block_tags[] = {
+    "p", "dt", "script", "style", NULL
+    };
+static const char *html_close_tag_unnecessary[] = {
+        "basefont", "br", "area", "link", "img", "param", "hr", "input",
+        "col", "frame", "isindex", "base", "meta",
+        "p", "dt", "dd", "li", "option", "thead", "tfoot", "colgroup",
+        "col", "tr", "th", "td", "script", "style", NULL
+};
+
+static bool is_member(const char *name, int len, const char **list) {
+    for (const char **item = list; *item; ++item) {
+        if (!strncmp(name, *item, len) && !(*item)[len]) {
+            return true;
+        }
+    }
+    return false;
+}
+
+#define OMIT_TAG_DEBUG 0
+
+void MainInfo::GetFoldChangeForLine(int lineStartPos,
+                                    int lineEndPos,
+                                    Accessor& styler,
+                                    int& foldChange,
+                                    bool& hasNonSpace,
+                                    StringStack *p_tagStack
+                                    )
+{
+    // Fill the line
+    // lineEndPos points one past the last char we're interested in.
+
+    foldChange = 0;
+    hasNonSpace = false;
+    char *buf = new char[lineEndPos - lineStartPos + 1];
+    if (!buf) return;
+    char *p_buf = buf;
+    for (int i = lineStartPos; i < lineEndPos; i++) {
+        *p_buf++ = styler[i];
+    }
+    *p_buf = 0;
+    hasNonSpace = (int) strspn(buf, " \t\r\n") < lineEndPos - lineStartPos;
+    int netChange = 0;
+    int pos = lineStartPos;
+    int i = 0;
+    int lastStyle = -1;
+    int currStyleStartIdx = 0;
+    bool isTagMarkupStyles[SCE_UDL_UPPER_BOUND + 1];
+    if (p_tagStack) {
+        memset(isTagMarkupStyles, 0, sizeof(isTagMarkupStyles));
+        isTagMarkupStyles[SCE_UDL_M_STAGO] =
+            isTagMarkupStyles[SCE_UDL_M_ETAGO] =
+            isTagMarkupStyles[SCE_UDL_M_EMP_TAGC] =
+            isTagMarkupStyles[SCE_UDL_M_STAGC] = true;
+    }
+    while (pos < lineEndPos) {
+        int style = safeStyleAt(pos, styler);
+        int j;
+        if (p_tagStack
+            && isTagMarkupStyles[style]) {
+            char curChar = buf[i];
+            if (curChar == '<'
+                && (style == SCE_UDL_M_STAGO || style == SCE_UDL_M_ETAGO)) {
+#if OMIT_TAG_DEBUG
+                fprintf(stderr, "Look at an html tag...\n");
+#endif
+                int i1 = i + 1;
+                int pos1 = pos + 1;
+                if (style == SCE_UDL_M_ETAGO
+                    && safeStyleAt(pos1, styler) == SCE_UDL_M_ETAGO) {
+                    ++pos1;
+                    ++i1;
+                }
+                char *p_tag_start = &buf[i1];
+                char *p_tag_end = NULL;
+                for (; pos1 < lineEndPos; ++pos1, ++i1) {
+                    if (safeStyleAt(pos1, styler) != SCE_UDL_M_TAGNAME) {
+#if OMIT_TAG_DEBUG
+                        fprintf(stderr, "Pulling out at \"%.10s\"\n", &buf[i1 - 1]);
+#endif
+                        p_tag_end = &buf[i1];
+                        break;
+                    }
+                }
+                if (pos1 == lineEndPos) {
+#if OMIT_TAG_DEBUG
+                    fprintf(stderr, "Hit the end of the line while looking at tags\n");
+#endif
+                    goto skip_tag_stack_adjustment;
+                }
+#if OMIT_TAG_DEBUG
+                fprintf(stderr, "Looking at tag style %d, name %.*s\n", style, p_tag_end - p_tag_start, p_tag_start);
+#endif
+                char *curr_tag_name = p_tag_start;
+                int   curr_tag_len = p_tag_end - p_tag_start;
+                char *prev_tag_name = p_tagStack->top();
+#if OMIT_TAG_DEBUG
+                fprintf(stderr, "STAGO|ETAGO : prev_tag_name: %s, curr_tag_len:%d, curr_tag_name:[%.*s]\n",
+                     prev_tag_name ? prev_tag_name : "<none>",
+                      curr_tag_len, curr_tag_len, curr_tag_name);
+#endif
+                if (style == SCE_UDL_M_STAGO) {
+                    if (prev_tag_name) {
+                        // Clear pending end-tags and omissible end-tag start-tags
+                        // Don't forget to check to see if this is an empty-tag
+
+                        // <foo>...<foo>, foo is optional-close
+                        if (!strncmp(curr_tag_name, prev_tag_name, curr_tag_len)
+                            && is_member(prev_tag_name,
+                                         strlen(prev_tag_name),
+                                         html_optional_close_tags)) {
+#if OMIT_TAG_DEBUG
+                            fprintf(stderr, "Pop: html_optional_close_tags, same tag\n");
+#endif
+                            p_tagStack->pop();
+                            --netChange;
+                            // <th>|<td> ... <tr> - close the item
+                        } else if (prev_tag_name[0] == 't' // "th" or "td"
+                                   && (prev_tag_name[1] == 'h'
+                                       || prev_tag_name[1] == 'd')
+                                   && !prev_tag_name[2]
+                                   && curr_tag_len == 2
+                                   && !strncmp(curr_tag_name, "tr", 2)) {
+                            p_tagStack->pop();
+#if OMIT_TAG_DEBUG
+                            fprintf(stderr, "Pop: th|td .. tr\n");
+#endif
+                            --netChange;
+                            // <x>...<y>, x can't contain block, y is block
+                        } else if (is_member(prev_tag_name,
+                                             strlen(prev_tag_name),
+                                             html_cannot_contain_block_tags)
+                                   && is_member(curr_tag_name,
+                                                curr_tag_len,
+                                                html_block_tags)) {
+                            p_tagStack->pop();
+#if OMIT_TAG_DEBUG
+                            fprintf(stderr, "Pop: prev cannot_contain_block_tags, curr is block\n");
+#endif
+                            --netChange;
+                        }
+                    }
+#if OMIT_TAG_DEBUG
+                    fprintf(stderr, "About to push tag %.*s\n", curr_tag_len, curr_tag_name);
+#endif
+                    p_tagStack->push(curr_tag_name, curr_tag_len);
+                    // Increment the netChange at the '>'
+                } else {
+                    // assert (style == SCE_UDL_M_ETAGO);
+#if OMIT_TAG_DEBUG
+                    fprintf(stderr, "ETAGO </: curr_tag_len:%d, curr_tag_name: [%.*s]\n",
+                         curr_tag_len, curr_tag_len, curr_tag_name);
+                    fprintf(stderr, "ETAGO </: prev_tag_name: %s\n",
+                          prev_tag_name ? prev_tag_name : "<none>");
+#endif
+                    if (prev_tag_name
+                        && p_tagStack->contains(curr_tag_name, curr_tag_len)) {
+#if OMIT_TAG_DEBUG
+                        fprintf(stderr, "Stack contains tag %*.s\n",
+                              curr_tag_len, curr_tag_name);
+#endif
+                        while (udl_strncasecmp(curr_tag_name, prev_tag_name,
+                                               curr_tag_len)) {
+                            p_tagStack->pop();
+                            prev_tag_name = p_tagStack->top();
+                            --netChange;
+                        }
+                    } else {
+                        while (prev_tag_name
+                               // Verify they're different
+                               && udl_strncasecmp(curr_tag_name, prev_tag_name,
+                                                  curr_tag_len)
+                               && is_member(prev_tag_name,
+                                            strlen(prev_tag_name),
+                                            html_close_tag_unnecessary)) {
+#if OMIT_TAG_DEBUG
+                            fprintf(stderr, "Pop: ETAGO: prev:%s, curr:%.*s, diff tags, prev is html_close_tag_unnecessary\n",
+                                    prev_tag_name, curr_tag_len, curr_tag_name);
+#endif
+                            p_tagStack->pop();
+                            prev_tag_name = p_tagStack->top();
+#if OMIT_TAG_DEBUG
+                            fprintf(stderr, "ETAGO </: After POP: prev_tag_name:%s, curr_tag_len:%d, curr_tag_name: [%.*s]\n",
+                                  prev_tag_name,
+                                  curr_tag_len, curr_tag_len, curr_tag_name);
+                            p_tagStack->dump();
+#endif
+                            --netChange;
+                        }
+                    }
+                    if (prev_tag_name
+                        && !udl_strncasecmp(curr_tag_name, prev_tag_name,
+                                            curr_tag_len)) {
+                        prev_tag_name = p_tagStack->pop();
+#if OMIT_TAG_DEBUG
+                        fprintf(stderr, "Pop: ETAGO: etag == stag\n");
+#endif
+                        // Decrement the netChange at the '>'
+                    }
+                }
+#if OMIT_TAG_DEBUG
+                p_tagStack->dump();
+#endif
+                
+            } else if (style == SCE_UDL_M_EMP_TAGC
+                       && curChar == '/') {
+                p_tagStack->pop();
+#if OMIT_TAG_DEBUG
+                fprintf(stderr, "Pop: empty tag\n");
+#endif
+                
+            } else if (style == SCE_UDL_M_STAGC
+                       && curChar == '>') {
+                char *prev_tag_name = p_tagStack->top();
+#if OMIT_TAG_DEBUG
+                fprintf(stderr, "STAGC >: prev_tag_name: %s\n",
+                      prev_tag_name ? prev_tag_name : "<none>");
+#endif
+                if (prev_tag_name
+                    && is_member(prev_tag_name,
+                                 strlen(prev_tag_name),
+                                 html_no_close_tags)) {
+                    p_tagStack->pop();
+#if OMIT_TAG_DEBUG
+                    fprintf(stderr, "Pop: STAGC >: prev is html_no_close_tags\n");
+#endif
+                    --netChange; // will be flipped up later on, so this is neutral
+                }
+            }
+#if OMIT_TAG_DEBUG
+            fprintf(stderr, "Style:%d, curChar:%c\n", style, curChar);
+            p_tagStack->dump();
+#endif
+            //Force rebuild.
+        }
+    skip_tag_stack_adjustment:
+        if (style == lastStyle) {
+            j = currStyleStartIdx;
+        } else {
+            j = 0;
+            lastStyle = style;
+            currStyleStartIdx = -1;
+        }
+        for (; j <= flipper_count; j++) {
+            if (j == flipper_count) {
+                // Sentinel check -- means we don't have any flippers,
+                // so move forward
+                bool moved = false;
+                if (currStyleStartIdx == -1) {
+                    // In this case, there aren't any flippers for this style,
+                    // so move ahead to the start of the next style.
+                    while (pos + 1 < lineEndPos
+                           && (safeStyleAt(pos + 1, styler) == style)) {
+                        pos += 1;
+                        i += 1;
+                        moved = true;
+                    }
+                    currStyleStartIdx = 0;
+                }
+                if (!moved) {
+                    pos += 1;
+                    i += 1;
+                }
+                break;
+            }
+            Flipper *p_flipper = pp_Flippers[j];
+            int direction, amtMatched;
+            if (style < p_flipper->style) {
+                if (currStyleStartIdx == -1) {
+                    currStyleStartIdx = flipper_count;
+                }
+                i += 1;
+                pos += 1;
+                break;
+            } else if (style == p_flipper->style) {
+                if (currStyleStartIdx == -1) {
+                    currStyleStartIdx = j;
+                }
+                if (p_flipper->Match(&buf[i], style, pos, lineEndPos,
+                                     direction, amtMatched, styler)) {
+                    if (amtMatched == 0) {
+                        amtMatched += 1; // safety precaution.
+                    }
+                    i += amtMatched;
+                    pos += amtMatched;
+                    netChange += direction;
+                    break;
+                }
+            }
+        }
+    }
+    delete[] buf;
+    foldChange = netChange;
+}
+
+// A list of MainInfo's    
+
+class LexerInfoList {
+    private:
+    MainInfo *p_Head;
+    
+    public:
+    LexerInfoList() {
+        p_Head = NULL;
+    };
+    ~LexerInfoList() {
+        if (p_Head) {
+#if 0
+            fprintf(stderr, "udl: destructing LexerInfoList\n");
+#endif
+            MainInfo *p_CurrNode = p_Head;
+            MainInfo *p_NextNode;
+            while (p_CurrNode) {
+                p_NextNode = p_CurrNode->p_Next;
+                delete p_CurrNode;
+                p_CurrNode = p_NextNode;
+            };
+            p_Head = NULL;
+        }
+    };
+
+    MainInfo *Intern(char *p_rawSubLanguage) {
+        MainInfo *p_MI = Lookup(p_rawSubLanguage);
+        if (!p_MI) {
+            p_MI = new MainInfo(p_rawSubLanguage);
+            if (!p_MI) {
+                fprintf(stderr, "udl: ColouriseTemplate1Doc: couldn't create a MainInfo\n");
+                return NULL;
+            }
+            char *p_finalFileName;
+            bool free_subLanguage = false;
+            if (!unescapeFileName(p_rawSubLanguage, &p_finalFileName,
+                                  &free_subLanguage)) {
+                return NULL;
+            }
+#if 0
+            fprintf(stderr, "udl: ColouriseTemplate1Doc: loading sublanguage %s, \n",
+                    p_finalFileName);
+#endif
+            p_MI->Init(p_finalFileName);
+            if (free_subLanguage) {
+                delete[] p_finalFileName;
+            }
+            p_MI->p_Next = p_Head;
+            p_Head = p_MI;
+        }
+        return p_MI;
+    };
+    
+    private:
+    
+    MainInfo *Lookup(char *p_rawSubLanguage) {
+        MainInfo *p_CurrNode = p_Head;
+        while (p_CurrNode) {
+            if (p_CurrNode->p_raw_sublang_file
+                && !strcmp(p_rawSubLanguage, p_CurrNode->p_raw_sublang_file)) {
+                return p_CurrNode;
+            }
+            p_CurrNode = p_CurrNode->p_Next;
+        }
+        return p_CurrNode;
+    };
+
+    bool unescapeFileName(char	   *p_rawSubLanguage,
+                          char	  **pp_finalFileName,
+                          bool	   *p_free_subLanguage) {
+#if 0
+        fprintf (stderr, "strchr(p_subLanguage, '%%') => %s\n",
+                 strchr(p_rawSubLanguage, '%') ? "yes" : "no");
+#endif
+        if (strchr(p_rawSubLanguage, '%')) {
+#if 0
+            fprintf(stderr, "udl: ColouriseTemplate1Doc: need to url-unescape %s, \n",
+                    p_rawSubLanguage);
+#endif
+            // Write it in place, as we know there's enough memory.
+            char *p_new_lang_buf = new_strdup(p_rawSubLanguage);
+            if (!p_new_lang_buf) {
+                fprintf(stderr, "udl: ColouriseTemplate1Doc: out of memory\n");
+                return false;
+            }
+            char *p_new_lang = p_new_lang_buf;
+            const char *p_old_lang = p_rawSubLanguage;
+            const char *p_end_old_lang = p_rawSubLanguage + strlen(p_rawSubLanguage);
+            char conversion_buf[5];
+            conversion_buf[0] = '0';
+            conversion_buf[1] = 'x';
+            conversion_buf[4] = 0;
+            while (p_old_lang < p_end_old_lang) {
+                if (*p_old_lang == '%') {
+                    if (p_end_old_lang - p_old_lang < 3) {
+                        break;
+                    }
+                    conversion_buf[2] = *(p_old_lang + 1);
+                    conversion_buf[3] = *(p_old_lang + 2);
+                    int val = strtol(conversion_buf, NULL, 16);
+                    if (val) {
+                        *p_new_lang++ = (char) val;
+                        p_old_lang += 3;
+                    } else {
+                        // If we can't convert, leave it as a '%' char.
+                        *p_new_lang++ = *p_old_lang++;
+                    }
+                } else {
+                    *p_new_lang++ = *p_old_lang++;
+                }
+            }
+            *p_new_lang = 0;
+#if 0
+            fprintf(stderr, "udl: ColouriseTemplate1Doc: converted %s to %s, \n",
+                    p_rawSubLanguage, p_new_lang_buf);
+#endif
+            *pp_finalFileName = p_new_lang_buf;
+            *p_free_subLanguage = true;
+        } else {
+            *pp_finalFileName = p_rawSubLanguage;
+            *p_free_subLanguage = false;
+        }
+        return true;
+    };
+};
+
+
+// ****************************************************************
+// **************** End UDL_Tables.h classes ****************
+// ****************************************************************
+
+
+// This class is used by the enter and exit methods, so it needs
+// to be hoisted out of the function.
+
+class QuoteCls {
+    public:
+    int  Count;
+    char Up;
+    char Down;
+    QuoteCls() {
+        this->New();
+    }
+    void New() {
+        Count = 0;
+        Up    = '\0';
+        Down  = '\0';
+    }
+    void Open(char u) {
+        Count++;
+        Up    = u;
+        Down  = opposite(Up);
+    }
+    QuoteCls(const QuoteCls& q) {
+        // copy constructor -- use this for copying in
+        Count = q.Count;
+        Up    = q.Up;
+        Down  = q.Down;
+    }
+    QuoteCls& operator=(const QuoteCls& q) { // assignment constructor
+        if (this != &q) {
+            Count = q.Count;
+            Up    = q.Up;
+            Down  = q.Down;
+        }
+        return *this;
+    }
+            
+};
+
+class LexString {
+    private:
+    char *p_buf;
+    unsigned int buf_size;
+    int			curr_line;
+
+    public:
+    LexString() {
+        p_buf = NULL;
+        buf_size = 0;
+        curr_line = -1;
+    };
+    ~LexString() {
+        if (p_buf) {
+            delete[] p_buf;
+        }
+    };
+    int CurrLine() {
+        return curr_line;
+    };
+    char *Val() {
+        return p_buf;
+    };
+
+    bool SetLine(int pos, Accessor &styler) {
+        curr_line = styler.GetLine(pos);
+        int line_length = CurrLineLength(pos, styler);
+        if (!MakeSpace(line_length + 1)) {
+            curr_line = -1;
+            return false;
+        }
+        char *p_s = p_buf;
+        int line_start = styler.LineStart(curr_line);
+        int line_end = line_start + line_length;
+        for (int i = line_start; i < line_end; i++) {
+            *p_s++ = styler.SafeGetCharAt(i);
+        }
+        *p_s = 0;
+        return true;        
+    };
+    bool Init() {
+        buf_size = 256;
+        p_buf = new char[buf_size];
+        if (!p_buf) {
+            buf_size = 0;
+            return false;
+        }
+        return true;
+    };
+    private:
+    int CurrLineLength(int pos, Accessor &styler)
+    {
+        int docLength;
+        if (pos < 0 || pos >= (docLength = styler.Length())) {
+            return -1;
+        }
+        int currLine = styler.GetLine(pos);
+        int lineStart = styler.LineStart(currLine);
+        int nextLineStart = styler.LineStart(currLine + 1);
+        if (nextLineStart >= docLength) {
+            return docLength - lineStart + 1;
+        }
+        return nextLineStart - lineStart;
+    };
+    bool MakeSpace(unsigned int needed_len) {
+        if (buf_size < needed_len) {
+            unsigned int curr_buf_size = buf_size;
+            while (curr_buf_size < needed_len) {
+                curr_buf_size *= 2;
+            }
+            if (!p_buf) {
+                assert(0 && "In LexString::Set, p_buf is null");
+            } else {
+                delete[] p_buf;
+            }
+            p_buf = new char[curr_buf_size];
+            if (!p_buf) {
+                buf_size = 0;
+                return false;
+            }
+            buf_size = curr_buf_size;
+        }
+        return true;
+    };
+
+};
+
+static LexerInfoList LexerList;    
+
+// For table-driven lexers, we move back until we find a style
+// that maps to exactly one internal style.  Otherwise we move
+// to char 0, and use this table's initial style.
+
+// Move back looking for the first style 
+// Only look at the start of each line, because we need to 
+// count fold-changing constructs in each line as well.
+
+// Requirements:
+// 1. The color style at the start of the line must map
+//    to a unique internal style
+// 2. The color style on the line preceding it must be default,
+//    ruling out multi-line styles.
+
+// This is a conservative approach, forcing the lexer back to 
+// well-understood points.  Hopefully not to the beginning of
+// the buffer too often.
+
+// We set the initStyle to the default style for the current family.
+
+#if 0
+// Semi-useful helper, but can only be called once per sprintf
+static char* line_colon_col(int pos, Accessor &styler) {
+    static char buf[30];
+    int line = styler.GetLine(pos);
+    sprintf(buf, "%d:%d", line + 1, pos - styler.LineStart(line));
+    return buf;
+}
+#endif
+
+// Macros for manipulating the line-state
+
+#define LEXER_STATE_MASK	0xfff
+#define DELIMITER_MASK		0xfff
+#define PUSH_STATE_MASK		0x7f
+
+#define eol_state_from_line_state(state) ((state) & LEXER_STATE_MASK)
+#define delimiter_hash_from_line_state(state) ((state >> 12) & DELIMITER_MASK)
+#define push_stack_size_from_line_state(state) ((state >> 24) & PUSH_STATE_MASK)
+
+static int create_line_state(int push_stack_size,
+                             int state) {
+    if (state > LEXER_STATE_MASK) {
+        // Fake a reason not to accept this state.
+        state = LEXER_STATE_MASK;
+        push_stack_size += 1;
+    }
+    if (push_stack_size > PUSH_STATE_MASK) {
+        push_stack_size = PUSH_STATE_MASK;
+    }
+    // Delimiter hashes are added in update_line_state_from_delim
+    return ((push_stack_size << 24) | state);
+}
+
+#define update_line_state_from_delim(line_state, delimiter_hash) \
+    ((line_state) | (((delimiter_hash) & DELIMITER_MASK) << 12))
+
+// From koILinter.idl:
+#define DECORATOR_UDL_FAMILY_TRANSITION 18
+
+static void synchronizeDocStart(unsigned int& startPos,
+                                int &length,
+                                int &initState, // out only
+                                int &currFamily,
+                                Accessor &styler,
+                                MainInfo		   *p_MainInfo
+                                )
+{
+    int startLine;
+    int newPos = startPos;
+    int lineEndPos;
+    // Avoid moving back to the beginning when in a nested state
+    int nested_lines_to_skip = 24;
+    if (newPos > 0) {
+        // Start at the line previous to the line the lexer's invoked at.
+        startLine = styler.GetLine(newPos);
+        // if startLine == 0, lineEndPos ends up at -1, but it's
+        // never consulted in this case, so it's ok
+        lineEndPos = styler.LineStart(startLine) - 1;
+        startLine -= 1;
+        newPos = styler.LineStart(startLine);
+    } else {
+        lineEndPos = 0; // Not used, squelch an OS X compiler warning
+        startLine = -1;
+    }
+    if (startLine > 0) {
+        styler.Flush();
+        for(;;) {
+
+            // Move up the buffer looking for a line we can stop at,
+            // and restore the internal lexer state
+
+            int currStyle;
+            currStyle = actual_style(styler.StyleAt(newPos));
+            currFamily = p_MainInfo->StyleToFamily(currStyle);
+            int familyDefaultStyle = p_MainInfo->GetFamilyDefaultColor(currFamily);
+            int prevLineEndStyle = actual_style(styler.StyleAt(lineEndPos));
+            if (prevLineEndStyle == familyDefaultStyle) {
+                int prevLineState = styler.GetLineState(startLine - 1);
+                if (delimiter_hash_from_line_state(prevLineState)) {
+#if 0
+                    fprintf(stderr, "Rejecting line %d because of delim.\n",
+                            startLine - 1);
+#endif
+                } else if (--nested_lines_to_skip >= 0
+                           && push_stack_size_from_line_state(prevLineState)) {
+#if 0
+                    if (nested_lines_to_skip == 23
+                        || nested_lines_to_skip == 0) {
+                        fprintf(stderr, "Rejecting line %d because it's in a push-state.\n",
+                                startLine - 1);
+                    }
+#endif
+                } else {
+#if 0
+                    fprintf(stderr, "udl: synchronizeDocStart: stopping at line %d => %d, pos %d => %d, docLength %d, family %d, color %d\n",
+                            styler.GetLine(startPos),
+                            startLine, startPos, newPos, length + (startPos - newPos),
+                            currFamily,
+                            familyDefaultStyle);
+#endif
+                    p_MainInfo->SetCurrFamily(currFamily);
+                    initState = eol_state_from_line_state(prevLineState);
+                    length += (startPos - newPos);
+                    startPos = newPos;
+                    return;
+                }
+            } else {
+#if 0
+                fprintf(stderr, " rejecting line %d -- prev line ends with style %d\n",
+                        startLine, prevLineEndStyle);
+#endif
+            }
+            if (--startLine <= 0) {
+                break;
+            }
+            lineEndPos = newPos - 1;
+            newPos = styler.LineStart(startLine);
+        }
+    }
+    length += startPos;
+    startPos = 0;
+    // By default, start in the markup family
+    currFamily = TRAN_FAMILY_MARKUP;
+    p_MainInfo->SetCurrFamily(currFamily);
+    initState = p_MainInfo->GetCurrFamily()->DefaultStartState();
+}
+
+#if 0
+static char * showChar(char c) {
+    static char buf[10];
+    if (c < 0) {
+        sprintf(buf, "\\x%02x", 256 + c);
+    } else if (c <= 32) {
+        if (c == ' ') {
+            buf[0] = c;
+            buf[1] = 0;
+        } else if (c == '\r') {
+            buf[0] = '\\';
+            buf[1] = 'r';
+            buf[2] = 0;
+        } else if (c == '\n') {
+            buf[0] = '\\';
+            buf[1] = 'n';
+            buf[2] = 0;
+        } else {
+            sprintf(buf, "\\x%02x", c);
+        }
+    } else {
+        buf[0] = c;
+        buf[1] = 0;
+    }
+    return buf;
+}
+#endif
+
+static void doColorAction(int	    styleNum,
+                          bool		no_keyword,
+                          int		pos,
+                          FamilyInfo	*p_FamilyInfo,
+                          MainInfo   *p_MainInfo,
+                          Accessor &styler
+                          )
+{
+    if (styleNum >= 0) {
+        // Look to see if we should color this as a keyword instead
+        if (!no_keyword && styleNum == p_FamilyInfo->GetIdentifierStyle()) {
+            char s[100];
+            GetCurrent(s, sizeof(s), pos - 1, styler);
+            if (s[0]) {
+                WordList &keywords = p_FamilyInfo->GetWordList();
+                if (keywords.InList(s)) {
+                    int newStyleNum = p_FamilyInfo->GetKeywordStyle();
+                    if (newStyleNum >= 0) {
+                        styleNum = newStyleNum;
+                    }
+                }
+            }
+        }
+        int lastStyledPos = styler.GetStartSegment() - 1;
+        if (lastStyledPos < 0) {
+            lastStyledPos = 0;
+        }
+        styler.ColourTo(pos - 1, styleNum);
+        styler.Flush();
+        int old_style = styler.StyleAt(lastStyledPos);
+        int old_family = p_MainInfo->StyleToFamily(styler.StyleAt(lastStyledPos));
+        int new_family = p_MainInfo->StyleToFamily(styleNum);
+        if (old_family != new_family) {
+            int nfpos = lastStyledPos + 1;
+#if 0
+            fprintf(stderr, "UDL: trans from style %d=>%d, family #%d=>%d at %d=>%d (char '%s') (%d:%d), final pos: %d\n",
+                    old_style, styleNum,
+                    old_family, new_family,
+                    nfpos, nfpos + 1,
+                    showChar(styler[nfpos]),
+                    styler.GetLine(nfpos),
+                    nfpos - styler.LineStart(styler.GetLine(nfpos)),
+                    pos - 1);
+#endif
+            styler.IndicatorFill(nfpos, nfpos + 1,
+                                 DECORATOR_UDL_FAMILY_TRANSITION, 1);
+        }
+    }
+}
+
+static void doActions(Transition     *p_TranBlock,
+                      int      &oldPos,
+                      int      &newPos,
+                      int       ,//lengthDoc,
+                      int      &istate, // internal state to move to
+                      int	   &curr_family,
+                      MainInfo   *p_MainInfo,
+                      BufferStateInfo *p_BufferStateInfo,
+                      Accessor &styler
+                      )
+{
+    if (!p_TranBlock) {
+        assert(p_TranBlock && "doActions got null tran-block");
+        return;
+    }
+    FamilyInfo *p_FamilyInfo = p_MainInfo->GetCurrFamily();
+    if (!p_TranBlock->token_check && oldPos > 0) {
+        doColorAction(p_TranBlock->upto_color, p_TranBlock->no_keyword, oldPos, p_FamilyInfo, p_MainInfo, styler);
+    }
+    doColorAction(p_TranBlock->include_color, p_TranBlock->no_keyword, newPos, p_FamilyInfo, p_MainInfo, styler);
+    int origOldPos = oldPos;
+    if (p_TranBlock->search_type == TRAN_SEARCH_EMPTY) {
+        // leave oldPos unchanged
+    } else if (p_BufferStateInfo->do_redo) {
+        // leave oldPos unchanged
+        // oldPos = newPos - 1;
+    } else {
+        oldPos = newPos;
+    }
+    int push_pop_state = p_TranBlock->push_pop_state;
+
+    // Determine if we hit end-of-line, and should redo
+    int eol_state = p_BufferStateInfo->curr_eol_transition;
+    if (eol_state) {
+        int start_line = styler.GetLine(origOldPos);
+        int end_line   = styler.GetLine(newPos);
+        // Are we going to use the eol-state this time?
+        int nextOldPos;
+        if (end_line > start_line) {
+            oldPos = styler.LineStart(start_line + 1);
+#if 0
+            fprintf(stderr, "#1: start-line=%d, end-line=%d, setting oldPos=%d=>%d\n",
+                    start_line, end_line, origOldPos, oldPos);
+#endif
+        } else if (origOldPos >= (nextOldPos =
+                                  styler.LineStart(start_line + 1)) - 1
+                   && newPos >= nextOldPos) {
+            oldPos = nextOldPos;
+#if 0
+            fprintf(stderr, "#2: start-line=%d, end-line=%d, setting oldPos=%d=>%d\n",
+                    start_line, end_line, origOldPos, oldPos);
+#endif
+        } else {
+            eol_state = 0;
+        }
+    }
+
+    if (p_TranBlock->clear_current_delimiter) {
+        p_BufferStateInfo->current_delimiter.clear();
+    }
+
+    int new_state = 0;
+    int new_family = curr_family; // ms vc++ 6 can't follow when this var
+    // isn't initialized and isn't used, so set it to an innocuous value
+
+    if (p_TranBlock->eol_target_state) {
+        if (!p_BufferStateInfo->curr_eol_transition) {
+            p_BufferStateInfo->curr_eol_transition = p_TranBlock->eol_target_state;
+        } else if (p_BufferStateInfo->curr_eol_transition != p_TranBlock->eol_target_state) {
+            // Currently if we have a non-zero eol-target state that's
+            // different from the one specified in an at_eol directive,
+            // we ignore it.
+            fprintf(stderr, "Current EOL setting is 0x%08x, ignoring 0x%08x\n",
+                    p_BufferStateInfo->curr_eol_transition,
+                    p_TranBlock->eol_target_state);
+        }
+    }
+    // Now look to see if we need to act on a pending EOL-state.
+    if (eol_state != 0) {
+        new_state = SF_GET_STATE(eol_state);
+        new_family = SF_GET_FAMILY(eol_state);
+        // Set the global state to 0.
+        p_BufferStateInfo->curr_eol_transition = 0;
+        // This deliberately squelches any pushing that would be done here.
+        //XXX: Pop all push-state transitions pushed since the eol_state
+        // thing was set.
+    } else if (push_pop_state > 0) {
+        p_MainInfo->PushState(push_pop_state);
+    } else if (push_pop_state == -1) {
+        int tmp = p_MainInfo->PopState();
+        new_state = SF_GET_STATE(tmp);
+        new_family = SF_GET_FAMILY(tmp);
+    }
+    if (!new_state) {
+        new_state = p_TranBlock->new_state;
+        if (new_state >= 1) {
+            new_family = p_TranBlock->new_family;
+        }
+    }
+    if (new_state >= 1 && new_state < p_MainInfo->NumTransitions()) {
+#if 0
+        fprintf(stderr, "state tran %d=>%d at pos %d [%d:%d] => %d\n",
+                istate,
+                new_state,
+                origOldPos,
+                styler.GetLine(origOldPos),
+                origOldPos - styler.LineStart(styler.GetLine(origOldPos)),
+                newPos);
+#endif
+        istate = new_state;
+        if (new_family >= 0 && curr_family != new_family) {
+            curr_family = new_family;
+            p_MainInfo->SetCurrFamily(curr_family);
+        }
+    }
+}
+/*
+ * Write no more than bufCapacity characters into the buffer:
+ * If oldPos <= bufCapacity - 2, stopPoint will be 0, and there's
+ * no problem.
+ * 
+ * Othewise, we set stopPoint = oldPos - bufCapacity + 2;
+ * segStart >= stopPoint
+ * Then we try to write chars segStart ... oldPos inclusive
+ * oldPos - segStart + 1 >=
+ * oldPos - stopPoint + 1 ==
+ * oldPos - (oldPos - bufCapacity + 2) + 1 ==
+ * bufCapacity - 1
+ * which leaves us room for the null byte.
+ *
+ */ 
+
+static void getSegmentParts(char *buf,
+                            int bufCapacity,
+                            int &segStart,
+                            int oldPos,
+                            int this_style,
+                            Accessor		&styler)
+{
+    // Allow 1 for styler[oldPos], 1 for the null byte
+    int stopPoint = oldPos - bufCapacity + 2; 
+    if (stopPoint < 0) {
+        stopPoint = 0;
+    }
+    for (segStart = oldPos;
+         segStart > stopPoint && actual_style(styler.StyleAt(segStart - 1)) == this_style;
+         segStart -= 1) {
+        //EMPTY
+    }
+    char *p_s;
+    int i;
+    for (i = segStart, p_s = buf; i <= oldPos; i++) {
+        *p_s++ = styler[i];
+    }
+    *p_s = 0;
+}
+                            
+static inline int columnStartPos(int pos, Accessor &styler) {
+    return pos - styler.LineStart(styler.GetLine(pos));
+}
+
+// We do this when we've matched a conditional string, like 
+// '/' if preferRE : paint(upto, CSL_DEFAULT), => IN_CSL_REGEX
+
+// Return true if there's no test, or if it passes
+// The idea is to walk backwards from the current point,
+// looking at each sequence of styled text, and determining
+// what to do next.
+
+static bool doLookBackTest(Transition      *p_TranBlock,
+                           int				oldPos,
+                           MainInfo		   *p_MainInfo,
+                           Accessor		&styler)
+{
+    if (oldPos <= 0) return true;
+    if (!p_TranBlock->token_check) return true;
+
+    FamilyInfo	*p_FamilyInfo = p_MainInfo->GetCurrFamily();
+    if (!p_FamilyInfo) {
+        assert(0 && "Can't get family info");
+        return true;
+    }
+
+    /* If there's an upto thing, color it now, as we need to
+     * test against the text to the left.
+     */
+    doColorAction(p_TranBlock->upto_color, p_TranBlock->no_keyword, oldPos, p_FamilyInfo, p_MainInfo, styler);
+    LookBackTests  *p_LookBackTests = p_FamilyInfo->GetLookBackTests();
+    if (!p_LookBackTests) return true;
+    oldPos--;
+    char buf[200];
+    int segStart;
+    styler.Flush();
+    while (oldPos > 0) {
+        int this_style = actual_style(styler.StyleAt(oldPos));
+        if (!p_LookBackTests->StyleInRange(this_style)) {
+            // We're at the beginning of a subfamily,
+            // so make the same assumption we make at the start of the doc
+            return true;
+        }
+        getSegmentParts(buf, sizeof(buf)/sizeof(buf[0]),
+                        segStart, oldPos,
+                        this_style, styler);
+        int action = -1;
+        int num_tests = p_LookBackTests->GetTestCount();
+        for (int i = 0; action == -1 && i < num_tests; i++) {
+            LookBackTestObj *p_LBTest = p_LookBackTests->GetTest(i);
+            if (!p_LBTest || p_LBTest->Style() != this_style) {
+                continue;
+            }
+            int list_type = p_LBTest->Type();
+            if (list_type == LBTEST_LIST_ALL) {
+                action = p_LBTest->Action();
+            } else if (list_type == LBTEST_LIST_KEYWORDS) {
+                if (p_LBTest->InKeywords(buf)) {
+                    action = p_LBTest->Action();
+                }
+            } else if (list_type == LBTEST_LIST_STRINGS) {
+                // for each string in the list of strings
+                // if we're looking at it, all one style, 
+                // go do the action.
+
+                int segLen = (int) strlen(buf);
+                char **pp_StringList = p_LBTest->Strings();
+                if (!pp_StringList)
+                    continue;
+                while (*pp_StringList) {
+                    int thisLen = (int) strlen(*pp_StringList);
+                    if (thisLen <= segLen
+                        && !strncmp(*pp_StringList,
+                                    buf + (segLen - thisLen), thisLen)) {
+                        // Adjust segStart in case we're skipping this one
+                        segStart = oldPos - segLen;
+                        action = p_LBTest->Action();
+                        break;
+                    }
+                    pp_StringList++;
+                }
+            }
+        } // end for loop
+        if (action == -1) {
+            action = p_LookBackTests->GetDefault(this_style);
+        }
+        if (action == LBTEST_ACTION_REJECT) {
+            return false;
+        } else if (action == LBTEST_ACTION_ACCEPT) {
+            return true;
+        } else {
+            // Skip
+            oldPos = segStart - 1;
+        }
+    }  // end while loop
+    // If we moved to the beginning of the doc, assume we'll transition
+    return true;
+}
+                           
+
+static bool lookingAtString(const char   *p_target,
+                            int     oldPos,
+                            int    &newPos,
+                            int     lengthDoc,
+                            Accessor &styler)
+{
+    int targetLen = (int) strlen(p_target);
+    if (lengthDoc - oldPos < targetLen) {
+        // Not enough space
+        return false;
+    }
+    const char *s = p_target;
+    while (*s && oldPos < lengthDoc) {
+        if (*s != styler[oldPos]) {
+            return false;
+        }
+        s += 1;
+        oldPos += 1;
+    }
+    newPos = oldPos;
+    return true;
+}
+
+static bool lookingAtMatch(
+#ifdef DEBUG
+                           char   *p_origPattern,
+#endif
+                           pcre    *p_compiledPattern,
+                           int      oldPos,
+                           int     &newPos,
+                           int      ,//lengthDoc,
+                           LexString   *p_CurrTextLine,
+                           MainInfo		   *p_MainInfo,
+                           BufferStateInfo       *p_BufferStateInfo,
+                           Accessor &styler)
+{
+    if (!p_compiledPattern) {
+        return false;
+    }
+    int rc;
+    int currLine = styler.GetLine(oldPos);
+    int currLineStart = styler.LineStart(currLine);
+    if (p_CurrTextLine->CurrLine() != currLine) {
+        rc = (int) p_CurrTextLine->SetLine(oldPos, styler);
+        if (!rc) {
+            return false;
+        }
+    }
+    char *p_subject = p_CurrTextLine->Val();
+    rc = pcre_exec(p_compiledPattern,
+                       NULL, // no extra data - we didn't study the pattern
+                       p_subject,
+                       (int) strlen(p_subject),
+                       oldPos - currLineStart,
+                       PCRE_ANCHORED, /* default options */
+                       p_MainInfo->ovector,   /* output vector for substring information */
+                       p_MainInfo->ovec_count);/* number of elements in the output vector */
+    bool res;
+    if (rc < 0) {
+        res = false;
+    } else if (p_MainInfo->ovector[0] == oldPos - currLineStart) {
+        res = true;
+        int num_chars_matched = p_MainInfo->ovector[1] - p_MainInfo->ovector[0];
+        newPos = oldPos + num_chars_matched;
+        p_BufferStateInfo->num_captured_groups = rc - 1;
+    } else {
+        res = false;
+    }
+    return res;
+}
+
+// Using strchr and pointer arithmetic might be more elegant, but
+// it's probably slower to run.
+static char getOpposite(char ch) {
+    switch (ch) {
+    case '[': return ']';
+    case '{' : return '}';
+    case '(': return ')';
+    case '<': return '>';
+    default: return ch;
+    }
+}
+
+static int simpleHash(unsigned int maxVal, const char *delim) {
+    unsigned int h = 0;
+    const char *p = delim;
+    while (*p) {
+        h += (h << 1) ^ *p++;
+        if (h > maxVal) {
+            unsigned int diff = h & ~maxVal;
+            while (diff && (diff & 1) == 0) {
+                diff >>= 2;
+            }
+            h = (h & maxVal) | diff;
+        }
+    }
+    return (int) h;
+}
+
+static void setNewDelimiter(Transition      *p_TranBlock,
+                            MainInfo	    *p_MainInfo,
+                            BufferStateInfo   *p_BufferStateInfo,
+                            LexString   *p_CurrTextLine,
+                            int , // i,
+                            Accessor & //styler
+                            )
+{
+    int do_opposite = SF_GET_STATE(p_TranBlock->target_delimiter);
+    int group_num = SF_GET_FAMILY(p_TranBlock->target_delimiter);
+    if (group_num <= p_BufferStateInfo->num_captured_groups) {
+        int start_delim = p_MainInfo->ovector[2 * group_num];
+        int end_delim = p_MainInfo->ovector[2 * group_num + 1];
+        char *p_delim_start = &(p_CurrTextLine->Val()[start_delim]);
+        bool succeeded;
+        int len = end_delim - start_delim;
+        char c = p_delim_start[len];
+        if (!do_opposite) {
+            p_delim_start[len] = 0;
+            p_BufferStateInfo->current_delimiter = std::string(p_delim_start, len);
+            p_delim_start[len] = c;
+            succeeded = true;
+        } else if (end_delim - start_delim != 1) {
+            fprintf(stderr,
+                    "udl: can't capture delimiter [%d,%d] on [%s]\n",
+                    start_delim, end_delim, p_CurrTextLine->Val());
+            succeeded = false;
+        } else {
+            p_BufferStateInfo->current_delimiter = std::string(1, getOpposite(*p_delim_start));
+            succeeded = true;
+        }
+    }
+}
+
+#if UDL_DEBUG_TIME
+static void ShowElapsedTime(const char *where,
+                            struct timeval& t1,
+                            struct timeval& t2) {
+    int secDiff = (int) (t2.tv_sec - t1.tv_sec);
+    int msecDiff = (int) (t2.tv_usec - t1.tv_usec);
+    if (msecDiff < 0) {
+        msecDiff += 1000000;
+        secDiff -= 1;
+    }
+    fprintf(stderr, "UDL fold calc time (%s): %f msecs\n",
+            where,
+            1000 * secDiff + msecDiff/1000.0);
+}
+#endif
+
+static void ColouriseTemplate1Doc(unsigned int startPos,
+                                  int length,
+                                  int
+#if UDL_DEBUG
+                                  initStyle
+#endif
+                                  ,
+                                  WordList *keywordlists[],
+                                  Accessor &styler)
+{
+#if UDL_DEBUG
+    fprintf(stderr,
+            "udl: ColouriseTemplate1Doc(startPos=%d, length=%d, lines %d:%d, initStyle=%d\n",
+            startPos,
+            length,
+            styler.GetLine(startPos),
+            styler.GetLine(startPos + length),
+            initStyle);
+#endif
+
+#ifdef LOG_MEM
+    if (!fp_log) {
+        OpenFPLog();
+    }
+    LogEvent(true, "ColouriseTemplate1Doc", &styler);
+#endif
+
+#if UDL_DEBUG_TIME
+    struct timeval t1, t2;
+    gettimeofday(&t1, NULL);
+#endif
+#if UDL_WINDEBUG
+    time_t t1, t2;
+    t1 = time(NULL);
+#endif
+    bool rc;
+    WordList &wl = *keywordlists[0];
+    char *p_subLanguage = wl.words[0];
+    if (!p_subLanguage || !p_subLanguage[0]) {
+        // This happens as part of a fallback in
+        // koTemplateLanguageBase.py::koTemplateLanguage.get_lexer
+        // when no lexres can be found.  This is the code:
+        //      lex.setKeywords(0, [])
+        // The result is that nothing gets colorized, but we
+        // don't need a message.
+        
+        //fprintf(stderr, "udl: ColouriseTemplate1Doc: no sublanguage\n");
+        styler.ColourTo(length, 0);
+        return;
+    }
+    
+    MainInfo *p_MainInfo = LexerList.Intern(p_subLanguage);
+    if (!p_MainInfo) {
+        fprintf(stderr, "udl: ColouriseTemplate1Doc: couldn't create a MainInfo\n");
+        assert(0 && "Can't create a MainInfo");
+        return;
+    }
+    if (!p_MainInfo->IsReady()) {
+        rc = false;
+    } else {
+        rc = true;
+    }
+    if (!rc) {
+        styler.ColourTo(length, 0);
+        fprintf(stderr, "udl: ColouriseTemplate1Doc: failed to load the engine\n");
+        return;
+    }
+    
+    int curr_family;
+    TransitionTable  *p_TransitionTable = p_MainInfo->GetTable();
+#if 0
+    int origStartPos = startPos;
+    int origLength = length;
+#endif
+    int istate; // the internal state
+    synchronizeDocStart(startPos, length, istate, curr_family,
+                        styler, // ref args
+                        p_MainInfo
+                        );
+    FamilyInfo		 *p_FamilyInfo = p_MainInfo->GetCurrFamily();
+    if (!p_FamilyInfo) {
+        fprintf(stderr, "udl: ColouriseTemplate1Doc: Can't get family info\n");
+        assert(0 && "Can't get family info");
+        return;
+    }
+
+    if (length == 0) {
+        return;
+    }
+#if 0
+    int origLine = styler.GetLine(origStartPos);
+    int currLine = styler.GetLine(startPos);
+    fprintf(stderr,
+            "udl: ColouriseTemplate1Doc -- sync moved from %d[%d:%d](%d) to %d[%d:%d](%d), internal state %d\n",
+            
+            origStartPos,
+            origLine + 1,
+            origStartPos - styler.LineStart(origLine),
+            origLength,
+            startPos,
+            currLine + 1,
+            startPos - styler.LineStart(currLine),
+            length,
+            istate);
+#endif
+
+    LexString	   *p_CurrTextLine = new LexString;
+    if (!p_CurrTextLine) {
+        fprintf(stderr, "udl: out of memory: failed to allocate a LexString\n");
+        return;
+    } else if (!p_CurrTextLine->Init()) {
+        fprintf(stderr, "udl: failed to init the current line tracker\n");
+        delete p_CurrTextLine;
+        return;
+    } else if (!p_CurrTextLine->SetLine(startPos, styler)) {
+        fprintf(stderr, "udl: failed to setup the line tracker at pos %d\n",
+                startPos);
+        delete p_CurrTextLine;
+        return;
+    }
+
+    TransitionInfo *p_TransitionInfo;
+    Transition     *p_TranBlock;    
+    BufferStateInfo *p_BufferStateInfo = new BufferStateInfo;
+    if (!p_BufferStateInfo) {
+        fprintf(stderr, "udl: out of memory: failed to allocate a BufferStateInfo\n");
+        delete p_CurrTextLine;
+        return;
+    }
+    char ch;
+    int lengthDoc = startPos + length;
+    int totalDocLength = styler.Length();
+    int i, newPos;
+    int lineStartUpdateState = styler.GetLine(startPos) - 1;
+    if (lineStartUpdateState < 0) lineStartUpdateState = 0;
+    int redoCount = 0;
+    const int redoLimit = 1000;
+
+    char lexerMask = 0x3f; // 6 bits
+
+    styler.StartAt(startPos, lexerMask);
+    styler.StartSegment(startPos);
+    if (lengthDoc > 1) {
+        // If there's an indicator at the very start of this line,
+        // leave it in -- we're not going to rediscover the transition.
+        styler.IndicatorFill(startPos + 1, lengthDoc - 1,
+                             DECORATOR_UDL_FAMILY_TRANSITION, 0);
+        if (startPos == 0) {
+            // Put an indicator at the start
+            styler.IndicatorFill(0, 1,
+                                 DECORATOR_UDL_FAMILY_TRANSITION, 1);
+        }
+    }
+    i = startPos;
+    for (;;) {
+        ch = styler.SafeGetCharAt(i);
+        if (styler.IsLeadByte(ch)) {
+            i += 1;
+            continue;
+        }
+        // set the line-state, to force further updates
+        // Update the line-state if we need to
+        // This is why we can't use a loop like
+        // for (i = startPos; i < lengthDoc; i++) : lengthDoc might change.
+        
+        int lineCurrent = styler.GetLine(i);
+        if (lineStartUpdateState < lineCurrent) {
+            for (int iLine = lineStartUpdateState; iLine < lineCurrent; iLine++) {
+                int oldLineState = styler.GetLineState(iLine);
+                int currStackSize = p_MainInfo->StateStackSize();
+                int newLineState = create_line_state(currStackSize,
+                                                     istate);
+                
+                // If we have an active delimiter, set the line-state
+                // based on a hash of it.  Otherwise set it to the current style.
+                if (p_BufferStateInfo->current_delimiter[0]) {
+                    // Create a hash of the delimiter, and bit-or it in based
+                    // on the current state
+                    unsigned int delimHash = (simpleHash(DELIMITER_MASK,
+                                                p_BufferStateInfo->current_delimiter.c_str())
+                                     & DELIMITER_MASK);
+                    newLineState = update_line_state_from_delim(newLineState,
+                                                                delimHash);
+                    if (oldLineState != newLineState && iLine == lineCurrent - 1) {
+                        // We changed delimiters, so force at least another line
+                        int nextLine = lineCurrent + 1;
+                        int nextLinePos = styler.LineStart(nextLine);
+                        // update the target
+                        if (lengthDoc < nextLinePos) {
+                            int newLengthDoc = nextLinePos < totalDocLength ? nextLinePos : totalDocLength;
+#if 0
+                            fprintf(stderr,
+                                    "Need to keep lexing, from %d to %d\n",
+                                    lengthDoc, newLengthDoc);
+#endif
+                            lengthDoc = newLengthDoc;
+                        }
+                    }
+                }
+                styler.SetLineState(iLine, newLineState);
+            }
+            lineStartUpdateState = lineCurrent;
+        }
+
+        if (i >= lengthDoc) {
+            break;
+        }
+
+        // Time to enter the engine
+        p_TransitionInfo = p_TransitionTable->Get(istate);
+        if (!p_TransitionInfo) {
+            // No point continuing ... there's no table info
+            break;
+        }
+        p_TranBlock = p_TransitionInfo->First();
+        if (!p_TranBlock) {
+            assert(p_TranBlock && "No transition block for this state .. bail out");
+            // Again, no point continuing, as we're stuck as this istate
+            break;
+        }
+        bool passedPart1 = false;
+        for (; p_TranBlock; p_TranBlock = p_TranBlock->Next()) {
+            if (p_TranBlock->search_type == TRAN_SEARCH_STRING) {
+                if (lookingAtString(p_TranBlock->p_search_string,
+                                    i, newPos, lengthDoc, styler)) {
+#if 0
+                    fprintf(stderr, "Matched [%s] at pos %d\n",
+                            p_TranBlock->p_search_string, i);
+#endif
+                    passedPart1 = true;
+                }
+            } else if (p_TranBlock->search_type == TRAN_SEARCH_REGEX) {
+                if (lookingAtMatch(
+#ifdef DEBUG
+                                   p_TranBlock->p_search_string,
+#endif
+                                   p_TranBlock->p_pattern,
+                                   i, newPos, lengthDoc, p_CurrTextLine,
+                                   p_MainInfo, p_BufferStateInfo,
+                                   styler)) {
+#if 0
+                    fprintf(stderr, "Matched [%s] at pos %d\n",
+                            p_TranBlock->p_search_string, i);
+#endif
+                    passedPart1 = true;
+                }
+            } else {
+                assert(p_TranBlock->search_type == TRAN_SEARCH_DELIMITER);
+                if (p_BufferStateInfo->current_delimiter[0]
+                    && lookingAtString(p_BufferStateInfo->current_delimiter.c_str(),
+                                       i, newPos, lengthDoc, styler)) {
+                    passedPart1 = true;
+#if 0
+                    fprintf(stderr, "keeping delimiter %s: %s\n",
+                            p_BufferStateInfo->current_delimiter.c_str(),
+                            p_TranBlock->keep_current_delimiter ? "true" : "false");
+#endif
+                    if (!p_TranBlock->keep_current_delimiter) {
+                        p_BufferStateInfo->current_delimiter.clear(); // can't undo
+                    }
+                }
+            }
+            if (passedPart1 && doLookBackTest(p_TranBlock, i, p_MainInfo,
+                                              styler)) {
+                if (p_TranBlock->search_type == TRAN_SEARCH_REGEX
+                    && p_TranBlock->target_delimiter) {
+                    setNewDelimiter(p_TranBlock, p_MainInfo,
+                                    p_BufferStateInfo,
+                                    p_CurrTextLine, i, styler);
+                }
+                break;
+            } else {
+                p_BufferStateInfo->num_captured_groups = 0;
+                passedPart1 = false;
+            }
+        }
+        if (!p_TranBlock) {
+            p_TranBlock = p_TransitionInfo->GetEmptyInfo();
+        }
+        if (p_TranBlock) {
+            // Watch out for infinite-redo loops
+            if (p_TranBlock->do_redo && ++redoCount > redoLimit) {
+                int line = styler.GetLine(i);
+                fprintf(stderr,
+                        "udl: looks like there's an infinite redo-loop at position %d (%d:%d), matching (%s) ... breaking it\n",
+                        i, line + 1, i + 1 - styler.LineStart(line),
+                        p_TranBlock->p_search_string);
+                p_BufferStateInfo->do_redo = false;
+                doActions(p_TranBlock, i, newPos, lengthDoc,
+                          istate, curr_family, p_MainInfo, p_BufferStateInfo,
+                          styler);
+                p_BufferStateInfo->do_redo = p_TranBlock->do_redo;
+                redoCount = 0;
+            } else {
+                int oldPos = i;
+                p_BufferStateInfo->do_redo = p_TranBlock->do_redo;
+                doActions(p_TranBlock, i, newPos, lengthDoc,
+                          istate, curr_family, p_MainInfo, p_BufferStateInfo,
+                          styler);
+                if (oldPos != i) {
+                    redoCount = 0;
+                }
+            }
+        } else {
+            ++i;
+            redoCount = 0;
+        }
+    }
+    // Check end-of-buffer conditions
+    p_TransitionInfo = p_TransitionTable->Get(istate);
+    // Coding it this way because VC++ issues warning C4706:
+    // assignment within conditional expression
+    if (p_TransitionInfo) {
+        p_TranBlock = p_TransitionInfo->GetEOFInfo();
+        if (p_TranBlock) {
+            newPos = lengthDoc;
+            doActions(p_TranBlock, i, newPos, lengthDoc, istate,
+                      curr_family, p_MainInfo, p_BufferStateInfo,
+                      styler);
+        }
+    }
+    delete p_CurrTextLine;
+    delete p_BufferStateInfo;
+    LogEvent(false, "ColouriseTemplate1Doc", &styler);
+#if UDL_DEBUG_TIME
+    gettimeofday(&t2, NULL);
+    ShowElapsedTime("ColouriseTemplate1Doc", t1, t2);
+#endif
+#if UDL_DEBUG
+    fprintf(stderr, "<< udl: ColouriseTemplate1Doc\n");
+#endif
+#if UDL_WINDEBUG
+    t2 = time(NULL);
+    fprintf(stderr, "ColouriseTemplate1Doc: %d secs\n", t2 - t1);
+#endif
+}
+
+static bool lookingAtXMLDocument(Accessor &styler) {
+    if (styler.Length() < 6) return true;  // doens't matter too much
+    if (styler.Length() > 6
+        && styler[0] == '<'
+        && styler[1] == '?'
+        && styler[2] == 'x'
+        && styler[3] == 'm'
+        && styler[4] == 'l'
+        && styler[5] == ' ') {
+        return true;
+    }
+    return false;
+}
+
+static void FoldUDLDoc(unsigned int startPos, int length, int
+#if UDL_DEBUG
+                       initStyle
+#endif
+                       ,
+                      WordList *keywordlists[], Accessor &styler)
+{
+#if UDL_DEBUG
+    fprintf(stderr,
+            ">> udl: FoldUDLDoc(startPos=%d, length=%d, initStyle=%d\n",
+            startPos,
+            length, initStyle);
+#endif
+#ifdef LOG_MEM
+    if (!fp_log) {
+        OpenFPLog();
+    }
+    LogEvent(true, "FoldUDLDoc", &styler);
+#endif
+    MainInfo *p_MainInfo = LexerList.Intern((*(keywordlists[0])).words[0]);
+    if (!p_MainInfo || !p_MainInfo->IsReady()) {
+        return;
+    }
+    StringStack *p_tagStack;
+    int lastLine;
+    //XXX: Can't use a property on the lexer, since many languages
+    // share the same lexer, so this should really  be controlled with
+    // a UDL declaration.
+    if (!lookingAtXMLDocument(styler)) {
+        p_tagStack = new StringStack;
+        lastLine = styler.GetLine(styler.Length());
+    } else {
+        p_tagStack = NULL;
+        lastLine = 0;
+    }
+    const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+    // bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+    int curr_family;
+    int istate; // the internal state
+    synchronizeDocStart(startPos, length, istate, curr_family,
+                        styler, // ref args
+                        p_MainInfo
+                        );
+    FamilyInfo		 *p_FamilyInfo = p_MainInfo->GetCurrFamily();
+    if (!p_FamilyInfo) {
+        assert(0 && "Can't get family info");
+        return;
+    }
+
+    if (length == 0)
+        return;
+
+    // Variables to allow folding.
+    unsigned int endPos = startPos + length;
+    bool hasNonSpace;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelPrev = startPos == 0 ? 0 : (styler.LevelAt(lineCurrent)
+                                         & SC_FOLDLEVELNUMBERMASK
+                                         & ~SC_FOLDLEVELBASE);
+    int levelCurrent = levelPrev;
+    int lineNo;
+    int lineStart = lineCurrent;
+    int lineEnd = styler.GetLine(endPos);
+    int startLinePos;
+    int endLinePos = styler.LineStart(lineStart);
+#if UDL_DEBUG_TIME
+    struct timeval t1, t2;
+    gettimeofday(&t1, NULL);
+#endif
+#if UDL_WINDEBUG
+    time_t t1, t2;
+    t1 = time(NULL);
+#endif
+    char *p_tagName;
+    for (lineNo = lineStart;
+         (lineNo <= lineEnd
+          || (p_tagStack
+              && lineNo <= lastLine
+              // && !p_tagStack->isEmpty()
+              && (p_tagName = p_tagStack->top()) != NULL
+              && is_member(p_tagName,
+                           strlen(p_tagName),
+                           html_close_tag_unnecessary)));
+         lineNo++) {
+        startLinePos = endLinePos;
+        endLinePos = lineNo == lineEnd ? endPos + 1 : styler.LineStart(lineNo + 1);
+        int foldChange = 0;
+        p_MainInfo->GetFoldChangeForLine(startLinePos, endLinePos, styler, foldChange, hasNonSpace, p_tagStack);
+        //fprintf(stderr, "**************** Change at line %d: %d\n", lineNo, foldChange);
+        levelCurrent += foldChange;
+        if (levelCurrent < 0)
+            levelCurrent = 0;
+        
+        int lev = levelPrev;
+        if (!hasNonSpace && foldCompact) {
+            lev |= SC_FOLDLEVELWHITEFLAG;
+        }
+        if ((levelCurrent > levelPrev) && hasNonSpace) {
+            lev |= SC_FOLDLEVELHEADERFLAG;
+        }
+        styler.SetLevel(lineNo, lev|SC_FOLDLEVELBASE);
+        levelPrev = levelCurrent;
+    }
+    delete p_tagStack;
+    LogEvent(false, "FoldUDLDoc", &styler);
+#if UDL_DEBUG
+    fprintf(stderr, "<< udl: FoldUDLDoc\n");
+#endif
+#if UDL_DEBUG_TIME
+    gettimeofday(&t2, NULL);
+    ShowElapsedTime("FoldUDLDoc", t1, t2);
+#endif
+#if UDL_WINDEBUG
+    t2 = time(NULL);
+    fprintf(stderr, "FoldUDLDoc: %d secs\n", t2 - t1);
+#endif
+}
+
+static const char * const UDLWordListDesc[] = {
+    "Keywords",
+    0
+};
+
+LexerModule lmUDL(SCLEX_UDL, ColouriseTemplate1Doc, "udl", FoldUDLDoc, UDLWordListDesc);
diff -ruN scintilla.orig/src/LexXSLT.cxx scintilla/src/LexXSLT.cxx
--- scintilla.orig/src/LexXSLT.cxx	1969-12-31 18:00:00.000000000 -0600
+++ scintilla/src/LexXSLT.cxx	2011-02-11 10:17:02.000000000 -0600
@@ -0,0 +1,913 @@
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Platform.h"
+
+#include "PropSet.h"
+#include "Accessor.h"
+#include "KeyWords.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+inline bool IsWhitespace (const unsigned char ch)
+{
+  return (ch == 0 || (ch < 128 && isspace(ch)));
+}
+
+#define isNameChar(ch) (((unsigned char)(ch) >= 128) \
+			|| (isalnum(ch) || (ch) == '_' || (ch) == '-' \
+                           || (ch) == '-' || (ch) == ':'))
+			
+
+// Don't make these STL maps in case we want to submit this to scintilla.
+
+static char* XSLT_TagNamesWithXPathAttribute[] = {
+  (char *) "xsl:apply-templates",
+  (char *) "xsl:copy-of",
+  (char *) "xsl:for-each",
+  (char *) "xsl:if",
+  (char *) "xsl:key",
+  (char *) "xsl:number",
+  (char *) "xsl:param",
+  (char *) "xsl:sort",
+  (char *) "xsl:template",
+  (char *) "xsl:value-of",
+  (char *) "xsl:variable",
+  (char *) "xsl:when",
+  (char *) "xsl:with-param",
+  0
+};
+  
+static char* XSLT_XPath_Attributes[] = {
+  (char *) "count",
+  (char *) "from",
+  (char *) "match",
+  (char *) "select",
+  (char *) "test",
+  (char *) "use",
+  (char *) "value",
+  0
+};
+  
+
+//Precondition: terms in LookupList[] are in ascending order.
+
+static bool FindMatch(char *LookupList[], char *term) {
+  int i = 0;
+  int res;
+  while (LookupList[i]) {
+    res = strcmp(term, LookupList[i]);
+    if (!res)
+      return true;
+    else if (res < 0)
+      return false;
+    i++;
+  }
+  return false;
+}
+
+#define HoldUp() i -= 1
+
+#define IncFoldCheck() if (fold && styler.SafeGetCharAt(i - 1) != '/') levelCurrent++
+
+#define DecFoldCheck() if (fold) levelCurrent--
+
+
+//Precondition:
+// currPos points to the last char of the attribute
+
+static bool InsideXPathElementWithXPathAttr(unsigned int currPos,
+					    Accessor &styler)
+{
+  unsigned int attrStart = styler.GetStartSegment();
+  unsigned int elementEnd;
+
+  // First what kind of element we're in
+  for (elementEnd = attrStart - 2;
+       elementEnd > 0;
+       elementEnd--) {
+    switch (styler.StyleAt(elementEnd)) {
+    case SCE_XPATH_TAG_NAME:
+      {
+	 char nameBuf[10];
+	 char *s = nameBuf;
+	 if (currPos >= attrStart
+	     && currPos - attrStart < (unsigned int)(sizeof(nameBuf) / sizeof(nameBuf[0]))) {
+	    unsigned int j;
+	    for (j = attrStart; j <= currPos; j++) {
+	       *s++ = styler[j];
+	    }
+	    *s = 0;
+	    return FindMatch (XSLT_XPath_Attributes, nameBuf);
+	 } else {
+	    return false;
+	 }
+      }
+      /*NOTREACHED*/
+      break;
+
+      case SCE_XML_START_TAG_NAME:
+	// We're in a standard element, so bail out.
+	return false;
+      }
+  }
+  return false;
+}
+
+
+static bool CheckIfNameIsXPathElement(int i,
+				      Accessor &styler)
+{
+  //todo: if this name is an XSLT name, color it so.
+  // i points to one past the end of the name
+
+  char nameBuf[30];
+  char *s = nameBuf;
+	 
+  int startingPoint = (int) styler.GetStartSegment();
+	 
+  if (startingPoint < i // sanity check
+      && i - startingPoint < (int)(sizeof(nameBuf) / sizeof(nameBuf[0]))) {
+    int j;
+    for (j = startingPoint; j < i; j++) {
+      *s++ = styler[j];
+    }
+    *s = 0;
+    if (FindMatch (XSLT_TagNamesWithXPathAttribute, nameBuf)) {
+      return true;
+    }
+  }
+  return false;
+}
+				      
+
+inline bool LookingAtNewline(const char ch,
+                             int i,
+                             Accessor &styler)
+{
+    return (ch == '\n' || (ch == '\r' && styler.SafeGetCharAt(i + 1) != '\n'));
+}
+
+
+inline bool LookingAtNewline(const char ch,
+                             const char chNext)
+{
+    return (ch == '\n' || (ch == '\r' && chNext != '\n'));
+}
+
+
+static void ColouriseXSLTDoc(unsigned int startPos,
+                             int length,
+                             int initStyle,
+                             WordList *[],
+                             Accessor &styler)
+{
+    int state = initStyle;
+    unsigned int lengthDoc = startPos + length;
+  
+    // Variables to allow folding.
+    bool fold = styler.GetPropertyInt("fold") != 0;
+    int lineCurrent = styler.GetLine(startPos);
+    int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
+    int levelCurrent = levelPrev;
+    bool hasVisibleChars = false;
+
+    styler.StartAt(startPos,63);
+    styler.StartSegment(startPos);
+
+    char ch;
+    // Prime this.
+    ch = styler.SafeGetCharAt(startPos);
+  
+    for (unsigned int i = startPos; i < lengthDoc; i++) {
+        // Update the char registers on each iteration in case i was
+        // messed with.
+     
+        ch = styler[i];
+
+        // Rule out common cases first
+        if (ch == '<') {
+            switch (state) {
+             case SCE_XML_START_TAG_OPEN:
+             case SCE_XML_START_TAG_NAME:
+             case SCE_XML_START_TAG_CLOSE:
+             case SCE_XML_START_TAG_EMPTY_CLOSE:
+             case SCE_XML_START_TAG_WHITE_SPACE:
+             case SCE_XML_START_TAG_ATTR_NAME:
+             case SCE_XML_START_TAG_ATTR_EQUALS:
+             case SCE_XML_START_TAG_ATTR_QUOT_CONTENT:
+             case SCE_XML_START_TAG_ATTR_APOS_CONTENT:
+             case SCE_XML_START_TAG_ATTR_QUOT_CLOSE:
+             case SCE_XML_START_TAG_ATTR_UNQUOTED:
+             case SCE_XML_END_TAG_NAME:
+             case SCE_XML_END_TAG_WHITE_SPACE:
+             case SCE_XML_ENTITY_REF:
+             case SCE_XML_CHAR_REF:
+             case SCE_XML_DATA_CHARS:
+             case SCE_XML_DATA_NEWLINE:
+             case SCE_XML_DECLARATION_TYPE:
+             case SCE_XML_DECLN_NAME:
+             case SCE_XML_DECLN_WHITE_SPACE:
+             case SCE_XML_DECLN_CLOSE:
+             case SCE_XML_DECLN_DATA_CHARS:
+	  
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_START_TAG_OPEN;
+                 continue;
+            }
+        } else if (ch == '&') {
+            switch (state) {
+             case SCE_XML_START_TAG_OPEN:
+             case SCE_XML_START_TAG_NAME:
+             case SCE_XML_START_TAG_CLOSE:
+             case SCE_XML_START_TAG_EMPTY_CLOSE:
+             case SCE_XML_START_TAG_WHITE_SPACE:
+             case SCE_XML_START_TAG_ATTR_NAME:
+             case SCE_XML_START_TAG_ATTR_EQUALS:
+             case SCE_XML_START_TAG_ATTR_QUOT_CLOSE:
+             case SCE_XML_END_TAG_NAME:
+             case SCE_XML_END_TAG_WHITE_SPACE:
+             case SCE_XML_ENTITY_REF:
+             case SCE_XML_CHAR_REF:
+             case SCE_XML_DATA_CHARS:
+             case SCE_XML_DATA_NEWLINE:
+                 styler.ColourTo(i - 1, state);
+                 if (styler.SafeGetCharAt(i + 1) == '#') {
+                     state = SCE_XML_CHAR_REF;
+                     i += 1;
+                 } else {
+                     state = SCE_XML_ENTITY_REF;
+                 }
+                 continue;
+            }
+        }
+
+        if (fold) {
+            if (LookingAtNewline(ch, i, styler)) {
+                // Apply folding at the end of the line (if required).
+                int lev = levelPrev;
+                if (!hasVisibleChars) {
+                    lev |= SC_FOLDLEVELWHITEFLAG;
+                }
+                if (levelCurrent > levelPrev) {
+                    lev |= SC_FOLDLEVELHEADERFLAG;
+                }
+                styler.SetLevel(lineCurrent++, lev);
+                levelPrev = (levelCurrent > 0) ? levelCurrent : 0; 
+                hasVisibleChars = false;
+            } else if (!hasVisibleChars) {
+                if (!IsWhitespace(ch)) {
+                    hasVisibleChars = true;
+                }
+            }
+        }
+
+        // How to speed this up:
+
+        // 1. Remove as many instances of HoldUp() as possible.
+     
+        // These routines should color both the previous and current
+        // state, and switch to the appropriate state.
+
+        // 
+
+        switch (state) {
+         case SCE_XML_DEFAULT:
+             // epsilon transition
+             if (LookingAtNewline(ch, i, styler))
+                 state = SCE_XML_DATA_NEWLINE;
+             else {
+                 HoldUp();
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_START_TAG_OPEN:
+             if (isNameChar (ch)) {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_START_TAG_NAME;
+             } else if (ch == '/') {
+                 state = SCE_XML_END_TAG_OPEN;
+             } else {
+                 char chNext = styler.SafeGetCharAt(i + 1);
+                 char chNext2 = styler.SafeGetCharAt(i + 2);
+                 if (ch == '!') {
+                     if (chNext == '-') {
+                         if (chNext2 == '-') {
+                             styler.ColourTo(i + 2, SCE_XML_COMMENT_OPEN);
+                             i += 2;
+                             state = SCE_XML_COMMENT_CONTENT;
+                         } else {
+                             styler.ColourTo(i + 1, SCE_XML_DATA_CHARS);
+                             i += 1;
+                             state = SCE_XML_DATA_CHARS;
+                         }
+                     } else if (chNext == '[') {
+                         if (chNext2 == 'C'
+                             && styler.SafeGetCharAt(i + 3) == 'D'
+                             && styler.SafeGetCharAt(i + 4) == 'A'
+                             && styler.SafeGetCharAt(i + 5) == 'T'
+                             && styler.SafeGetCharAt(i + 6) == 'A'
+                             && styler.SafeGetCharAt(i + 7) == '[') {
+                             styler.ColourTo(i + 7, SCE_XML_CDATA_SECT_OPEN);
+                             i += 7;
+                             state = SCE_XML_CDATA_SECT_CONTENT;
+                         } else {
+                             styler.ColourTo(i, SCE_XML_DATA_CHARS);
+                             i += 1;
+                             state = SCE_XML_DATA_CHARS;
+                         }
+                     } else if (isNameChar (chNext)) {
+                         styler.ColourTo(i, SCE_XML_DECLARATION_OPEN);
+                         state = SCE_XML_DECLARATION_TYPE;
+                     } else {
+                         state = SCE_XML_DATA_CHARS;
+                     }
+                 } else if (ch == '?') {
+                     if (chNext == 'x'
+                         && chNext2 == 'm'
+                         && styler.SafeGetCharAt(i + 3) == 'l'
+                         && IsWhitespace(styler.SafeGetCharAt(i + 4))) {
+                         styler.ColourTo(i + 3, SCE_XML_XML_DECL_OPEN);
+                         i += 3;
+                         state = SCE_XML_XML_DECL_CONTENT;
+                     } else {
+                         styler.ColourTo(i, SCE_XML_PI_OPEN);
+                         state = SCE_XML_PI_CONTENT;
+                     }
+                 } else if (LookingAtNewline(ch, chNext)) {
+                     state = SCE_XML_DATA_NEWLINE;
+                 } else {
+                     state = SCE_XML_DATA_CHARS;
+                     HoldUp();
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_NAME:
+             if (isNameChar (ch)) {
+                 // do nothing
+             } else {
+	  
+	 
+                 if (CheckIfNameIsXPathElement(i, styler)) {
+                     styler.ColourTo(i - 1, SCE_XPATH_TAG_NAME);
+                 } else {
+                     styler.ColourTo(i - 1, state);
+                 }
+	  
+                 if (IsWhitespace(ch)) {
+                     state = SCE_XML_START_TAG_WHITE_SPACE;
+                 } else if (ch == '/') {
+                     state = SCE_XML_START_TAG_EMPTY_CLOSE;
+                 } else if (ch == '>') {
+                     IncFoldCheck();
+                     state = SCE_XML_START_TAG_CLOSE;
+                 } else if (ch == '\'') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_APOS_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_APOS_CONTENT;
+                 } else if (ch == '"') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_QUOT_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_QUOT_CONTENT;
+                 } else {
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_CLOSE:
+             styler.ColourTo(i - 1, state);
+             if (LookingAtNewline(ch, i, styler))
+                 state = SCE_XML_DATA_NEWLINE;
+             else {
+                 state = SCE_XML_DATA_CHARS;
+                 HoldUp();
+             }
+             break;
+
+         case SCE_XML_START_TAG_EMPTY_CLOSE:
+             if (ch == '>') {
+                 styler.ColourTo(i, state);
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (LookingAtNewline(ch, i, styler)) {
+                     state = SCE_XML_DATA_NEWLINE;
+                 } else {
+                     HoldUp();
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_WHITE_SPACE:
+             if (IsWhitespace(ch)) {
+                 // stay
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (isNameChar (ch)) {
+                     state = SCE_XML_START_TAG_ATTR_NAME;
+                 } else if (ch == '/') {
+                     state = SCE_XML_START_TAG_EMPTY_CLOSE;
+                 } else if (ch == '>') {
+                     IncFoldCheck();
+                     state = SCE_XML_START_TAG_CLOSE;
+                 } else if (ch == '\'') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_APOS_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_APOS_CONTENT;
+                 } else if (ch == '"') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_QUOT_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_QUOT_CONTENT;
+                 } else {
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_NAME:
+             if (isNameChar (ch)) {
+                 // stay
+             } else {
+                 bool IsXPathAttr = InsideXPathElementWithXPathAttr(i - 1, styler);
+                 state = IsXPathAttr ? SCE_XPATH_ATTR_NAME: SCE_XML_START_TAG_ATTR_NAME;
+                 styler.ColourTo(i - 1, state);
+                 if (IsWhitespace(ch) || ch == '=') {
+                     state = SCE_XML_START_TAG_ATTR_EQUALS;
+                 } else if (ch == '/') {
+                     state = SCE_XML_START_TAG_EMPTY_CLOSE;
+                 } else if (ch == '>') {
+                     IncFoldCheck();
+                     state = SCE_XML_START_TAG_CLOSE;
+                 } else if (ch == '\'') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_APOS_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_APOS_CONTENT;
+                 } else if (ch == '"') {
+                     styler.ColourTo(i, SCE_XML_START_TAG_ATTR_QUOT_OPEN);
+                     state = SCE_XML_START_TAG_ATTR_QUOT_CONTENT;
+                 } else {
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_EQUALS:
+             if (IsWhitespace(ch) || ch == '=') {
+                 // stay
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (ch == '\'' || ch == '"') {
+                     int j;
+                     bool useXPathAttr = false;
+                     for (j = i - 2; j > 0; j--) {
+                         switch (styler.StyleAt(j)) {
+                          case SCE_XPATH_ATTR_NAME:
+                              useXPathAttr = true;
+                              j = 0;
+                              break;
+		 
+                          case SCE_XML_START_TAG_ATTR_NAME:
+                              useXPathAttr = false;
+                              j = 0;
+                              break;
+                         }
+                     }
+                     if (useXPathAttr) {
+                         styler.ColourTo(i, SCE_XPATH_OPEN);
+                         if (ch == '\'') {
+                             state = SCE_XPATH_CONTENT_APOS;
+                         } else {
+                             state = SCE_XPATH_CONTENT_QUOT;
+                         }
+                     } else {
+                         if (ch == '\'') {
+                             styler.ColourTo(i, SCE_XML_START_TAG_ATTR_APOS_OPEN);
+                             state = SCE_XML_START_TAG_ATTR_APOS_CONTENT;
+                         } else {
+                             styler.ColourTo(i, SCE_XML_START_TAG_ATTR_QUOT_OPEN);
+                             state = SCE_XML_START_TAG_ATTR_QUOT_CONTENT;
+                         }
+                     }
+                 } else if (ch == '/') {
+                     state = SCE_XML_START_TAG_EMPTY_CLOSE;
+                 } else if (ch == '>') {
+                     IncFoldCheck();
+                     state = SCE_XML_START_TAG_CLOSE;
+                 } else {
+                     // Allow old-style unquoted attr values
+                     state = SCE_XML_START_TAG_ATTR_UNQUOTED;
+                 }
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_QUOT_OPEN:
+             styler.ColourTo(i, state);
+             state = SCE_XML_START_TAG_ATTR_QUOT_CONTENT;
+             break;
+
+         case SCE_XML_START_TAG_ATTR_QUOT_CONTENT:
+             if (ch == '"') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_START_TAG_ATTR_QUOT_CLOSE;
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_QUOT_CLOSE:
+         case SCE_XML_START_TAG_ATTR_APOS_CLOSE:
+             styler.ColourTo(i - 1, state);
+             if (IsWhitespace(ch)) {
+                 state = SCE_XML_START_TAG_WHITE_SPACE;
+             } else if (ch == '/') {
+                 state = SCE_XML_START_TAG_EMPTY_CLOSE;
+             } else if (ch == '>') {
+                 IncFoldCheck();
+                 state = SCE_XML_START_TAG_CLOSE;
+             } else {
+                 state = SCE_XML_START_TAG_WHITE_SPACE;
+                 if (!LookingAtNewline(ch, i, styler))
+                     HoldUp();
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_APOS_OPEN:
+             styler.ColourTo(i - 1, state);
+             state = SCE_XML_START_TAG_ATTR_APOS_CONTENT;
+             break;
+
+         case SCE_XML_START_TAG_ATTR_APOS_CONTENT:
+             if (ch == '\'') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_START_TAG_ATTR_APOS_CLOSE;
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_UNQUOTED:
+             if (ch == '>') {
+                 styler.ColourTo(i - 1, state);
+                 IncFoldCheck();
+                 state = SCE_XML_START_TAG_CLOSE;
+             } else if (IsWhitespace(ch)) {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_START_TAG_WHITE_SPACE;
+             } else {
+                 // stay
+             }
+             break;
+
+         case SCE_XML_END_TAG_OPEN:
+             styler.ColourTo(i - 1, state);
+             state = SCE_XML_END_TAG_NAME;
+             break;
+
+         case SCE_XML_END_TAG_NAME:
+             if (isNameChar (ch)) {
+                 // stay
+             } else {
+                 if (CheckIfNameIsXPathElement(i, styler)) {
+                     styler.ColourTo(i - 1, SCE_XPATH_TAG_NAME);
+                 } else {
+                     styler.ColourTo(i - 1, state);
+                 }
+                 if (IsWhitespace(ch)) {
+                     state = SCE_XML_END_TAG_WHITE_SPACE;
+                 } else {
+                     state = SCE_XML_END_TAG_CLOSE;
+                     DecFoldCheck();
+                 }
+             }
+             break;
+
+         case SCE_XML_END_TAG_WHITE_SPACE:
+             if (IsWhitespace(ch)) {
+                 // stay
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (ch == '>') {
+                     state = SCE_XML_END_TAG_CLOSE;
+                     DecFoldCheck();
+                 } else {
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+	
+         case SCE_XML_END_TAG_CLOSE:
+             styler.ColourTo(i - 1, state);
+             if (LookingAtNewline(ch, i, styler))
+                 state = SCE_XML_DATA_NEWLINE;
+             else {
+                 HoldUp();
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_START_TAG_ATTR_NUMBER:
+             // Not used
+             if (LookingAtNewline(ch, i, styler))
+                 state = SCE_XML_DATA_NEWLINE;
+             else {
+                 HoldUp();
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_ENTITY_REF:
+             if (isNameChar (ch)) {
+                 // stay
+             } else {
+                 if (ch == ';') {
+                     styler.ColourTo(i, state);
+                 } else {
+                     styler.ColourTo(i - 1, state);
+                     if (LookingAtNewline(ch, i, styler))
+                         state = SCE_XML_DATA_NEWLINE;
+                     else {
+                         HoldUp();
+                         state = SCE_XML_DATA_CHARS;
+                     }
+                 }
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_CHAR_REF:
+             if ((unsigned int) ch < 128 && isalnum (ch)) {
+                 // stay
+             } else {
+                 if (ch == ';') {
+                     styler.ColourTo(i, state);
+                 } else {
+                     styler.ColourTo(i - 1, state);
+                     if (LookingAtNewline(ch, i, styler))
+                         state = SCE_XML_DATA_NEWLINE;
+                     else {
+                         HoldUp();
+                         state = SCE_XML_DATA_CHARS;
+                     }
+                 }
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_DATA_NEWLINE:
+             if (ch == '\r' || ch == '\n') {
+                 // stay
+             } else {
+                 // We don't have a < or &, so don't hold up.
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_DATA_CHARS:
+             if (ch == '\r' || ch == '\n') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DATA_NEWLINE;
+             }
+             // otherwise stay.
+             break;
+
+         case SCE_XML_CDATA_SECT_OPEN:
+             styler.ColourTo(i - 1, state);
+             if (ch == ']') {
+                 HoldUp();
+             }
+             state = SCE_XML_CDATA_SECT_CONTENT;
+             break;
+
+         case SCE_XML_CDATA_SECT_CONTENT:
+             if (ch == ']'
+                 && styler.SafeGetCharAt(i + 1) == ']'
+                 && styler.SafeGetCharAt(i + 2) == '>') {
+                 styler.ColourTo(i - 1, state);
+                 i += 2;
+                 styler.ColourTo(i, SCE_XML_CDATA_SECT_CLOSE);
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_CDATA_SECT_CLOSE:
+             // Shouldn't happen
+             styler.ColourTo(i - 1, state);
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XML_COMMENT_OPEN:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XML_COMMENT_CONTENT:
+             if (ch == '-'
+                 && styler.SafeGetCharAt(i + 1) == '-'
+                 && styler.SafeGetCharAt(i + 2) == '>') {
+                 styler.ColourTo(i - 1, state);
+                 i += 2;
+                 styler.ColourTo(i, SCE_XML_COMMENT_CLOSE);
+                 state = SCE_XML_DATA_CHARS;
+             } 
+             break;
+
+         case SCE_XML_COMMENT_CLOSE:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XML_PI_OPEN:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XML_PI_CONTENT:
+             if (ch == '?' && styler.SafeGetCharAt(i + 1) == '>') {
+                 styler.ColourTo(i - 1, state);
+                 i += 1;
+                 styler.ColourTo(i, SCE_XML_PI_CLOSE);
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_PI_CLOSE:
+             // Shouldn't happen
+             break;
+
+         case SCE_XML_XML_DECL_OPEN:
+             // Shouldn't happen
+             break;
+
+         case SCE_XML_XML_DECL_CONTENT:
+             if (ch == '?' && styler.SafeGetCharAt(i + 1) == '>') {
+                 styler.ColourTo(i - 1, state);
+                 i += 1;
+                 styler.ColourTo(i, SCE_XML_XML_DECL_CLOSE);
+                 state = SCE_XML_DATA_CHARS;
+             }
+             break;
+
+         case SCE_XML_XML_DECL_CLOSE:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XML_BOM:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XPATH_TAG_NAME:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XPATH_ATTR_NAME:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XPATH_OPEN:
+             // Shouldn't happen
+             state = SCE_XML_DATA_CHARS;
+             break;
+
+         case SCE_XPATH_CONTENT_QUOT:
+             if (ch == '"') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XPATH_CLOSE;
+             }
+             break;
+
+         case SCE_XPATH_CONTENT_APOS:
+             if (ch == '\'') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XPATH_CLOSE;
+             }
+             break;
+
+         case SCE_XPATH_CLOSE:
+             styler.ColourTo(i - 1, state);
+             if (!LookingAtNewline(ch, i, styler))
+                 HoldUp();
+             state = SCE_XML_START_TAG_WHITE_SPACE;
+             break;
+
+         case SCE_XML_DECLARATION_TYPE:
+         case SCE_XML_DECLN_NAME:
+             if (isNameChar (ch)) {
+                 // stay
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (IsWhitespace(ch) || ch == '%') {
+                     state = SCE_XML_DECLN_WHITE_SPACE;
+                 } else if (ch == '>') {
+                     state = SCE_XML_DECLN_CLOSE;
+                 } else if (ch == '"') {
+                     state = SCE_XML_DECLN_QUOT_CONTENT;
+                 } else if (ch == '\'') {
+                     state = SCE_XML_DECLN_APOS_CONTENT;
+                 } else if (ch == ']') {
+                     if (styler.SafeGetCharAt(i + 1) == '>') {
+                         i++;
+                         styler.ColourTo(i, SCE_XML_DECLN_DATA_CHARS);
+                         state = SCE_XML_DATA_CHARS;
+                     }
+                 } else {
+                     if (!LookingAtNewline(ch, i, styler))
+                         HoldUp();
+                     state = SCE_XML_DECLN_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_DECLN_WHITE_SPACE:
+             if (IsWhitespace(ch) || ch == '%') {
+                 // stay
+             } else {
+                 styler.ColourTo(i - 1, state);
+                 if (isNameChar (ch)) {
+                     state = SCE_XML_DECLN_NAME;
+                 } else if (ch == '>') {
+                     state = SCE_XML_DECLN_CLOSE;
+                 } else if (ch == '"') {
+                     state = SCE_XML_DECLN_QUOT_CONTENT;
+                 } else if (ch == '\'') {
+                     state = SCE_XML_DECLN_APOS_CONTENT;
+                 } else if (ch == ']') {
+                     if (styler.SafeGetCharAt(i + 1) == '>') {
+                         i++;
+                         styler.ColourTo(i, SCE_XML_DECLN_DATA_CHARS);
+                         state = SCE_XML_DATA_CHARS;
+                     }
+                 } else {
+                     if (!LookingAtNewline(ch, i, styler))
+                         HoldUp();
+                     state = SCE_XML_DECLN_DATA_CHARS;
+                 }
+             }
+             break;
+
+         case SCE_XML_DECLN_QUOT_CONTENT:
+             if (ch == '"') {
+                 styler.ColourTo(i, state);
+                 state = SCE_XML_DECLN_WHITE_SPACE;
+             }
+             break;
+
+         case SCE_XML_DECLN_APOS_CONTENT:
+             if (ch == '\'') {
+                 styler.ColourTo(i, state);
+                 state = SCE_XML_DECLN_WHITE_SPACE;
+             }
+             break;
+
+         case SCE_XML_DECLN_CLOSE:
+             styler.ColourTo(i - 1, state);
+             if (!LookingAtNewline(ch, i, styler))
+                 HoldUp();
+             state = SCE_XML_DECLN_DATA_CHARS;
+             break;
+
+         case SCE_XML_DECLN_DATA_CHARS:
+             if (isNameChar (ch)) {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DECLN_NAME;
+             } else if (ch == '>') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DECLN_CLOSE;
+             } else if (ch == '"') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DECLN_QUOT_CONTENT;
+             } else if (ch == '\'') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DECLN_APOS_CONTENT;
+             } else if (IsWhitespace(ch) || ch == '%') {
+                 styler.ColourTo(i - 1, state);
+                 state = SCE_XML_DECLN_WHITE_SPACE;
+             } else if (ch == ']') {
+                 if (styler.SafeGetCharAt(i + 1) == '>') {
+                     i++;
+                     styler.ColourTo(i, state);
+                     state = SCE_XML_DATA_CHARS;
+                 }
+             }
+             break;
+
+         default:
+             // Shouldn't see this.
+             HoldUp();
+             state = SCE_XML_DATA_CHARS;
+        }
+    }
+    styler.ColourTo(lengthDoc - 1, state);
+    if (fold) {
+        int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
+        styler.SetLevel(lineCurrent, levelPrev | flagsNext);
+    }
+}
+
+  //LexerModule lmXSLT(SCLEX_XSLT, ColouriseXSLTDoc, "XSLT", (LexerFunction) 0);
+LexerModule lmXSLT(SCLEX_XSLT, ColouriseXSLTDoc, "xslt");
diff -ruN scintilla.orig/src/PropSet.cxx scintilla/src/PropSet.cxx
--- scintilla.orig/src/PropSet.cxx	2010-02-16 18:39:46.000000000 -0600
+++ scintilla/src/PropSet.cxx	2011-05-29 23:12:56.000000000 -0500
@@ -17,7 +17,6 @@
 #endif
 
 #include <string>
-#include <map>
 
 #include "Platform.h"
 
@@ -28,7 +27,6 @@
 using namespace Scintilla;
 #endif
 
-typedef std::map<std::string, std::string> mapss;
 
 PropSetSimple::PropSetSimple() {
 	mapss *props = new mapss;
diff -ruN scintilla.orig/src/PropSetSimple.h scintilla/src/PropSetSimple.h
--- scintilla.orig/src/PropSetSimple.h	2009-07-21 03:55:42.000000000 -0500
+++ scintilla/src/PropSetSimple.h	2011-05-29 23:16:30.000000000 -0500
@@ -8,14 +8,20 @@
 #ifndef PROPSETSIMPLE_H
 #define PROPSETSIMPLE_H
 
+#include "PropSet.h"
+#include <map>
+#include <string>
+
 #ifdef SCI_NAMESPACE
 namespace Scintilla {
 #endif
 
+typedef std::map<std::string, std::string> mapss;
+
 class PropSetSimple : public PropertyGet {
-	void *impl;
 	void Set(const char *keyVal);
 public:
+	void *impl;
 	PropSetSimple();
 	virtual ~PropSetSimple();
 	void Set(const char *key, const char *val, int lenKey=-1, int lenVal=-1);
